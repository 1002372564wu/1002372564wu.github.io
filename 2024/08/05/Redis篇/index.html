<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis常见数据类型及其应用场景（⭐）    Redis 中比较常见的数据类型有：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。    String：一般用于存储一些常规数据，如Session、Token、序列化后的对象，还可以用来实现分布式锁。  Hash：适合用于存储对象信息。  List：底层为一个双向链表，支持从左右两边获取元素以及弹出">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2024/08/05/Redis%E7%AF%87/index.html">
<meta property="og:site_name" content="Michael-Jay">
<meta property="og:description" content="Redis常见数据类型及其应用场景（⭐）    Redis 中比较常见的数据类型有：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。    String：一般用于存储一些常规数据，如Session、Token、序列化后的对象，还可以用来实现分布式锁。  Hash：适合用于存储对象信息。  List：底层为一个双向链表，支持从左右两边获取元素以及弹出">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/08/05/Redis%E7%AF%87/1.png">
<meta property="article:published_time" content="2024-08-05T00:47:38.453Z">
<meta property="article:modified_time" content="2024-08-07T09:07:34.680Z">
<meta property="article:author" content="吴华杰">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/08/05/Redis%E7%AF%87/1.png">

<link rel="canonical" href="http://example.com/2024/08/05/Redis%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis | Michael-Jay</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
   <script type="text/javascript" src="/js/clicklove.js"></script>
  

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Michael-Jay</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="/study/" rel="section"><i class="fas fa-marker fa-fw"></i>技术</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-practice">

    <a href="/practice/" rel="section"><i class="fas fa-building fa-fw"></i>实习</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/05/Redis%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/jay.jpg">
      <meta itemprop="name" content="吴华杰">
      <meta itemprop="description" content="Time will tell">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Michael-Jay">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-05 08:47:38" itemprop="dateCreated datePublished" datetime="2024-08-05T08:47:38+08:00">2024-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-07 17:07:34" itemprop="dateModified" datetime="2024-08-07T17:07:34+08:00">2024-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Redis常见数据类型及其应用场景（⭐）"><a href="#Redis常见数据类型及其应用场景（⭐）" class="headerlink" title="Redis常见数据类型及其应用场景（⭐）"></a>Redis常见数据类型及其应用场景（⭐）</h1><pre><code>    Redis 中比较常见的数据类型有：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。 
</code></pre>
<ul>
<li><p><strong>String</strong>：一般用于存储一些常规数据，如Session、Token、序列化后的对象，还可以用来实现分布式锁。</p>
</li>
<li><p><strong>Hash</strong>：适合用于存储对象信息。</p>
</li>
<li><p><strong>List</strong>：底层为一个双向链表，支持从左右两边获取元素以及弹出元素，可以使用range命令查看范围内的元素。 List可用作消息队列，但一般不推荐使用。</p>
</li>
<li><p><strong>Set</strong>：无序集合，集合内元素没有顺序且唯一。 基于set可以轻易的实现交集、并集、差集的操作，因此Set常用于实现共同关注、共同好友等功能。</p>
</li>
<li><p><strong>Zset</strong>：类似于Set，只是每个元素加了一个score字段，元素会根据score的大小进行排序，并且可以根据score值进行范围查询。常用于实现排行榜等功能。</p>
<pre><code>还有特殊的数据类型：
</code></pre>
</li>
<li><p><strong>BitMap</strong> ：底层是一个由0、1组成的二进制串，常用命令：setbit key offset value；getbit key offset； 通常用于用户签到等场景：key为[当前年份：用户id]，offset为[当前天数]。</p>
</li>
<li><p><strong>HyperLogLog</strong> ：能够使用极少的内存来统计巨量的数据，如统计百万级访问量网页的用户点击次数。在 Redis 中实现的 HyperLogLog，只需要12K内存就能统计2^64个数据。 但是计数存在一定的误差，标准误差为 0.81% 。</p>
</li>
<li><p><strong>Geospatial</strong>：主要用于存储地理位置信息，通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>
</li>
</ul>
<h1 id="Redis有什么优点和缺点？"><a href="#Redis有什么优点和缺点？" class="headerlink" title="Redis有什么优点和缺点？"></a>Redis有什么优点和缺点？</h1><p><strong>优点：</strong></p>
<ul>
<li><strong>速度快</strong>：Redis是基于内存的，并且是单线程的，还采用了IO多路复用模型。</li>
<li><strong>支持丰富的数据类型。</strong></li>
<li><strong>提供了持久化策略</strong>：RDB和AOF等持久化策略。</li>
<li><strong>提供高并发和高可用的Redis集群</strong>。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Redis是内存数据库，存储的数据量有限，需要制定数据过期策略定期删除数据。</li>
</ul>
<h1 id="什么是缓存穿透-怎么解决-（⭐）"><a href="#什么是缓存穿透-怎么解决-（⭐）" class="headerlink" title="什么是缓存穿透 ? 怎么解决 ?（⭐）"></a>什么是缓存穿透 ? 怎么解决 ?（⭐）</h1><pre><code>    缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存就形同虚设（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。
  
</code></pre>
<p> <strong>解决方案：</strong></p>
<ul>
<li><strong>缓存空对象</strong>：如果该数据在缓存和数据库中都不存在，就缓存一个空值到redis中，并且超时时间设置得短一点，如2分钟，以防占用太多redis空间。</li>
<li><strong>布隆过滤</strong>：布隆过滤器是由初始值都为 0 的位图数组和若干个个哈希函数组成的数据结构，通常用于从海量数据中判断某数字是否存在，应用场景如缓存穿透、垃圾邮件过滤。布隆过滤器会通过若干个哈希函数计算数据的哈希值并取模，在位图中对应位置设为1。客户端的所有请求都会先通过该过滤器进行过滤，由于哈希的性质，若该过滤器都查不到数据，则直接返回错误信息；若查到了则放行，但也不一定存在该数据(存在哈希冲突)。</li>
</ul>
<h1 id="什么是缓存击穿-怎么解决-（⭐）"><a href="#什么是缓存击穿-怎么解决-（⭐）" class="headerlink" title="什么是缓存击穿? 怎么解决 ?（⭐）"></a>什么是缓存击穿? 怎么解决 ?（⭐）</h1><pre><code>    缓存击穿也叫热点Key问题，一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。
</code></pre>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>互斥锁</strong>：只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求。<ul>
<li>优点：强一致性。</li>
<li>缺点：性能差。</li>
</ul>
</li>
<li><strong>逻辑过期</strong>：①在缓存中多设置一个逻辑过期字段，而不真正设置过期时间。②查询时，通过过期字段来判断当前key是否过期。③<strong>若过期，则另外开一个线程去数据库查询并同步缓存数据，当前线程则返回旧数据。</strong><ul>
<li>优点：性能高，具有高可用性。</li>
<li>缺点：无法保证数据绝对一致。</li>
</ul>
</li>
</ul>
<h1 id="什么是缓存雪崩-怎么解决-（⭐）"><a href="#什么是缓存雪崩-怎么解决-（⭐）" class="headerlink" title="什么是缓存雪崩? 怎么解决 ?（⭐）"></a>什么是缓存雪崩? 怎么解决 ?（⭐）</h1><pre><code>    缓存雪崩是指在同一时间段，大量缓存的key同时失效，或者Redis服务宕机，导致大量请求到达数据库。
</code></pre>
<p><strong>解决方案：</strong></p>
<ul>
<li>给不同的Key的TTL添加随机值，让其在不同时间段分批失效。</li>
<li>利用Redis集群提高服务的可用性。（哨兵模式，集群模式）</li>
<li>给缓存业务添加降级限流策略。（保底策略）</li>
<li>给业务添加多级缓存。（可以理解为穿了好几件防弹衣）。</li>
</ul>
<h1 id="mysql如何与redis进行同步？（⭐）"><a href="#mysql如何与redis进行同步？（⭐）" class="headerlink" title="mysql如何与redis进行同步？（⭐）"></a>mysql如何与redis进行同步？（⭐）</h1><p>业务中有优惠券秒杀功能，要求实时性比较高，因此采用读写锁保证redis和mysql的强一致性。 主要采用redisson实现的读写锁，读的时候添加共享锁（读锁），保证读读不互斥，读写互斥；更新数据的时候添加排他锁（写锁），读读、读写都互斥。 这样可以防止写数据的时候其他线程读数据，避免了脏数据。</p>
<blockquote>
<p><strong>缓存的更新策略：当用户修改数据时，应该先删缓存还是先修改数据库？</strong></p>
<ul>
<li><strong>先删缓存</strong>：修改数据库的途中，有别的线程来访问该数据就会把脏数据读入缓存。</li>
<li><strong>先更新数据库</strong>：删完缓存还没提交事务的这段时间空隙，有别的线程来访问数据也会访问到脏数据并读入内存，但是发生的机率较小。</li>
</ul>
</blockquote>
<p><strong>延时双删：</strong> 延时双删也是分布式系统中保持redis和mysql一致性的常用策略，但不具有强一致性。</p>
<ul>
<li><strong>延时双删：当前为写操作时，先删除redis中的缓存，再更新数据库，短暂延时之后再次删除redis中的缓存。</strong><ul>
<li>为什么要两次删除redis缓存？<ul>
<li>防止数据库还没更新完，有别的线程读取了数据库的脏数据，并更新redis缓存。</li>
</ul>
</li>
<li>为什么要延时删除？<ul>
<li>数据库一般是主从模式，需要给主节点一些时间同步数据到从节点中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="redis做为缓存，数据的持久化是怎么做的？（⭐）"><a href="#redis做为缓存，数据的持久化是怎么做的？（⭐）" class="headerlink" title="redis做为缓存，数据的持久化是怎么做的？（⭐）"></a>redis做为缓存，数据的持久化是怎么做的？（⭐）</h1><pre><code>    Redis是内存数据库，宕机后数据会消失，需要提供持久化策略。在Redis中提供了两种数据持久化的方式：RDB 和 AOF。
</code></pre>
<ul>
<li><strong>RDB（Redis DataBase）</strong>：是一个快照文件，它把redis内存存储的数据写到磁盘上，当redis 宕机恢复数据的时候，方便从 RDB 的快照文件中恢复数据。<ul>
<li><strong>优点</strong>：RDB是二进制压缩文件，占用空间小，便于传输，恢复数据速度较快。</li>
<li><strong>缺点</strong>：两次RDB期间有空档期，此期间若Redis宕机了可能会造成数据的丢失。</li>
<li><strong>创建RDB文件的两个命令</strong>：<ul>
<li><strong>SAVE</strong>：会阻塞Redis服务器进程，直到RDB文件创建完毕为止。</li>
<li><strong>BGSAVE</strong>：会派生出一个子进程负责创建RDB文件，父进程继续处理命令请求。</li>
</ul>
</li>
</ul>
</li>
<li><strong>AOF（append only file）</strong>：当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。（AOF会记录过程，RDB只管结果）<ul>
<li><strong>优点</strong>：数据的完整性较高。</li>
<li><strong>缺点</strong>：文件较大，恢复速度较慢。</li>
</ul>
</li>
<li><strong>RDB-AOF混合持久化</strong>：该模式会将生成相应的RDB数据，写入AOF文件中，重写后的新 AOF 文件前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。这样用户可以同时获得RDB持久化和AOF持久化的优点。</li>
</ul>
<h1 id="Redis的数据过期策略有哪些-（⭐）"><a href="#Redis的数据过期策略有哪些-（⭐）" class="headerlink" title="Redis的数据过期策略有哪些 ?（⭐）"></a>Redis的数据过期策略有哪些 ?（⭐）</h1><p>Redis的过期删除策略：惰性删除 + 定期删除两种策略进行配合使用。</p>
<ul>
<li><strong>惰性删除</strong>：设置该key过期时间后，不去管它，当需要该key时，再检查其是否过期，如果过期，我们就删掉它，反之返回该key。<ul>
<li>优点：对CPU友好，只在使用该key时才进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</li>
<li>缺点：对内存不友好，过期的key将一直存在于内存中不会释放。</li>
</ul>
</li>
<li><strong>定期删除：</strong> 每隔一段时间，我们就对一些key进行检查，删除里面过期的key。<ul>
<li>优点：可以通过限制删除操作执行的时长来减少对 CPU性能的影响。</li>
<li>缺点：这个操作时长难以把控。</li>
</ul>
</li>
</ul>
<h1 id="redis的数据淘汰策略"><a href="#redis的数据淘汰策略" class="headerlink" title="redis的数据淘汰策略"></a>redis的数据淘汰策略</h1><p><strong>Redis支持8种不同策略来选择要删除的key：</strong></p>
<ul>
<li><strong>noeviction</strong>： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li>
<li><strong>volatile-ttl</strong>： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰。</li>
<li><strong>allkeys-random</strong>：对全体key ，随机进行淘汰。</li>
<li><strong>volatile-random</strong>：对设置了TTL的key ，随机进行淘汰。</li>
<li><strong>allkeys-lru</strong>： 对全体key，基于LRU算法进行淘汰。</li>
<li><strong>volatile-lru</strong>： 对设置了TTL的key，基于LRU算法进行淘汰。</li>
<li><strong>allkeys-lfu</strong>： 对全体key，基于LFU算法进行淘汰。</li>
<li><strong>volatile-lfu</strong>： 对设置了TTL的key，基于LFU算法进行淘汰。</li>
</ul>
<h2 id="LRU和LFU两种策略："><a href="#LRU和LFU两种策略：" class="headerlink" title="LRU和LFU两种策略："></a>LRU和LFU两种策略：</h2><ul>
<li><strong>LRU（Least Recently Used）：</strong> 最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li>
<li><strong>LFU（Least Frequently Used）：</strong> 最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li>
</ul>
<h2 id="数据库有1000万数据-Redis只能缓存20w数据-如何保证Redis中数据都是热点数据"><a href="#数据库有1000万数据-Redis只能缓存20w数据-如何保证Redis中数据都是热点数据" class="headerlink" title="数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中数据都是热点数据 ?"></a>数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中数据都是热点数据 ?</h2><p>使用<strong>allkeys-lru</strong>(最近最少使用)淘汰策略，留下来的都是经常访问的热点数据。</p>
<h2 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h2><p>看数据淘汰策略是什么，如果是默认的配置（ noeviction ），会直接报错。</p>
<h1 id="Redis分布式锁的实现"><a href="#Redis分布式锁的实现" class="headerlink" title="Redis分布式锁的实现"></a>Redis分布式锁的实现</h1><p>   项目中的 <strong>优惠券秒杀抢单功能</strong> 存在<strong>超卖问题</strong>，可以使用<strong>Synchronized</strong>锁解决。但如果是在集群模式下， 多台服务器会对应多个jvm， <strong>synchronized</strong>锁可以锁住单台服务器的多线程，多台服务器就锁不住了，此时需要有一个多服务器共享的锁监视器，即<strong>分布式锁</strong>。<br>   Redis实现<strong>分布式锁</strong>主要利用Redis的<strong>setnx命令(SET if not exists)</strong> ，该命令需要<strong>设置锁的过期时间</strong>，以<strong>防止服务宕机从而导致锁永远无法释放</strong>的问题。这个过期时间设置长了会影响性能，设置短了又可能会提前释放锁导致线程安全问题，这就需要<strong>合理的控制锁的有效时长</strong>。</p>
<h2 id="Redisson实现分布式锁如何合理的控制锁的有效时长？"><a href="#Redisson实现分布式锁如何合理的控制锁的有效时长？" class="headerlink" title="Redisson实现分布式锁如何合理的控制锁的有效时长？"></a>Redisson实现分布式锁如何合理的控制锁的有效时长？</h2><p>   于是我们使用采用<strong>redisson</strong>实现的<strong>分布式锁</strong>，底层是<strong>setnx和lua脚本</strong>（保证原子性）。在redisson的分布式锁中，提供了一个<strong>WatchDog(看门狗）机制：一个线程获取锁成功以后，会定期给锁续期（默认每10s续期一次）。</strong></p>
<h2 id="Redisson的这个锁，可以重入吗？"><a href="#Redisson的这个锁，可以重入吗？" class="headerlink" title="Redisson的这个锁，可以重入吗？"></a>Redisson的这个锁，可以重入吗？</h2><p>   <strong>可重入，这样做是为了避免死锁的产生</strong>。多个锁重入需要判断是否是同一线程，<strong>在redis中进行存储的时候使用的hash结构，来存储线程信息和重入的次数：大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数。</strong></p>
<h2 id="Redisson锁能解决主从数据一致的问题吗？"><a href="#Redisson锁能解决主从数据一致的问题吗？" class="headerlink" title="Redisson锁能解决主从数据一致的问题吗？"></a>Redisson锁能解决主从数据一致的问题吗？</h2><p>   不能解决，但可以使用redisson提供的红锁来解决，但是使用红锁性能太低了，如果业务中非要保证数据的强一致性，建议采用zookeeper实现的分布式锁。</p>
<h1 id="Redis的集群方案（⭐）"><a href="#Redis的集群方案（⭐）" class="headerlink" title="Redis的集群方案（⭐）"></a>Redis的集群方案（⭐）</h1><p>Redis中提供的集群方案总共有三种：<strong>主从集群</strong>、<strong>哨兵模式</strong>、<strong>Redis</strong> <strong>分片集群。</strong></p>
<h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><p>单节点Redis的并发能力是有上限的，要<strong>进一步提高Redis的并发能力</strong>，可以搭建<strong>主从集群</strong>，实现<strong>读写分离</strong>。一般都是<strong>一主多从，主节点负责写数据，从节点负责读数据</strong>，主节点写入数据之后，需要把数据同步到从节点中。<br>主从同步数据的流程：分为<strong>全量同步</strong>和<strong>增量同步</strong>。</p>
<ul>
<li><strong>全量同步：</strong> 从节点第一次与主节点建立连接的时候使用全量同步。<ul>
<li>从节点请求主节点<strong>同步数据</strong>，从节点会携带自己的<strong>replication</strong> <strong>id</strong>和<strong>offset</strong>偏移量。	</li>
<li>主节点判断是否是第一次请求，主要判断依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己replication id和offset发送给从节点，让从节点与主节点的信息保持一致。 </li>
<li>此时主节点会执行bgsave生成rdb文件，同时将此时收到的写命令缓存起来，将 rdb 文件发送给从节点去同步，接着将缓存中的写命令也发送给从节点同步。（<strong>同步数据的过程中，主节点和从节点都是正常工作的，并且从节点是基于旧数据对外提供服务的</strong>）</li>
</ul>
</li>
<li><strong>增量同步：</strong><ul>
<li>从节点请求主节点同步数据，主节点还是判断是不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。</li>
</ul>
</li>
</ul>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis提供了<strong>哨兵（Sentinel）机制</strong>来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p>
<ul>
<li><strong>监测</strong>：Sentinel 会基于心跳机制不断检查master和slave是否按预期工作：<ul>
<li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li>
<li>客观下线：若超过一半的sentinel都认为该实例主观下线，则该实例客观下线。</li>
</ul>
</li>
<li><strong>选主</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。 下面是哨兵选举的规则：<ul>
<li>首先判断主与从节点断开时间长短，如断开时间太长则不选举该从节点。</li>
<li>然后判断从节点的slave-priority值，越小优先级越高。</li>
<li>如果优先值相等，则判断从节点的offset值，越大优先级越高</li>
</ul>
</li>
<li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端。</li>
</ul>
<h2 id="Redis-哨兵模式的数据丢失问题："><a href="#Redis-哨兵模式的数据丢失问题：" class="headerlink" title="Redis 哨兵模式的数据丢失问题："></a>Redis 哨兵模式的数据丢失问题：</h2><p><strong>异步复制导致的数据丢失：</strong><br>由于主从复制的过程是异步的，所以可能有部分数据还没复制到从节点，主节点就宕机了，此时这部分数据就会丢失。<br><strong>脑裂导致的数据丢失：</strong><br>脑裂是由于网络等原因，使得哨兵无法心跳感知到主节点，于是通过选举的方式产生了一个新的主节点，于是就有了两个主节点，这样会导致客户端在老主节点那更新数据，新的主节点无法同步更新数据。<br><strong>解决方案：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<ul>
<li>配置参数：要求至少有 1 个从节点，数据复制和同步的延迟不能超过 10 秒。如果所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。 这样就能<strong>将发生的数据丢失降低到可控范围之内</strong>。</li>
</ul>
<h1 id="怎么保证Redis的高并发高可用？"><a href="#怎么保证Redis的高并发高可用？" class="headerlink" title="怎么保证Redis的高并发高可用？"></a>怎么保证Redis的高并发高可用？</h1><p>首先可以搭建<strong>主从集群(解决高并发)<strong>，再加上使用redis中的</strong>哨兵模式(解决高可用)<strong>，</strong>哨兵模式可以实现主从集群的自动故障恢复</strong>，里面就包含了对主从服务的<strong>监控、自动故障恢复、通知</strong>；<br>        如果master故障，Sentinel会将一个slave提升为master。 当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证redis的高并发高可用。</p>
<h1 id="redis的分片集群"><a href="#redis的分片集群" class="headerlink" title="redis的分片集群"></a>redis的分片集群</h1><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决： <strong>海量数据存储</strong>问题 和 <strong>高并发写</strong>的问题。<br><strong>分片集群的作用：</strong></p>
<ul>
<li>集群中有多个master，每个master保存不同数据。（解决海量数据存储和高并发写的问题）</li>
<li>每个master都可以有多个slave节点。(解决高并发读的问题)</li>
<li>master之间通过ping监测彼此健康状态。</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点。(路由)</li>
</ul>
<h2 id="Redis分片集群中数据是怎么存储和读取的？"><a href="#Redis分片集群中数据是怎么存储和读取的？" class="headerlink" title="Redis分片集群中数据是怎么存储和读取的？"></a><strong>Redis分片集群中数据是怎么存储和读取的？</strong></h2><ul>
<li>Redis 分片集群引入了<strong>哈希槽</strong>的概念，Redis 集群有 16384 个哈希槽。</li>
<li>将16384个插槽分配到不同的<strong>master</strong>节点。</li>
<li>读写数据：<strong>根据key的有效部分计算哈希值</strong>，<strong>对16384取余</strong>。（有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分）<strong>余数做为插槽，寻找插槽所在的节点</strong>。</li>
</ul>
<h1 id="Redis-为什么是单线程的？为什么性能快？（⭐）"><a href="#Redis-为什么是单线程的？为什么性能快？（⭐）" class="headerlink" title="Redis 为什么是单线程的？为什么性能快？（⭐）"></a>Redis 为什么是单线程的？为什么性能快？（⭐）</h1><p>Redis <strong>单线程</strong>并不是说 Redis 服务器就只有一个线程，而是指<strong>在处理客户端请求（如增删改查）的时候只有一个线程</strong>，但其实在其他操作的时候是有可能多个线程的，比如说持久化。<strong>Redis</strong>执行<strong>BGSAVE</strong>指令，进行快照持久化时，就会<strong>fork</strong>出一个子进程，然后子进程去创建快照，完成持久化操作。</p>
<p><strong>为什么 Redis 采用单线程？</strong> </p>
<p>通常在<strong>涉及到频繁 I&#x2F;O 操作的时候可以采用多线程</strong>，<strong>（磁盘I&#x2F;O是一个比较耗时的操作，所以对于需要进行磁盘I&#x2F;O的程序，我们可以使用多线程，在某个线程进行I&#x2F;O时，CPU切换到当前程序的其他线程执行，以此减少CPU的等待时间）</strong> 以提高 CPU 的利用率，<strong>但是 Redis 是基于内存的，不涉及到什么IO操作，使用多线程并不能有效提升效率</strong>，相反，使用多线程还需要考虑高并发情况下的线程安全问题，以及各种不必要的上下文切换，影响效率。</p>
<p><strong>Redis 为什么快？</strong></p>
<ul>
<li>Redis是基于C语言编写，是基于内存操作，执行速度非常快。</li>
<li>采用单线程，避免不必要的上下文切换，多线程还需要考虑线程安全问题。</li>
<li>使用了I&#x2F;O多路复用模型，非阻塞IO。</li>
</ul>
<h1 id="I-O多路复用模型"><a href="#I-O多路复用模型" class="headerlink" title="I&#x2F;O多路复用模型"></a>I&#x2F;O多路复用模型</h1><p>Redis是纯内存操作，执行速度非常快，它的<strong>性能瓶颈是网络延迟和内存，而不是执行速度</strong>，<strong>I&#x2F;O多路复用模型主要就是实现了高效的网络请求。</strong></p>
<ul>
<li><strong>阻塞IO：用户区进程在“内核区准备数据”和“拷贝数据”两个阶段都处于阻塞状态。</strong></li>
<li><strong>非阻塞IO：第一个阶段是非阻塞，第二阶段阻塞。虽然是非阻塞，但都是忙等，没有提高性能，还会使CPU空转，使用率暴涨。</strong></li>
<li><strong>IO多路复用：是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</strong><ul>
<li><strong>监听Socket的方式：</strong><ul>
<li><strong>select：</strong> 轮询监听各个Socket，监听个数上限为1024。</li>
<li><strong>poll：</strong> 也要轮询监听，但是监听上限大于select方法。</li>
<li><strong>epoll：</strong> 不必轮询监听，当socket准备好了通知一下即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>redis使用<strong>I&#x2F;O多路复用</strong>结合<strong>事件的处理器</strong>来应对多个Socket请求，</p>
<ul>
<li><strong>连接应答处理器</strong></li>
<li><strong>命令回复处理器</strong>，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</li>
<li><strong>命令请求处理器</strong>，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程。</li>
</ul>
<p><img src="/2024/08/05/Redis%E7%AF%87/1.png"></p>
<h1 id="什么是大Key问题？如何解决？"><a href="#什么是大Key问题？如何解决？" class="headerlink" title="什么是大Key问题？如何解决？"></a>什么是大Key问题？如何解决？</h1><p>BigKey的具体表现是Redis中的key对应的value很大，占用的redis空间比较大，本质上是大value问题。在读取大key的时候，由于读取的内容较多，占用较大的带宽，造成网络带宽的阻塞。 解决方案：</p>
<ul>
<li><strong>针对BigKey进行拆分：</strong> 将大key拆分成多个小key的键值对，读取的时候使用mget批量读取。</li>
<li><strong>压缩对应BigKey的value</strong>：可以通过序列化等方法对value进行压缩，使其变为较小的value。</li>
<li><strong>清理无效的数据</strong>：主要是针对像是<strong>list</strong>和<strong>set</strong>这种类型，在使用的过程中，<strong>list</strong>和<strong>set</strong>中对应的内容不断增加，需要定时的对list和set进行清理。</li>
</ul>

    </div>

    
    
    
	
	 
       <div>
		 <div>
    
        <div style="text-align:center;color: #00BFFF;font-size:18px;"><br>-------------------- 本文结束 <i class="fas fa-heart"></i> 感谢您的阅读！ -------------------</div>
    
</div>
	   </div>
     

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/02/MySQL%E7%AF%87/" rel="prev" title="MySQL">
      <i class="fa fa-chevron-left"></i> MySQL
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/08/05/JVM%E7%AF%87/" rel="next" title="JVM">
      JVM <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
	
	<!-- require APlayer -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    <!-- require MetingJS-->
    <script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
    <!--qq音乐-->   
    <meting-js
		auto="https://c6.y.qq.com/base/fcgi-bin/u?__=nYC8LhwMbhVJ">
	</meting-js>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">Redis常见数据类型及其应用场景（⭐）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">Redis有什么优点和缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">什么是缓存穿透 ? 怎么解决 ?（⭐）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">什么是缓存击穿? 怎么解决 ?（⭐）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">什么是缓存雪崩? 怎么解决 ?（⭐）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E5%A6%82%E4%BD%95%E4%B8%8Eredis%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">mysql如何与redis进行同步？（⭐）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E5%81%9A%E4%B8%BA%E7%BC%93%E5%AD%98%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">redis做为缓存，数据的持久化是怎么做的？（⭐）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">Redis的数据过期策略有哪些 ?（⭐）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">9.</span> <span class="nav-text">redis的数据淘汰策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LRU%E5%92%8CLFU%E4%B8%A4%E7%A7%8D%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="nav-number">9.1.</span> <span class="nav-text">LRU和LFU两种策略：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%891000%E4%B8%87%E6%95%B0%E6%8D%AE-Redis%E5%8F%AA%E8%83%BD%E7%BC%93%E5%AD%9820w%E6%95%B0%E6%8D%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E4%B8%AD%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="nav-number">9.2.</span> <span class="nav-text">数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中数据都是热点数据 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">9.3.</span> <span class="nav-text">Redis的内存用完了会发生什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.</span> <span class="nav-text">Redis分布式锁的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E7%9A%84%E6%8E%A7%E5%88%B6%E9%94%81%E7%9A%84%E6%9C%89%E6%95%88%E6%97%B6%E9%95%BF%EF%BC%9F"><span class="nav-number">10.1.</span> <span class="nav-text">Redisson实现分布式锁如何合理的控制锁的有效时长？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson%E7%9A%84%E8%BF%99%E4%B8%AA%E9%94%81%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%85%A5%E5%90%97%EF%BC%9F"><span class="nav-number">10.2.</span> <span class="nav-text">Redisson的这个锁，可以重入吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson%E9%94%81%E8%83%BD%E8%A7%A3%E5%86%B3%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="nav-number">10.3.</span> <span class="nav-text">Redisson锁能解决主从数据一致的问题吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">Redis的集群方案（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="nav-number">11.1.</span> <span class="nav-text">主从集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.2.</span> <span class="nav-text">哨兵模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">11.3.</span> <span class="nav-text">Redis 哨兵模式的数据丢失问题：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81Redis%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">怎么保证Redis的高并发高可用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E7%9A%84%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="nav-number">13.</span> <span class="nav-text">redis的分片集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E5%92%8C%E8%AF%BB%E5%8F%96%E7%9A%84%EF%BC%9F"><span class="nav-number">13.1.</span> <span class="nav-text">Redis分片集群中数据是怎么存储和读取的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E5%BF%AB%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">14.</span> <span class="nav-text">Redis 为什么是单线程的？为什么性能快？（⭐）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">I&#x2F;O多路复用模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7Key%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">什么是大Key问题？如何解决？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴华杰"
      src="/images/jay.jpg">
  <p class="site-author-name" itemprop="name">吴华杰</p>
  <div class="site-description" itemprop="description">Time will tell</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:1002372564@qq.com" title="E-Mail → mailto:1002372564@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-07-31 @ – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴华杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">105k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:36</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共60.6k字</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
