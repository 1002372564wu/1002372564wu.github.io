<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/jay.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/jay.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="线程基础进程与线程的区别？ 进程：进程是程序的一次执行过程，是操作系统资源分配的基本单位。程序由指令和数据组成，指令要运行就得加载至CPU，数据要读写就得加载至内存，在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存以及IO 的。 线程：一个线程就是一个指令流，是操作系统中最小的调度单位，负责将指令流中的一条条指令以一定的顺序交给 CPU 执行。 两者区别： 关系：进程是正">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC">
<meta property="og:url" content="http://example.com/2024/08/05/JUC%E7%AF%87/index.html">
<meta property="og:site_name" content="Michael-Jay">
<meta property="og:description" content="线程基础进程与线程的区别？ 进程：进程是程序的一次执行过程，是操作系统资源分配的基本单位。程序由指令和数据组成，指令要运行就得加载至CPU，数据要读写就得加载至内存，在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存以及IO 的。 线程：一个线程就是一个指令流，是操作系统中最小的调度单位，负责将指令流中的一条条指令以一定的顺序交给 CPU 执行。 两者区别： 关系：进程是正">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/9.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/4.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/3.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/10.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/6.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/11.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/5.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/7.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/2.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/8.png">
<meta property="og:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/1.png">
<meta property="article:published_time" content="2024-08-05T03:22:08.230Z">
<meta property="article:modified_time" content="2024-08-05T05:48:08.574Z">
<meta property="article:author" content="吴华杰">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/08/05/JUC%E7%AF%87/9.png">

<link rel="canonical" href="http://example.com/2024/08/05/JUC%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JUC | Michael-Jay</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <script type="text/javascript" src="/js/love.js"></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Michael-Jay</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="/study/" rel="section"><i class="fas fa-marker fa-fw"></i>技术</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/05/JUC%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/jay.jpg">
      <meta itemprop="name" content="吴华杰">
      <meta itemprop="description" content="Time will tell">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Michael-Jay">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JUC
        </h1>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-05 11:22:08 / 修改时间：13:48:08" itemprop="dateCreated datePublished" datetime="2024-08-05T11:22:08+08:00">2024-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="进程与线程的区别？"><a href="#进程与线程的区别？" class="headerlink" title="进程与线程的区别？"></a>进程与线程的区别？</h2><ul>
<li><strong>进程：进程是程序的一次执行过程，是操作系统资源分配的基本单位。</strong>程序由指令和数据组成，指令要运行就得加载至CPU，数据要读写就得加载至内存，在指令运行过程中还需要用到磁盘、网络等设备。<strong>进程就是用来加载指令、管理内存以及IO 的</strong>。</li>
<li><strong>线程：一个线程就是一个指令流，是操作系统中最小的调度单位</strong>，负责将指令流中的一条条指令以一定的顺序交给 CPU 执行。</li>
<li><strong>两者区别</strong>：<ul>
<li><strong>关系</strong>：进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务。</li>
<li><strong>内存</strong>：不同的进程使用不同的内存空间，同一进程下的所有线程共享内存空间。</li>
<li><strong>开销</strong>：线程更轻量，线程上下文切换开销要比进程上下文切换开销低。</li>
</ul>
</li>
</ul>
<h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<h2 id="创建线程的方式（⭐）"><a href="#创建线程的方式（⭐）" class="headerlink" title="创建线程的方式（⭐）"></a>创建线程的方式（⭐）</h2><ul>
<li><p><strong>继承Thread类：</strong>继承 Thread 类，并重写了其 run () 方法，之后直接调用 start () 即可实现多线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过集成 Thread 类实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread</span>().start()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现runnable接口</strong>：定义一个线程执行的任务（run 方法里面的逻辑）并没有创建线程。它首先通过 MyRunnable 类实现 Runnable 接口，然后重写 run () 方法，之后还要把这个实现了 run () 方法的实例传到 Thread 类中才可以实现多线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过实现 Runnable 方式实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 1、创建MyRunnable实例</span></span><br><span class="line"><span class="type">MyRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="comment">//2.创建Thread对象</span></span><br><span class="line"><span class="comment">//3.将MyRunnable放入Thread实例中</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line"><span class="comment">//4.通过线程对象操作线程(运行、停止)</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现Callable接口</strong>：Callable 与 Runnable 名字还有点像，区别在于 Runnable 是无返回值的。它们的本质都是定义线程要做的任务（call 或 run 方法里面的逻辑），而不是说他们本身就是线程。但无论有无返回值，它们都是需要被线程执行。</p>
</li>
<li><p><strong>线程池创建线程</strong></p>
</li>
</ul>
<h3 id="runnable和Callable的区别："><a href="#runnable和Callable的区别：" class="headerlink" title="runnable和Callable的区别："></a>runnable和Callable的区别：</h3><ul>
<li>Runnable 接口 run 方法没有返回值； Callable 接口 call 方法有返回值，是个泛型，和Future 、 FutureTask 配合可以用来获取异步执行的结果。</li>
<li>Callalbe 接口支持返回执行结果，需要调用 FutureTask.get() 得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部使用try-catch消化，不能继续上抛。</li>
</ul>
<h3 id="线程中的run-和-start-的区别："><a href="#线程中的run-和-start-的区别：" class="headerlink" title="线程中的run()和 start()的区别："></a>线程中的run()和 start()的区别：</h3><ul>
<li>**start():**用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li>
<li>**run():**封装了要被线程执行的代码，可以被调用多次。</li>
</ul>
<p><strong>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行，会把 run() 方法当成一个 main 线程下的普通方法去执行。</strong></p>
<h2 id="线程的状态及其生命周期（⭐）"><a href="#线程的状态及其生命周期（⭐）" class="headerlink" title="线程的状态及其生命周期（⭐）"></a>线程的状态及其生命周期（⭐）</h2><ul>
<li><strong>新建状态(New)：</strong> 线程对象被创建出来，但没有执行start()。</li>
<li><strong>可执行状态(RUNNABLE)：</strong> 线程调用start()方法转为可执行状态。</li>
<li><strong>阻塞状态(Blocked)：</strong> 没有获取锁则进入阻塞状态，获得锁再切换为可执行状态。</li>
<li><strong>等待状态(wating)：</strong> 线程调用了wait()方法进入等待状态，其他线程调用notify()唤醒后可切换为可执行状态。</li>
<li><strong>计时等待状态(TIME_WAITING)：</strong> 线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态。</li>
<li><strong>终止状态(TERMINATED)：</strong> 该线程已经运行完毕。</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/9.png"></p>
<h2 id="新建-T1、T2、T3-三个线程，如何保证按顺序执行？（⭐）"><a href="#新建-T1、T2、T3-三个线程，如何保证按顺序执行？（⭐）" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证按顺序执行？（⭐）"></a>新建 T1、T2、T3 三个线程，如何保证按顺序执行？（⭐）</h2><p>使用线程类的<strong>join()<strong>方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</strong>如：在t2线程里添加代码:t1.join(); 在t3线程里添加代码t2.join()；</strong></p>
<blockquote>
<p><strong>join()方法的作用：</strong><br><strong>使主线程(即调用t.join方法的线程)挂起，并等待子线程 t 执行完毕后才会被唤醒。</strong></p>
</blockquote>
<h2 id="notify-和-notifyAll-的区别"><a href="#notify-和-notifyAll-的区别" class="headerlink" title="notify()和 notifyAll()的区别"></a>notify()和 notifyAll()的区别</h2><ul>
<li><strong>notifyAll：</strong> 唤醒所有wait的线程。</li>
<li><strong>notify：</strong> 随机唤醒一个 wait 线程。</li>
</ul>
<h2 id="sleep-方法和-wait-方法的异同"><a href="#sleep-方法和-wait-方法的异同" class="headerlink" title="sleep() 方法和 wait() 方法的异同"></a>sleep() 方法和 wait() 方法的异同</h2><ul>
<li><strong>相同点：</strong> 都可以让线程进入阻塞状态。</li>
<li><strong>不同点：</strong><ul>
<li><strong>方法归属：</strong> sleep是Thread的静态本地方法，wait()是Object类的本地方法。</li>
<li><strong>醒来时机：</strong> sleep执行完线程会自动苏醒；wait需要其他线程调用notify或notifyAll。</li>
<li><strong>锁特性：</strong> 调用wait方法需要获取对象锁，唤醒后会释放锁；调用sleep不需要获取锁也不会释放锁。</li>
</ul>
</li>
</ul>
<h2 id="如何停止一个正在运行的线程？（⭐）"><a href="#如何停止一个正在运行的线程？（⭐）" class="headerlink" title="如何停止一个正在运行的线程？（⭐）"></a>如何停止一个正在运行的线程？（⭐）</h2><ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>
<li>使用stop方法强行终止（不推荐，方法已作废）。</li>
<li>使用interrupt方法中断线程。</li>
</ul>
<h2 id="使用两个线程交替打印1-100（⭐）"><a href="#使用两个线程交替打印1-100（⭐）" class="headerlink" title="使用两个线程交替打印1-100（⭐）"></a>使用两个线程交替打印1-100（⭐）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用两个线程交替打印1-100</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Jay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2024-05-27 21:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">print_1_to_100</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//此处需要加关键字volatile保证变量之间的可见性，否则程序将会阻塞在while循环中动不了（有点类似死锁）。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">thread1</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">thread2</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">99</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(print_1_to_100.flag == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1: &quot;</span> + i );</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                print_1_to_100.flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(print_1_to_100.flag == <span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2: &quot;</span> + i );</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                print_1_to_100.flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/2024/08/05/JUC%E7%AF%87/4.png"></p>
<h1 id="线程中的并发安全"><a href="#线程中的并发安全" class="headerlink" title="线程中的并发安全"></a>线程中的并发安全</h1><h2 id="synchronized关键字的底层原理（⭐）"><a href="#synchronized关键字的底层原理（⭐）" class="headerlink" title="synchronized关键字的底层原理（⭐）"></a>synchronized关键字的底层原理（⭐）</h2><blockquote>
<p><strong>回答思路：宏观介绍一下synchronized的大致功能—&gt;底层实现monitor—&gt;锁升级</strong></p>
</blockquote>
<ul>
<li><strong>synchronized</strong>用于<strong>解决多线程的并发安全问题</strong>，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</li>
<li><strong>synchronized</strong>底层是由<strong>monitor</strong>实现的，在线程获取锁成功过后需要和monitor对象进行关联，即将对象头的mark word字段存储monitor的地址，并将<strong>monitor的owner字段指向该线程</strong>。</li>
<li>由于monitor是操作系统级别的对象，<strong>在实现线程之间的切换时需要从用户态转换到内核态，成本较高，因此synchronized属于重量级锁</strong>，效率低下。 jdk1.6之后引入了锁升级减少了锁的开销，如：轻量级锁、偏向锁等。<ul>
<li>monitor有三个字段：<ul>
<li><strong>Owner</strong>：存储当前获取锁的线程的，只能有一个线程可以获取。</li>
<li><strong>EntryList</strong>：关联没有抢到锁的线程，处于Blocked状态的线程。</li>
<li><strong>WaitSet</strong>：关联调用了wait方法的线程，处于Waiting状态的线程 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="锁升级："><a href="#锁升级：" class="headerlink" title="锁升级："></a>锁升级：</h2><p>介绍锁升级之前，需要先介绍一下<strong>Java对象的内存结构</strong>。在HotSpot虚拟机中，<strong>对象的内存结构</strong>包括三个字段：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充。</strong></p>
<ul>
<li>其中对象头有两个字段：<ul>
<li><strong>Klass pointer：</strong> 指向方法区中存的类元数据，<strong>通过这个指针来确定这个对象是哪个类的实例</strong>。</li>
<li><strong>Mark word：</strong> 对象的hashcode，分代年龄，锁状态，类元数据指针等信息，如下图。</li>
</ul>
</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/3.png"><br><strong>由于阻塞一个线程涉及到操作系统用户态和内核态的转换，开销较大，因此jdk1.6之后，synchronized锁进行了优化，锁一共分为四种状态：</strong></p>
<ul>
<li><strong>无锁状态</strong></li>
<li><strong>偏向锁：</strong>用于<strong>解决锁的重入问题</strong>。共享资源首次被访问时，JVM会对该共享资源对象做一些设置，比如将对象头中是否偏向锁标志位置为1，<strong>对象头中的线程ID设置为当前线程ID，后续当前线程再次访问这个共享资源时，会根据偏向锁标识跟线程ID进行比对是否相同，比对成功则直接获取到锁</strong>，进入临界区域，这也是synchronized锁的可重入功能。</li>
<li><strong>轻量级锁：</strong> 当前锁是偏向锁的时候，有另外的线程访问，则会升级成轻量级锁。<strong>轻量级锁通过自旋等待（CAS操作）来尝试获取锁</strong>，避免线程立即挂起。如果自旋等待达到一定次数仍无法获取锁，则会升级为重量级锁。</li>
<li><strong>重量级锁</strong></li>
</ul>
<h2 id="谈谈-JMM（Java-内存模型）（⭐）"><a href="#谈谈-JMM（Java-内存模型）（⭐）" class="headerlink" title="谈谈 JMM（Java 内存模型）（⭐）"></a>谈谈 JMM（Java 内存模型）（⭐）</h2><p>首先搞清楚<strong>java内存区域</strong>和<strong>java内存模型</strong>的区别：</p>
<ul>
<li><strong>java内存区域</strong>：定义的是jvm在运行时如何如何分区存储程序数据。</li>
<li><strong>java内存模型</strong>：和java并发编程相关，描述了Java程序中各种变量(线程共享变量)的访问规则<br>，目的是为了简化多线程编程。</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/10.png"></p>
<ul>
<li>所有的<strong>共享变量</strong>都存储于<strong>主内存</strong>，这里所说的变量指的是<strong>实例变量</strong>和<strong>类变量</strong>。不包含局部变量，因为<strong>局部变量是线程私有的，因此不存在竞争问题。</strong></li>
<li>每一个线程还存在自己的<strong>工作内存</strong>，线程的工作内存，保留了被线程使用的变量的工作副本。</li>
<li><strong>线程对变量的所有操作(读，写)都必须在工作内存中完成</strong>，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程之间交互需要通过<strong>主内存</strong>完成。</li>
</ul>
<h2 id="谈谈CAS（⭐）"><a href="#谈谈CAS（⭐）" class="headerlink" title="谈谈CAS（⭐）"></a>谈谈CAS（⭐）</h2><p><strong>CAS</strong>全称是：<strong>Compare And Swap(比较再交换)，它体现的是一种乐观锁的思想， 在无锁情况下保证多线程操作共享数据的原子性</strong>。<br> 高并发的场景下，乐观锁相比悲观锁来说，<strong>不存在锁竞争造成线程阻塞</strong>，也不会有死锁的问题，在性能上往往会更胜一筹。但是，<strong>如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升</strong>。<br>CAS 的思想很简单，<strong>就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新</strong>，不相等则自旋重试。<br><strong>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）</strong>。sun.misc包下的<strong>Unsafe</strong>类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作。</p>
<blockquote>
<p><strong>CAS引出的ABA问题</strong>：就是在比较并交换时，存在一个时间差，在这期间数据可能会被修改多次，只不过最终结果和最初结果恰巧相同。<br><strong>解决办法</strong>：使用AtomicStampedReference类可以解决ABA问题。这个类维护了一个版本号Stamp，在进行CAS操作的时候，不仅要比较当前值，还要比较版本号。只有两者都相等，才执行更新操作。</p>
</blockquote>
<h2 id="谈谈volatile（⭐）"><a href="#谈谈volatile（⭐）" class="headerlink" title="谈谈volatile（⭐）"></a>谈谈volatile（⭐）</h2><h3 id="可见性问题："><a href="#可见性问题：" class="headerlink" title="可见性问题："></a>可见性问题：</h3><p>可见性问题和<strong>Java内存模型(JMM)<strong>有关，在JMM中，存在</strong>主内存</strong>和<strong>工作内存</strong>，主内存存的是共享变量，工作内存是线程私有的，线程对数据的操作是在工作内存当中进行的，此时数据的改动对于主内存以及其他工作内存是不可见的。当一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li><strong>保证线程间的可见性</strong>：一个线程修改了某个变量的值，该新值对其他线程来说是立即可见的。<ul>
<li>volatile关键字可以保证变量的可见性，如果我们将变量声明为 volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li>
</ul>
</li>
<li><strong>禁止指令重排序：</strong> 用volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</li>
</ul>
<h2 id="谈谈AQS（⭐）"><a href="#谈谈AQS（⭐）" class="headerlink" title="谈谈AQS（⭐）"></a>谈谈AQS（⭐）</h2><p>AQS全称AbstractQueuedSynchronizer，即<strong>抽象队列同步器</strong>。它是<strong>构建锁或者其他同步组件的基础框架</strong>，常见的实现类有：<strong>ReentrantLock</strong>(阻塞式锁)、<strong>Semaphore</strong>(信号量)、<strong>CountDownLatch</strong>(倒计时锁)。AQS与Synchronized的区别如下图：<br><img src="/2024/08/05/JUC%E7%AF%87/6.png"><br><strong>AQS 核心思想</strong>：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。<br><strong>AQS的核心框架实现：</strong></p>
<ul>
<li>AQS内部维护了一个先进先出的<strong>双向队列CLH</strong>，队列中存储排队等候唤醒的线程。<ul>
<li>CLH队列是一个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。<strong>每个线程被封装成队列中的一个节点，节点保存着线程的引用、前驱节点、后继节点等信息</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/11.png"></p>
<ul>
<li>AQS内部还维护了一个属性<strong>state</strong>，由 <strong>volatile <strong>修饰。相当于资源，默认为0(无锁状态)。当有线程修改了state为1，则该线程获取了资源。状态信息state可以通过</strong>getState</strong>和<strong>setState</strong>方法获取和修改，这些方法由final修饰，无法更改。</li>
<li>使用<strong>CAS</strong>操作保证各线程对state修改的原子性。即<strong>compareAndSetState</strong>方法。</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/5.png"></p>
<h2 id="AQS底层的实现类（⭐）"><a href="#AQS底层的实现类（⭐）" class="headerlink" title="AQS底层的实现类（⭐）"></a>AQS底层的实现类（⭐）</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul>
<li>ReentrantLock表示可重入锁，属于独占式锁，同一线程可多次获取锁。</li>
<li>ReentrantLock主要利用CAS+AQS队列来实现。</li>
<li>ReentrantLock支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁。</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li>synchronized 和 ReentrantLock都是一次只允许一个线程访问某个资源，<strong>Semaphore (信号量)可以控制同时访问特定资源的线程数量</strong>，通常用于那些资源有明确访问数量限制的场景比如<strong>限流</strong>。</li>
<li>Semaphore 的使用：假设有 N个线程来获取 Semaphore 中的共享资源，以下代码表示同一时刻 只有N 个线程能获取到共享资源，其他线程都会阻塞。直到有线程释放了共享资源，其他阻塞的线程才能获取到资源。</li>
<li>Semaphore也支持公平锁和非公平锁：<ul>
<li><strong>公平模式：</strong> 调用 <strong>acquire()</strong> 方法的顺序遵循 FIFO；</li>
<li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>
</li>
</ul>
<h2 id="谈谈ConcurrentHashMap-（⭐）"><a href="#谈谈ConcurrentHashMap-（⭐）" class="headerlink" title="谈谈ConcurrentHashMap （⭐）"></a>谈谈ConcurrentHashMap （⭐）</h2><ul>
<li><strong>底层数据结构：</strong><ul>
<li>JDK1.7及之前之前采用** 分段数组(segment) + 链表**实现。</li>
<li>JDK1.8开始底层的数据结构和JDK1.8HashMap一样，采用<strong>数组+链表&#x2F;红黑树</strong>实现。</li>
</ul>
</li>
<li><strong>加锁方式：</strong><ul>
<li>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock。</li>
<li>JDK1.8放弃了Segment分段锁的设计，采用** CAS + synchronized **保证线程安全，锁粒度更细。CAS控制数组节点的添加，synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发安全问题。</li>
</ul>
</li>
</ul>
<p>jdk1.7：<br><img src="/2024/08/05/JUC%E7%AF%87/7.png"><br>jdk1.8：<br><img src="/2024/08/05/JUC%E7%AF%87/2.png"></p>
<h2 id="Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）"><a href="#Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）" class="headerlink" title="Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）"></a>Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）</h2><p>满足Java并发编程的三大特性：</p>
<ul>
<li><strong>原子性：</strong> 一段程序执行是不可分割的，要么全部执行成功，要么全部失败。<ul>
<li>可以使用synchronized和lock保证程序的原子性。</li>
</ul>
</li>
<li><strong>可见性：</strong> 一个线程对共享变量的修改对另一个线程可见。<ul>
<li>可以使用volatile(推荐)保证可见性，synchronized、Lock也可以。</li>
</ul>
</li>
<li><strong>有序性：</strong> 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<ul>
<li>可以通过volatile关键字来保证一定的“有序性”，synchronized和Lock也可以。</li>
</ul>
</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="什么是线程池？为什么要用线程池？（⭐）"><a href="#什么是线程池？为什么要用线程池？（⭐）" class="headerlink" title="什么是线程池？为什么要用线程池？（⭐）"></a>什么是线程池？为什么要用线程池？（⭐）</h2><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。<strong>线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制</strong>。池化技术的好处：</p>
<ul>
<li><strong>降低资源消耗</strong>。重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当有任务时，可以不需要等待线程的创建就能立即执行。</li>
</ul>
<h4 id="线程池的关闭方式："><a href="#线程池的关闭方式：" class="headerlink" title="线程池的关闭方式："></a>线程池的关闭方式：</h4><ul>
<li><strong>shutdown</strong>：使线程池状态从 <strong>RUNNING</strong> 转变为 <strong>SHUTDOWN</strong>，该状态下不再处理新任务，但会将工作队列中的任务执行结束。</li>
<li><strong>shutdownNow</strong>：使线程池状态将会从 <strong>RUNNING</strong> 转变为 <strong>STOP</strong>，该状态下新任务旧任务都不再处理，并且会中断线程。</li>
</ul>
<h2 id="线程池的核心参数（⭐）"><a href="#线程池的核心参数（⭐）" class="headerlink" title="线程池的核心参数（⭐）"></a>线程池的核心参数（⭐）</h2><p>线程池有七个参数：</p>
<ul>
<li><strong>corePoolSize</strong>：核心线程数目</li>
<li><strong>maximumPoolSize</strong>：最大线程数目 &#x3D; 核心线程 + 临时线程的最大数目</li>
<li><strong>workQueue</strong>：当没有空闲核心线程时，新来任务会加入到此队列排队，当队列满时会创建临时线程执行任务</li>
<li><strong>keepAliveTime</strong>：临时线程的生存时间，若生存时间内没有新任务，此线程资源会释放</li>
<li><strong>unit</strong>：临时线程生存时间的单位</li>
<li><strong>threadFactory：线程工厂，可以定制线程对象的创建，如设置线程名字、是否是守护线程等</strong></li>
<li><strong>handler</strong>：拒绝策略 - 当所有线程都在繁忙，队列也放满时，会触发拒绝策略<ul>
<li>1.<strong>AbortPolicy</strong>：直接抛出异常，默认策略；</li>
<li>2.<strong>CallerRunsPolicy</strong>：用调用者所在的线程来执行任务；</li>
<li>3.<strong>DiscardOldestPolicy</strong>：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>4.<strong>DiscardPolicy</strong>：直接丢弃任务。</li>
</ul>
</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/8.png"></p>
<h2 id="线程池中有哪些常见的阻塞队列（⭐）"><a href="#线程池中有哪些常见的阻塞队列（⭐）" class="headerlink" title="线程池中有哪些常见的阻塞队列（⭐）"></a>线程池中有哪些常见的阻塞队列（⭐）</h2><ul>
<li><strong>ArrayBlockingQueue</strong>：基于数组结构的有界阻塞队列，FIFO。</li>
<li><strong>LinkedBlockingQueue</strong>：基于链表结构的有界阻塞队列，FIFO。</li>
<li><strong>DelayedWorkQueue</strong> ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的。</li>
<li><strong>SynchronousQueue</strong>：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li>
</ul>
<p><strong>ArrayBlockingQueue</strong>的<strong>LinkedBlockingQueue</strong>区别：</p>
<ul>
<li>LinkedBlockingQueue默认无界，支持有界；ArrayBlockingQueue强制有界。</li>
<li>LinkedBlockingQueue底层是单向链表实现；ArrayBlockingQueue基于数组实现。</li>
<li>LinkedBlockingQueue头尾各一把锁，效率较高；ArrayBlockingQueue只有一把锁。</li>
</ul>
<h2 id="如何确定核心线程数？（⭐）"><a href="#如何确定核心线程数？（⭐）" class="headerlink" title="如何确定核心线程数？（⭐）"></a>如何确定核心线程数？（⭐）</h2><ul>
<li><strong>CPU密集型任务：</strong> 这类任务消耗的主要是 CPU 资源，可将线程核心数设置为 <strong>N（CPU 核心数）+1。</strong><ul>
<li><strong>多出来的一个核心线程是为了防止各种原因导致任务暂停而带来的影响</strong>。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的线程可以充分利用 CPU 的空闲时间。</li>
</ul>
</li>
<li><strong>I&#x2F;O密集型任务</strong>：这类任务系统会将大部分时间用在I&#x2F;O交互上，这段时间CPU是空闲的，可以交给其他线程使用，因此可以多配置一些线程，常用的值为<strong>2N（CPU核心数）</strong>。</li>
</ul>
<h2 id="如何创建线程池？线程池有哪些种类？（⭐）"><a href="#如何创建线程池？线程池有哪些种类？（⭐）" class="headerlink" title="如何创建线程池？线程池有哪些种类？（⭐）"></a>如何创建线程池？线程池有哪些种类？（⭐）</h2><ul>
<li><strong>方式一：</strong>使用<strong>ThreadPoolExecutor</strong>构造函数来创建。</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/1.png"></p>
<ul>
<li><strong>方式二：</strong>使用<strong>Executors</strong>工具类来创建。<ul>
<li>newFixedThreadPool：创建一个定长线程池，控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newSingleThreadExecutor：创建一个单线程的线程池，若多余的任务被提交到该线程池，其会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newScheduledThreadPool：可执行延迟任务的线程池，支持定时及周期性任务执行。</li>
</ul>
</li>
</ul>
<h2 id="为什么不推荐使用内置线程池（Executors）？（⭐）"><a href="#为什么不推荐使用内置线程池（Executors）？（⭐）" class="headerlink" title="为什么不推荐使用内置线程池（Executors）？（⭐）"></a>为什么不推荐使用内置线程池（Executors）？（⭐）</h2><ul>
<li>采用无界的阻塞队列，可能会堆积大量的任务，最终导致内存溢出。</li>
<li>允许创建的线程数为<strong>Integer.MAX_VALUE</strong>，也可能导致内存溢出。</li>
</ul>
<h2 id="谈谈对ThreadLocal的理解（⭐）"><a href="#谈谈对ThreadLocal的理解（⭐）" class="headerlink" title="谈谈对ThreadLocal的理解（⭐）"></a>谈谈对ThreadLocal的理解（⭐）</h2><p><strong>ThreadLocal</strong>，<strong>本地线程变量，ThreadLocal可以让每个线程绑定自己的变量，该变量对其他线程而言是封闭且隔离的。</strong></p>
<h3 id="ThreadLocal的原理："><a href="#ThreadLocal的原理：" class="headerlink" title="ThreadLocal的原理："></a>ThreadLocal的原理：</h3><p><strong>ThreadLocal的set方法源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。<br>        每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。<br><strong>ThreadLocal的get方法源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">get</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T) e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.refersTo(key))</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocal-的应用场景："><a href="#ThreadLocal-的应用场景：" class="headerlink" title="ThreadLocal 的应用场景："></a>ThreadLocal 的应用场景：</h3><ul>
<li><p><strong>解决高并发条件下多线程访问共享变量产生的并发安全问题。</strong></p>
<blockquote>
<p><strong>例如：项目中@Autowired默认是单例模式，那么负责连接数据库的connection也是单例的，如果多个线程同时获取connection请求连接数据库的话，就会产生并发安全问题。底层的解决方案就是使用ThreadLocal，每个线程请求连接数据库的时候，会先从自己的ThreadLocal中获取connection对象，达到各个线程隔离的效果。</strong></p>
</blockquote>
</li>
<li><p><strong>ThreadLocal 用作每个线程内需要独立保存信息</strong>，以便<strong>供其他方法更方便地获取</strong>该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过 ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。</p>
<blockquote>
<p><strong>例如：项目中拦截器中获取到的用户信息，可以让不同方法直接使用，避免了各个类传参的麻烦。</strong></p>
</blockquote>
</li>
</ul>
<h3 id="ThreadLocal-的弊端："><a href="#ThreadLocal-的弊端：" class="headerlink" title="ThreadLocal 的弊端："></a>ThreadLocal 的弊端：</h3><p><strong>内存泄漏：</strong> 如果我们使用线程池创建的线程，那么该线程很长一段时间都不会消失，而ThreadLocalMap中的value值属于强引用，不会被垃圾回收，而key是弱引用，此时就会产生<strong>内存泄漏</strong>的问题。</p>

    </div>

    
    
    
	
	 
       <div>
		 <div>
    
        <div style="text-align:center;color: #00BFFF;font-size:18px;"><br>-------------------- 本文结束 <i class="fas fa-heart"></i> 感谢您的阅读！ -------------------</div>
    
</div>
	   </div>
     

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/05/JVM%E7%AF%87/" rel="prev" title="JVM">
      <i class="fa fa-chevron-left"></i> JVM
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/08/05/%E6%A1%86%E6%9E%B6%E7%AF%87/" rel="next" title="Java框架">
      Java框架 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">进程与线程的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">并行和并发的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">创建线程的方式（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#runnable%E5%92%8CCallable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.3.1.</span> <span class="nav-text">runnable和Callable的区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84run-%E5%92%8C-start-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.3.2.</span> <span class="nav-text">线程中的run()和 start()的区别：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">线程的状态及其生命周期（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA-T1%E3%80%81T2%E3%80%81T3-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">新建 T1、T2、T3 三个线程，如何保证按顺序执行？（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#notify-%E5%92%8C-notifyAll-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.</span> <span class="nav-text">notify()和 notifyAll()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.7.</span> <span class="nav-text">sleep() 方法和 wait() 方法的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.8.</span> <span class="nav-text">如何停止一个正在运行的线程？（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">使用两个线程交替打印1-100（⭐）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="nav-number">2.</span> <span class="nav-text">线程中的并发安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">synchronized关键字的底层原理（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">锁升级：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88-JMM%EF%BC%88Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">谈谈 JMM（Java 内存模型）（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88CAS%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">谈谈CAS（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88volatile%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">谈谈volatile（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">2.5.1.</span> <span class="nav-text">可见性问题：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88AQS%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">谈谈AQS（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.7.</span> <span class="nav-text">AQS底层的实现类（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">2.7.1.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">2.7.2.</span> <span class="nav-text">Semaphore</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88ConcurrentHashMap-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.8.</span> <span class="nav-text">谈谈ConcurrentHashMap （⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AE%89%E5%85%A8%EF%BC%9F%EF%BC%88%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%89"><span class="nav-number">2.9.</span> <span class="nav-text">Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">3.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">什么是线程池？为什么要用线程池？（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">线程池的关闭方式：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">线程池的核心参数（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">线程池中有哪些常见的阻塞队列（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">如何确定核心线程数？（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%A7%8D%E7%B1%BB%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">3.5.</span> <span class="nav-text">如何创建线程池？线程池有哪些种类？（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88Executors%EF%BC%89%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">3.6.</span> <span class="nav-text">为什么不推荐使用内置线程池（Executors）？（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">3.7.</span> <span class="nav-text">谈谈对ThreadLocal的理解（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">3.7.1.</span> <span class="nav-text">ThreadLocal的原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">3.7.2.</span> <span class="nav-text">ThreadLocal 的应用场景：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9A"><span class="nav-number">3.7.3.</span> <span class="nav-text">ThreadLocal 的弊端：</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴华杰"
      src="/images/jay.jpg">
  <p class="site-author-name" itemprop="name">吴华杰</p>
  <div class="site-description" itemprop="description">Time will tell</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:1002372564@qq.com" title="E-Mail → mailto:1002372564@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-07-31 @ – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴华杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">73k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:07</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共47.9k字</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

</body>
</html>
