<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/jay.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/jay.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="常规：数据库三大范式 1NF : 表中字段的数据不可再拆分。(原子性) 2NF : 在满足第一范式的情况下，遵循唯一性，消除部分依赖。即，表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。(一个表只能描述一件事情) 3NF : 在满足第二范式的情况下，消除传递依赖。即，在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://example.com/2024/08/02/MySQL%E7%AF%87/index.html">
<meta property="og:site_name" content="Michael-Jay">
<meta property="og:description" content="常规：数据库三大范式 1NF : 表中字段的数据不可再拆分。(原子性) 2NF : 在满足第一范式的情况下，遵循唯一性，消除部分依赖。即，表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。(一个表只能描述一件事情) 3NF : 在满足第二范式的情况下，消除传递依赖。即，在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/08/02/MySQL%E7%AF%87/1.png">
<meta property="og:image" content="http://example.com/2024/08/02/MySQL%E7%AF%87/2.png">
<meta property="og:image" content="http://example.com/2024/08/02/MySQL%E7%AF%87/3.png">
<meta property="og:image" content="http://example.com/2024/08/02/MySQL%E7%AF%87/4.png">
<meta property="og:image" content="http://example.com/2024/08/02/MySQL%E7%AF%87/5.png">
<meta property="article:published_time" content="2024-08-02T09:22:20.437Z">
<meta property="article:modified_time" content="2024-08-05T05:58:53.585Z">
<meta property="article:author" content="吴华杰">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/08/02/MySQL%E7%AF%87/1.png">

<link rel="canonical" href="http://example.com/2024/08/02/MySQL%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL | Michael-Jay</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Michael-Jay</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="/study/" rel="section"><i class="fas fa-marker fa-fw"></i>技术</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/02/MySQL%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/jay.jpg">
      <meta itemprop="name" content="吴华杰">
      <meta itemprop="description" content="Time will tell">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Michael-Jay">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-02 17:22:20" itemprop="dateCreated datePublished" datetime="2024-08-02T17:22:20+08:00">2024-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-05 13:58:53" itemprop="dateModified" datetime="2024-08-05T13:58:53+08:00">2024-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="常规："><a href="#常规：" class="headerlink" title="常规："></a>常规：</h1><h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><ul>
<li><strong>1NF</strong> : 表中字段的数据不可再拆分。(原子性)</li>
<li><strong>2NF</strong> : 在满足第一范式的情况下，遵循唯一性，消除部分依赖。即，表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。(一个表只能描述一件事情)</li>
<li><strong>3NF</strong> : 在满足第二范式的情况下，消除传递依赖。即，在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。<span id="more"></span></li>
</ul>
<h2 id="主键和外键的区别？"><a href="#主键和外键的区别？" class="headerlink" title="主键和外键的区别？"></a>主键和外键的区别？</h2><ul>
<li><strong>主键：唯一标识一条记录。不能有重复的，不允许为空 。</strong></li>
<li><strong>外键：表的外键是另一表的主键, 用于和其他表建立联系。外键可以有重复的, 可以是空值。</strong></li>
</ul>
<h2 id="CHAR-和-VARCHAR-的区别是什么？"><a href="#CHAR-和-VARCHAR-的区别是什么？" class="headerlink" title="CHAR 和 VARCHAR 的区别是什么？"></a>CHAR 和 VARCHAR 的区别是什么？</h2><p>**        两者的主要区别在于：CHAR 是定长字符串，VARCHAR 是变长字符串。**</p>
<ul>
<li><strong>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。</strong></li>
<li><strong>VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</strong></li>
</ul>
<h2 id="DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a>DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h2><p>DECIMAL 和 FLOAT 的区别是：</p>
<ul>
<li><strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。</strong></li>
<li><strong>DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></li>
</ul>
<h2 id="NULL-和-‘-‘-的区别是什么？"><a href="#NULL-和-‘-‘-的区别是什么？" class="headerlink" title="NULL 和 ‘ ‘ 的区别是什么？"></a>NULL 和 ‘ ‘ 的区别是什么？</h2><ul>
<li><strong>类型</strong>：null表示的是一个对象的值，而非一个字符串，而””表示的是一个长度为0的空字符串。</li>
<li><strong>内存分配</strong>：null不分配内存空间;而””会分配内存空间。 如：<ul>
<li>String aaa &#x3D; null ; 表示声明一个字符串对象的引用，但指向为null（未指向任何的内存空间）；</li>
<li>String bbb &#x3D; “”;表示声明一个字符串类型的引用，其值为””空字符串（指向空字符串的内存空间）；</li>
</ul>
</li>
<li>查询 NULL 值时，必须使用 IS NULL 或 IS NOT NULL 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而’’是可以使用这些比较运算符的。</li>
</ul>
<h2 id="Boolean-类型如何表示？"><a href="#Boolean-类型如何表示？" class="headerlink" title="Boolean 类型如何表示？"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Boolean&spm=1001.2101.3001.7020">Boolean</a> 类型如何表示？</h2><p>MySQL 中没有专门的布尔<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">类型</a>，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</p>
<h2 id="MySQL-基础架构及执行过程-⭐执行一条select语句期间发生了什么"><a href="#MySQL-基础架构及执行过程-⭐执行一条select语句期间发生了什么" class="headerlink" title="MySQL 基础架构及执行过程(⭐执行一条select语句期间发生了什么)"></a>MySQL 基础架构及执行过程(⭐执行一条select语句期间发生了什么)</h2><p><img src="/2024/08/02/MySQL%E7%AF%87/1.png"><br>** MySQL 的架构共分为两层：Server 层和存储引擎层：**</p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。<strong>MySQL 大多数的核心功能模块都在这实现</strong>，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的<strong>内置函数</strong>（如日期、时间、数学和加密函数等）和<strong>所有跨存储引擎的功能</strong>（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。<strong>我们常说的索引数据结构，就是由存储引擎层实现的</strong>，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树。</li>
</ul>
<p><strong>一条SQL查询语句的执行过程：</strong></p>
<ul>
<li><strong>连接器</strong>： 包括TCP三次握手、身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存</strong>： 执行查询语句的时候，会先查询缓存（由于每次更新操作都会删除所有缓存，因此缓存功能较为鸡肋，在MySQL 8.0 版本后移除）。</li>
<li><strong>解析器</strong>： 没有命中缓存的话，SQL 语句就会经过解析器，通过<strong>词法分析</strong>识别出关键字、表名等，构建出<strong>语法树</strong>，接着再做<strong>语法分析</strong>判断语句是否符合MySQL语法。</li>
<li><strong>优化器</strong>： 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器</strong>： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>
<li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>
</ul>
<h2 id="MySQL-存储引擎MyISAM-和-InnoDB-有什么区别？（⭐）"><a href="#MySQL-存储引擎MyISAM-和-InnoDB-有什么区别？（⭐）" class="headerlink" title="MySQL 存储引擎MyISAM 和 InnoDB 有什么区别？（⭐）"></a>MySQL 存储引擎MyISAM 和 InnoDB 有什么区别？（⭐）</h2><p>MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。</p>
<pre><code>    MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎，之前默认存储引擎是MyISAM，两者区别如下：
</code></pre>
<ul>
<li><strong>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</strong></li>
<li><strong>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</strong><ul>
<li>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别，并可以解决幻读问题（基于 MVCC 和 Next-Key Lock）。</li>
</ul>
</li>
<li><strong>MyISAM 不支持外键，而 InnoDB 支持。</strong></li>
<li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li>
<li>MyISAM 和 InnoDB 都使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>InnoDB 的性能比 MyISAM 更强大。<blockquote>
<p><strong>MyISAM引擎和InnoDB引擎的使用场景：</strong><br><strong>MyISAM</strong>：适用于以<strong>读数据为主、低并发、不需要事务支持</strong>的业务场景。<br><strong>InnoDB</strong>：适用于<strong>需要经常修改数据、高并发、需要事务支持</strong>的业务场景。</p>
</blockquote>
</li>
</ul>
<h2 id="事务的四大特性（⭐）"><a href="#事务的四大特性（⭐）" class="headerlink" title="事务的四大特性（⭐）"></a>事务的四大特性（⭐）</h2><ul>
<li><strong>原子性</strong>(Atomicity)：事务是一个不可分割的工作单位，事务内的操作要么全部执行成功，要么全部回滚。</li>
<li><strong>一致性</strong>(Consistency)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li>
<li><strong>隔离性</strong>(Isolation)：一个事务所做的修改操作在提交之前，对于其他事务来说是不可见的。</li>
<li><strong>持久性</strong>(Durability)：事务一旦被提交，它对数据库中数据的改变就是永久性的。<blockquote>
<p>   <strong>redo log保证了持久性，undo log保证了原子性，锁和MVCC机制保证了隔离性，三者共同保证了一致性。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="MySQL事务隔离级别（⭐）"><a href="#MySQL事务隔离级别（⭐）" class="headerlink" title="MySQL事务隔离级别（⭐）"></a>MySQL事务隔离级别（⭐）</h2><p>事务隔离要实际解决的问题：</p>
<ul>
<li><strong>脏读</strong>：读了其他事务未提交的数据。</li>
<li><strong>不可重复读</strong>：同一事务先后读取同一条<strong>记录</strong>，但两次读取的数据不同。</li>
<li><strong>幻读</strong>：在一个事务中，两次查询返回的数据<strong>结果集</strong>不同，通常是针对插入语句的。</li>
</ul>
<p><img src="/2024/08/02/MySQL%E7%AF%87/2.png"><br>**        <strong>数据库事务隔离级别分为四个等级,分别为 : <strong>读未提交</strong>( read-uncommitted)、</strong>读已提交(<strong>read committed)、</strong>可重复读**(repeatable read)、<strong>串行序列化</strong>(serializable)。</p>
<ul>
<li>对于<strong>「读未提交」</strong>隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于<strong>「串行化」</strong>隔离级别的事务来说，通过加读写锁的方式来避免并行访问；<strong>在读写数据时会锁住整张表，效率比较低，因此innodb引擎默认级别为可重复读。</strong></li>
<li>对于<strong>「读已提交」</strong>和<strong>「可重复读」</strong>隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li>
</ul>
<p><strong>重点说一下「读已提交」和「可重复读」是如何实现的？</strong><br>首先这俩个隔离级别都是通过 <strong>Read View <strong>实现的，</strong>Read View</strong>是一个快照文件，记录了四个和事务有关的字段，如下图：<br><img src="/2024/08/02/MySQL%E7%AF%87/3.png"><br>还有两个隐藏字段：<strong>事务id（创建这条记录的事务id）、回滚指针（指向该记录的旧版本）</strong>，如下图：<br><img src="/2024/08/02/MySQL%E7%AF%87/4.png"><br><strong>「读已提交」：</strong><br><strong>RC 隔离级别只会读到别的事务提交的数据，但是存在不可重复读的问题，即在同一事务中，由于别的事务提交了数据，导致前后两次读的数据不一致。下面说说为什么会这样：</strong><br>RC 隔离级别每次读取数据都会生成一个新的<strong>Read view</strong>，该快照文件里头有一个字段会记录<strong>当前活跃的事务id集合</strong>，<strong>RC 隔离级别会判断当前这条记录的事务id是否存在于集合当中，若存在，说明这条记录是还未提交过的事务修改的，这时就不会读这个版本的记录，而是沿着undo log 找到旧版本的记录； 若不存在，说明修改这条记录的事务已经提交了，这时就可以读取这条记录</strong>。 <strong>由于RC每次读取数据都会生成新的read view，因此中途别的事务提交了的数据是会被读到的，因此有不可重复读的问题</strong>。<br><strong>「可重复读」：</strong><br>启动事务时生成一个 <strong>Read View</strong>，然后<strong>整个事务期间都在用这个 Read View</strong>，这样就保证了在事务期间读到的数据都是事务启动前的记录。</p>
<h3 id="可重复读又是如何解决幻读问题的？"><a href="#可重复读又是如何解决幻读问题的？" class="headerlink" title="可重复读又是如何解决幻读问题的？"></a>可重复读又是如何解决幻读问题的？</h3><p>采用<strong>锁+MVCC</strong>机制解决。<br><strong>针对当前读：</strong>读取的是最新的数据，使用<strong>next-key lock（记录锁+间隙锁）</strong>的方式解决幻读问题。当在执行读操作时，会加上 next-key lock，此时如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。<br><strong>针对（普通读）快照读：</strong>普通的 select 语句，采用<strong>mvcc机制</strong>解决幻读问题，并不会对记录加锁。 </p>
<h2 id="解释一下-undo-log、redo-log-和-bin-log"><a href="#解释一下-undo-log、redo-log-和-bin-log" class="headerlink" title="解释一下 undo log、redo log 和 bin log"></a>解释一下 undo log、redo log 和 bin log</h2><ul>
<li><strong>redo log（重做日志）：</strong>是 <strong>Innodb 存储引擎层</strong>生成的日志，实现了事务中的<strong>持久性</strong>，主要用于<strong>数据库故障的数据恢复</strong>；</li>
<li><strong>undo log（回滚日志）：</strong>是 <strong>Innodb 存储引擎层</strong>生成的日志，实现了事务中的<strong>原子性，主要用于事务回滚和 MVCC。</strong></li>
<li><strong>binlog （归档日志）</strong>：是 <strong>Server 层</strong>生成的日志，主要<strong>用于数据备份和主从复制</strong>。</li>
</ul>
<p><strong>redo log 和 bin log有什么区别？</strong></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；redo log 是 Innodb 存储引擎实现的日志；</li>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志；redo log 是循环写，日志空间大小是固定，日志文件写满了MySQL就会发生阻塞。</li>
</ul>
<p><strong>为什么需要redo log？</strong><br>首先要知道innodb存储引擎中提供了<strong>缓冲池（Buffer Pool）</strong>来提高数据库的读写性能：</p>
<ul>
<li>当读取数据时，如果数据存在于** Buffer Pool **中，客户端就会直接读取 Buffer Pool 中的数据。</li>
<li>当修改数据时，如果数据存在于** Buffer Pool **中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li>
</ul>
<p>但是问题来了，<strong>Buffer Pool <strong>是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</strong>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了</strong>。</p>
<h2 id="事务中的隔离性是如何保证的呢？（⭐）"><a href="#事务中的隔离性是如何保证的呢？（⭐）" class="headerlink" title="事务中的隔离性是如何保证的呢？（⭐）"></a>事务中的隔离性是如何保证的呢？（⭐）</h2><p><strong>事务的隔离性是由锁和mvcc实现的。</strong><br>**        <strong>mvcc的意思是</strong>多版本并发控制<strong>。</strong>指维护一个数据的多个版本，使得读写操作没有冲突**，它的底层实现主要分为三个部分：</p>
<ul>
<li><strong>隐藏字段：</strong><ul>
<li>**trx_id(事务id)**：记录每一次操作的事务id，是自增的。</li>
<li>**roll_pointer(回滚指针)**：指向上一个事务版本的地址。</li>
</ul>
</li>
<li><strong>undo log：</strong><ul>
<li>回滚日志，存储老版本数据，形成一条版本链。</li>
<li>版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表。</li>
</ul>
</li>
<li><strong>readView</strong>：解决的是一个事务查询选择版本的问题。<ul>
<li>根据readView的匹配规则和当前的一些事务id判断该访问哪个版本的数据。</li>
<li>不同的隔离级别快照读也不一样，最终的访问的结果不一样：<ul>
<li>RC（读已提交） ：每一次执行快照读时生成ReadView。</li>
<li>RR（可重复读）：仅在事务中第一次执行快照读时生成ReadView，后续复用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="MySQL主从同步原理（⭐）"><a href="#MySQL主从同步原理（⭐）" class="headerlink" title="MySQL主从同步原理（⭐）"></a>MySQL主从同步原理（⭐）</h2><pre><code>    MySQL主从复制的核心就是**二进制日志（binlog）**，里面记录了所有DDL和DML语句。
</code></pre>
<ul>
<li>主库在事务提交时，会将数据变更记录在binlog中。</li>
<li>从库读取主库的binlog，写入从库的中继日志Relay log中。</li>
<li>从库读取中继日志，写入到自己的数据库中。</li>
</ul>
<h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><blockquote>
<p>drop&gt; truncate &gt;delete</p>
</blockquote>
<p><strong>delete：用于删除表中的行，并且保留表结构，删除的行可以通过回滚日志回滚。</strong><br><strong>truncate ：TRUNCATE 用于删除表中的所有数据，但保留表的结构。</strong><br><strong>drop：DROP 用于删除整个表（包括表的结构和数据）。</strong></p>
<h2 id="什么是视图？"><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h2><pre><code>    **视图是一个表或多个表的查询子集，其作用是方便用户对数据的操作。**
</code></pre>
<ul>
<li><strong>简单</strong>：视图可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li>
<li><strong>安全性</strong>：通过视图，用户只能查询和修改指定的数据，这样可以防止敏感信息被未授权的用户查看，增强机密信息的安全性。</li>
</ul>
<h2 id="MySQL的表级锁和行级锁（⭐）"><a href="#MySQL的表级锁和行级锁（⭐）" class="headerlink" title="MySQL的表级锁和行级锁（⭐）"></a>MySQL的表级锁和行级锁（⭐）</h2><pre><code>    **MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性能非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。**
</code></pre>
<ul>
<li><strong>表级锁</strong>： MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。</li>
<li><strong>行级锁</strong>： MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。<ul>
<li><strong>记录锁</strong>（Record Lock）：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁</strong>（Gap Lock）：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁</strong>（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。<strong>记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</strong><blockquote>
<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="索引相关："><a href="#索引相关：" class="headerlink" title="索引相关："></a>索引相关：</h1><p><strong>扯①索引的作用（优缺点）+②存储引擎（底层数据结构）+③创建索引的原则</strong><br><strong>索引是一种用于快速查询和检索数据的数据结构，本质可以看成是一种排序好的数据结构。</strong><br>索引的优缺点：</p>
<ul>
<li><strong>优点：大大加快 数据的检索速度，降低数据库的IO成本。</strong></li>
<li><strong>缺点：创建索引和维护索引需要耗费大量时间，索引的存储也需要消耗一定的空间。</strong></li>
</ul>
<h2 id="索引的底层数据结构选型（⭐）"><a href="#索引的底层数据结构选型（⭐）" class="headerlink" title="索引的底层数据结构选型（⭐）"></a>索引的底层数据结构选型（⭐）</h2><pre><code>    索引底层数据结构存在很多种类型，常见的索引结构有:** B 树， B+树 和 Hash、红黑树**。在 MySQL 中，**无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。**
    下面分别介绍几种索引结构以及为什么要选择B+树做索引结构。
</code></pre>
<ul>
<li><p><strong>哈希表</strong>是键值对的集合，通过key可以快速地检索到对应的值，因此哈希表可以快速检索数据。然而，因为hash索引是精确查找，不支持范围查询，因此不使用hash作为索引结构。</p>
</li>
<li><p><strong>AVL树</strong>(平衡二叉查找树)解决了二叉查找树最坏情形退化成链表的情况，但是需要不断地旋转操作来保持树地平衡，I&#x2F;O磁盘操作次数较多。</p>
</li>
<li><p><strong>红黑树</strong>不和AVL树一样追求绝对平衡，只追求大致平衡，但因此红黑树的高度也会较高，检索数据时也需要较多的IO磁盘。</p>
</li>
<li><p><strong>B树</strong>，全称多路平衡查找树，B+ 树是 B 树的一种变体，二者区别如下：</p>
<ul>
<li><p>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他节点只存放 key，相当于索引。</p>
</li>
<li><p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
</li>
<li><p>B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>
<p>   <strong>选用B+树的主要原因:</strong></p>
</li>
</ul>
</li>
<li><p>阶数更多，路径更短。</p>
</li>
<li><p>磁盘读写代价 更低，非叶子节点只存储指针，叶子节点存储数据。</p>
</li>
<li><p>B+ 树便于扫库和区间查询，叶子节点是一个双向链表。</p>
</li>
</ul>
<h2 id="MySQL中，如何定位慢查询"><a href="#MySQL中，如何定位慢查询" class="headerlink" title="MySQL中，如何定位慢查询?"></a>MySQL中，如何定位慢查询?</h2><p>MySQL中也提供了<strong>慢日志查询</strong>的功能，可以在MySQL的系统配置文件中开启这个慢日志的功能，并且也可以设置SQL执行超过多少时间来记录到一个日志文件中。</p>
<h2 id="那这个SQL语句执行很慢-如何分析呢？"><a href="#那这个SQL语句执行很慢-如何分析呢？" class="headerlink" title="那这个SQL语句执行很慢, 如何分析呢？"></a>那这个SQL语句执行很慢, 如何分析呢？</h2><p>可以使用MySQL自带的explain来查看这条SQL语句的执行计划，如下图：<br><img src="/2024/08/02/MySQL%E7%AF%87/5.png"><br>可以从以下三个方面进行分析：</p>
<ul>
<li>通过key和key_len检查是否命中了索引。</li>
<li>通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描。<ul>
<li>type 性能由好到差为：</li>
<li>system：查询系统中的表。</li>
<li>const：根据主键查询。</li>
<li>eq ref：主键索引查询或唯一索引查询。</li>
<li>ref：索引查询。</li>
<li>range：范围查询。</li>
<li>index：全索引扫描。</li>
<li>all：全盘扫描。</li>
</ul>
</li>
<li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。</li>
</ul>
<h2 id="什么是聚簇索引什么是非聚簇索引-（⭐）"><a href="#什么是聚簇索引什么是非聚簇索引-（⭐）" class="headerlink" title="什么是聚簇索引什么是非聚簇索引 ?（⭐）"></a>什么是聚簇索引什么是非聚簇索引 ?（⭐）</h2><ul>
<li><strong>聚簇索引</strong>（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个，一般是主键索引。</li>
<li><strong>非聚簇索引</strong>（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个。</li>
</ul>
<h2 id="什么是回表查询-（⭐）"><a href="#什么是回表查询-（⭐）" class="headerlink" title="什么是回表查询?（⭐）"></a>什么是回表查询?（⭐）</h2><p> <strong>通过二级索引找到对应的主键值，再通过主键值到聚集索引中查找整行数据的过程。</strong></p>
<h2 id="什么是覆盖索引-（⭐）"><a href="#什么是覆盖索引-（⭐）" class="headerlink" title="什么是覆盖索引?（⭐）"></a>什么是覆盖索引?（⭐）</h2><p><strong>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</strong></p>
<ul>
<li>使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</li>
<li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *</li>
</ul>
<h2 id="MYSQL超大分页怎么处理"><a href="#MYSQL超大分页怎么处理" class="headerlink" title="MYSQL超大分页怎么处理 ?"></a>MYSQL超大分页怎么处理 ?</h2><pre><code>    超大分页一般都是在数据量比较大时，我们使用了limit 分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决：
</code></pre>
<p>先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了。  由于查询id的时候走的覆盖索引，效率相对较高。        </p>
<h2 id="索引创建原则有哪些？（⭐）"><a href="#索引创建原则有哪些？（⭐）" class="headerlink" title="索引创建原则有哪些？（⭐）"></a>索引创建原则有哪些？（⭐）</h2><ul>
<li><strong>针对数据量较大，且查询比较频繁的表。(10w数据量)</strong></li>
<li><strong>针对常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</strong></li>
<li><strong>尽量使用联合索引，避免回表，提升效率。</strong></li>
<li><strong>控制索引的数量，索引越多，维护索引的成本越高，会影响到增删改的效率。</strong></li>
<li><strong>尽量选择区分度高的列作为索引。</strong></li>
<li>如果是字符串类型的字段作为索引，且字段较长，建立前缀索引。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。</li>
</ul>
<h2 id="什么情况下索引会失效-（⭐）"><a href="#什么情况下索引会失效-（⭐）" class="headerlink" title="什么情况下索引会失效 ?（⭐）"></a>什么情况下索引会失效 ?（⭐）</h2><ul>
<li><strong>违反最左前缀法则。（主要针对联合索引）</strong></li>
<li><strong>范围查询右边的列，不能使用索引 。</strong></li>
<li><strong>索引列上进行运算操作， 索引将失效。</strong></li>
<li><strong>字符串不加单引号，造成索引失效。(发生了类型转换)</strong></li>
<li><strong>以%开头的Like模糊查询，索引失效。（%结尾不会失效）</strong></li>
</ul>
<h2 id="谈一谈你对sql的优化的经验"><a href="#谈一谈你对sql的优化的经验" class="headerlink" title="谈一谈你对sql的优化的经验"></a>谈一谈你对sql的优化的经验</h2><ul>
<li><strong>表的设计优化。</strong><ul>
<li>如设置合适的数值类型（int、bigint、tinyint），字符串类型（char、varchar）</li>
</ul>
<p>		</p>
</li>
<li><strong>索引优化：索引创建原则、避免索引失效。</strong><ul>
<li>见以上第8、9点。</li>
</ul>
</li>
<li><strong>SQL语句优化。</strong><ul>
<li><strong>如：select语句指明具体字段，尽量避免使用select * ，防止回表查询。</strong></li>
<li><strong>SQL语句尽量避免造成索引失效的写法。</strong></li>
<li><strong>尽量用union all代替union，union会去重，多一次过滤操作，效率低。</strong></li>
<li><strong>Join优化 能用inner join 就不用left join right join，如必须使用 一定要以小表为驱动。</strong></li>
</ul>
</li>
<li><strong>主从复制、读写分离。</strong><ul>
<li>数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。</li>
</ul>
</li>
<li><strong>分库分表。</strong></li>
</ul>
<h2 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h2><p>现在，几乎所有的系统都支持邮箱登录，那么如何在邮箱这样的字段上建立合理的索引呢？<br><strong>MySQL 是支持前缀索引的</strong>，因此给邮箱字段添加索引有两种方法：</p>
<ul>
<li><strong>定义字符串的一部分作为索引。</strong><ul>
<li><strong>占用空间更小，但是可能会增加额外的扫描次数，影响性能。</strong></li>
</ul>
</li>
<li><strong>定义整个字符串作为索引。</strong><ul>
<li><strong>占用空间较大，但是只要扫描一次。</strong></li>
</ul>
</li>
</ul>
<p><strong>sql语句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index <span class="title function_">index1</span><span class="params">(email)</span>;</span><br><span class="line">或</span><br><span class="line">mysql&gt; alter table SUser add index <span class="title function_">index2</span><span class="params">(email(<span class="number">6</span>)</span>);</span><br></pre></td></tr></table></figure>













    </div>

    
    
    
	
	 
       <div>
		 <div>
    
        <div style="text-align:center;color: #00BFFF;font-size:18px;"><br>-------------------- 本文结束 <i class="fas fa-heart"></i> 感谢您的阅读！ -------------------</div>
    
</div>
	   </div>
     

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/02/%E9%9B%86%E5%90%88%E7%AF%87/" rel="prev" title="Java集合">
      <i class="fa fa-chevron-left"></i> Java集合
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/08/05/Redis%E7%AF%87/" rel="next" title="Redis">
      Redis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">常规：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">数据库三大范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">主键和外键的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CHAR-%E5%92%8C-VARCHAR-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">CHAR 和 VARCHAR 的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DECIMAL-%E5%92%8C-FLOAT-DOUBLE-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NULL-%E5%92%8C-%E2%80%98-%E2%80%98-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">NULL 和 ‘ ‘ 的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boolean-%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">Boolean 类型如何表示？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-%E2%AD%90%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">1.7.</span> <span class="nav-text">MySQL 基础架构及执行过程(⭐执行一条select语句期间发生了什么)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM-%E5%92%8C-InnoDB-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.8.</span> <span class="nav-text">MySQL 存储引擎MyISAM 和 InnoDB 有什么区别？（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">事务的四大特性（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">MySQL事务隔离级别（⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="nav-number">1.10.1.</span> <span class="nav-text">可重复读又是如何解决幻读问题的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-undo-log%E3%80%81redo-log-%E5%92%8C-bin-log"><span class="nav-number">1.11.</span> <span class="nav-text">解释一下 undo log、redo log 和 bin log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%9A%84%E5%91%A2%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.12.</span> <span class="nav-text">事务中的隔离性是如何保证的呢？（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.13.</span> <span class="nav-text">MySQL主从同步原理（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.14.</span> <span class="nav-text">drop、delete与truncate的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%9F"><span class="nav-number">1.15.</span> <span class="nav-text">什么是视图？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%9A%84%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">1.16.</span> <span class="nav-text">MySQL的表级锁和行级锁（⭐）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">索引相关：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">索引的底层数据结构选型（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.</span> <span class="nav-text">MySQL中，如何定位慢查询?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%A3%E8%BF%99%E4%B8%AASQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%91%A2%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">那这个SQL语句执行很慢, 如何分析呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">什么是聚簇索引什么是非聚簇索引 ?（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">什么是回表查询?（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">什么是覆盖索引?（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MYSQL%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">2.7.</span> <span class="nav-text">MYSQL超大分页怎么处理 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.8.</span> <span class="nav-text">索引创建原则有哪些？（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88-%EF%BC%88%E2%AD%90%EF%BC%89"><span class="nav-number">2.9.</span> <span class="nav-text">什么情况下索引会失效 ?（⭐）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E5%AF%B9sql%E7%9A%84%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="nav-number">2.10.</span> <span class="nav-text">谈一谈你对sql的优化的经验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">2.11.</span> <span class="nav-text">怎么给字符串字段加索引？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴华杰"
      src="/images/jay.jpg">
  <p class="site-author-name" itemprop="name">吴华杰</p>
  <div class="site-description" itemprop="description">Time will tell</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:1002372564@qq.com" title="E-Mail → mailto:1002372564@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-07-31 @ – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴华杰</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共46.6k字</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

</body>
</html>
