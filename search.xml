<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>首页</title>
    <url>/2024/07/31/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div style="text-align: center; font-size: 24px;">
<b>  欢迎来到 Michael-Jay 的博客！ </b>
</div>
<div style="text-align: center; font-size: 20px;">
我将在这里记录我的学习历程、生活感悟、兴趣爱好等 
</div>
<div style="text-align: center; font-size: 20px;">
送各位一首<b>好了歌</b>，愿我们都能不忘初心：                        
</div>
<br>
<div style="text-align: center; font-size: 20px;"> 

<p><em>世人都晓神仙好，惟有功名忘不了。</em></p>
<p><em>古今将相在何方？荒冢一堆草没了。</em></p>
<p><em>世人都晓神仙好，只有金银忘不了。</em></p>
<p><em>终朝只恨聚无多，及到多时眼闭了。</em></p>
<p><img src="/2024/07/31/hello-world/1.jpg"></p>
</div>





]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2024/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><p>二叉树前序遍历有两种方式，一种是<strong>递归法</strong>，还一种是用<strong>栈模拟迭代</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        travelsal(ans,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travelsal</span><span class="params">(List&lt;Integer&gt; list, TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        travelsal(list,node.left);</span><br><span class="line">        travelsal(list,node.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="comment">//此处要先放右孩子再放左孩子，因为栈是先进后出的。</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traversal(ans,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(List&lt;Integer&gt; ans, TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traversal(ans,node.left);</span><br><span class="line">        ans.add(node.val);</span><br><span class="line">        traversal(ans,node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历的迭代法，需要用一个cur变量，从左子树的最左节点开始遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                ans.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traversal(ans,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(List&lt;Integer&gt; ans, TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traversal(ans,node.left);</span><br><span class="line">        traversal(ans,node.right);</span><br><span class="line">        ans.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历的迭代法可以通过先序遍历的迭代法得到“中-右-左”的元素顺序，然后再反转即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时ans中元素的顺序为：中-右-左,倒置之后就是后序遍历了</span></span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p>二叉树的层序遍历需要靠队列来实现，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queue.addFirst(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.addFirst(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.addFirst(node.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p><img src="/2024/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91/1.png" alt="image.png"><br><strong>在层序遍历的代码上添加交换左右节点的逻辑即可：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        queue.addFirst(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">                <span class="comment">//交换左右孩子节点，即使是null也要换，所以不用判空操作。</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">                node.left = node.right;</span><br><span class="line">                node.right = temp;</span><br><span class="line">                <span class="comment">//将左右孩子放入队列，此时就要判空了。</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.addFirst(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.addFirst(node.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><img src="/2024/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91/2.png" alt="image.png"><br>本题在<strong>层序遍历</strong>的基础上，每一层对全局变量ans进行++操作即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue.addFirst(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.addFirst(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.addFirst(node.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p><img src="/2024/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91/3.png" alt="image.png"><br>思路和求<strong>二叉树最大深度</strong>类似，在内层while循环中加一句判断：当当前节点的左右孩子节点都为空时，直接返回当前深度，此时也就是二叉树的最小深度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue.addFirst(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">                <span class="comment">//左右孩子节点都为空，则此时的树高为二叉树的最小深度。</span></span><br><span class="line">                <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.addFirst(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.addFirst(node.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><p><img src="/2024/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91/4.png" alt="image.png"><br>本题依旧是可以用<strong>层序遍历</strong>的逻辑来做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue.addFirst(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.addFirst(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.addFirst(node.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><img src="/2024/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91/5.png" alt="image.png"><br>将左右孩子节点放入一个队列queue中，依次比较左右孩子是否对称，需要注意的是 **左节点的左孩子要跟右节点的右孩子作比较，左节点的右孩子要跟右节点的左孩子作比较。 **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.addFirst(root.left);</span><br><span class="line">        queue.addFirst(root.right);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left_node</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right_node</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">            <span class="keyword">if</span>(left_node==<span class="literal">null</span> &amp;&amp; right_node==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//左右子树不一致，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span>(left_node==<span class="literal">null</span> || right_node==<span class="literal">null</span> || left_node.val!=right_node.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//左节点的左孩子和右节点的右孩子作比较</span></span><br><span class="line">            queue.addFirst(left_node.left);</span><br><span class="line">            queue.addFirst(right_node.right);</span><br><span class="line">            <span class="comment">//左节点的右孩子和右节点的左孩子作比较</span></span><br><span class="line">            queue.addFirst(left_node.right);</span><br><span class="line">            queue.addFirst(right_node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h1><p><img src="/2024/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91/6.png" alt="image.png"><br>本题可以用<strong>动态规划</strong>来做，分析当n&#x3D;3的情况：</p>
<ul>
<li>当1作为根节点，此时左子树有0个节点，右子树有2两个节点，此时的二叉树种数应该有dp[0]*dp[2]种。</li>
<li>当2作为根节点，此时左右子树各有一个节点，种数都是dp[1]，此时的二叉树种数应该有dp[1]*dp[1]种。</li>
<li>当3作为根节点，此时情况和第一种情况类似，只是左右子树交换了。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i-j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h1><p><img src="/2024/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91/7.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//找切割点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">seg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[<span class="number">0</span>])&#123;</span><br><span class="line">                seg = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切割数组</span></span><br><span class="line">        <span class="type">int</span>[] in_left = Arrays.copyOfRange(inorder,<span class="number">0</span>,seg);</span><br><span class="line">        <span class="type">int</span>[] in_right = Arrays.copyOfRange(inorder,seg+<span class="number">1</span>,inorder.length);</span><br><span class="line">        <span class="type">int</span>[] pre_left = Arrays.copyOfRange(preorder,<span class="number">1</span>,in_left.length+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[] pre_right = Arrays.copyOfRange(preorder,in_left.length+<span class="number">1</span>,preorder.length);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root.left = buildTree(pre_left,in_left);</span><br><span class="line">        root.right = buildTree(pre_right,in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>几种重要的排序算法</title>
    <url>/2024/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>十种常见排序算法可以分类两大类别：<strong>比较类排序</strong>和<strong>非比较类排序</strong>。</p>
<p><img src="/2024/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png"></p>
<p>常见的<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。比较类排序是通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)。在冒泡排序之类的排序中，问题规模为 n，又因为需要比较 n 次，所以平均时间复杂度为 O(n²)。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 logn 次，所以时间复杂度平均 O(nlogn)。</p>
<p><strong>非比较类排序</strong>不通过比较来决定元素间的相对次序，而是<strong>通过确定每个元素之前，应该有多少个元素来排序</strong>。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序是一种简单的排序算法。它<strong>重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来</strong>。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮”到数列的顶端。</p>
<p><img src="/2024/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.gif"><br><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                </span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>此处对代码做了一个小优化，加入了一个Flag变量，当原输入序列就是排序好的情况下，停止遍历，此时时间复杂度为O(n)。</strong><br><strong>算法分析：</strong></p>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度：</strong> 最佳：O(n) , 最差：O(n2)，平均：O(n2)</li>
<li><strong>空间复杂度：</strong> O(1)</li>
</ul>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>选择排序</strong>的思想更加朴实：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。其时间复杂度永远都是O(n2)。</p>
<p><img src="/2024/08/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.gif"><br><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度：</strong> 最佳：O(n2) , 最差：O(n2)，平均：O(n2)</li>
<li><strong>空间复杂度：</strong> O(1)</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>快速排序</strong>的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p>
<p><strong>算法步骤：</strong></p>
<ul>
<li>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<strong>pivot</strong>)；</li>
<li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。</li>
<li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= base)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= base)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时left = right</span></span><br><span class="line">        nums[left] = base;</span><br><span class="line">        quick_sort(nums,start,left-<span class="number">1</span>);</span><br><span class="line">        quick_sort(nums,left+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度：</strong> 最佳：O(nlogn) , 最差：O(nlogn)，平均：O(nlogn)</li>
<li><strong>空间复杂度：</strong> O(logn)</li>
</ul>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><strong>堆排序(Heap Sort)<strong>是指利用</strong>堆</strong>这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于(或者大于)它的父节点。堆的底层是一棵完全二叉树。而完全二叉树是一层一层按照进入的顺序排成的。按照这个特性，我们可以用数组来按照完全二叉树实现堆。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>构建初始堆，将待排序列构成一个大顶堆(或者小顶堆)，升序大顶堆，降序小顶堆；</li>
<li>将堆顶元素与堆尾元素交换，并断开(从待排序列中移除)堆尾元素。</li>
<li>重新构建堆。</li>
<li>重复2~3，直到待排序列中只剩下一个元素(堆顶元素)。</li>
</ol>
<p><strong>代码实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 手撕堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Jay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2024-05-02 11:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heapSort</span> &#123;</span><br><span class="line">    <span class="comment">//堆的长度大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> heapLen;</span><br><span class="line">    <span class="comment">//定义 交换数组两元素 的函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化构建大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//从最后一个非叶子节点开始,对应的索引为 arr.length / 2 - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            adjustHeap(arr,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; heapLen &amp;&amp; arr[right] &gt; arr[largest])&#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; heapLen &amp;&amp; arr[left] &gt; arr[largest])&#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">            swap(arr,largest,i);</span><br><span class="line">            adjustHeap(arr,largest); <span class="comment">//交换之后，子节点可能不满足堆的性质了，需要重新调整。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">16</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">20</span>,<span class="number">17</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        heapLen = arr.length;</span><br><span class="line">        buildHeap(arr);</span><br><span class="line">        <span class="comment">//交换堆顶和堆尾元素，再重新调整堆。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            swap(arr,i,<span class="number">0</span>);</span><br><span class="line">            heapLen--;</span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度：</strong> 最佳：O(nlogn) , 最差：O(nlogn)，平均：O(nlogn)</li>
<li><strong>空间复杂度：</strong> O(1)</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>永福</title>
    <url>/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="海纳特电项目"><a href="#海纳特电项目" class="headerlink" title="海纳特电项目"></a>海纳特电项目</h1><p>这个项目是一个老项目，我主要负责新增或者维护一些功能接口。</p>
<h2 id="工商业光伏项目模块"><a href="#工商业光伏项目模块" class="headerlink" title="工商业光伏项目模块"></a>工商业光伏项目模块</h2><h3 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h3><p>提供一个下载 excel 模板的接口，如图：<img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/1.png" alt="image.png"><br>代码逻辑比较简单，在对应的 <strong>controller</strong> 中加一个方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;下载模板&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/download/template&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downloadTemplate</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename*=utf-8&#x27;&#x27;工商业光伏项目模板.xlsx&quot;</span>);</span><br><span class="line">    IOUtils.copyLarge(templateResource.getInputStream(), response.getOutputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法参数：</strong><ul>
<li>接收一个 response 参数，用于向客户端发送 HTTP 响应。</li>
</ul>
<p>	</p>
</li>
<li><strong>方法体：</strong><ul>
<li>设置相应的 contentType，表示下载的文件为 excel 文件。</li>
<li>设置了Content-Disposition响应头部，指示客户端以附件形式下载文件。</li>
<li>最后，通过IOUtils工具类将模板文件的输入流写入到HTTP响应的输出流中，从而实现文件下载。</li>
</ul>
</li>
</ul>
<h3 id="导入-excel-文件"><a href="#导入-excel-文件" class="headerlink" title="导入 excel 文件"></a>导入 excel 文件</h3><p>提供一个导入 excel 文件的接口，如下图：<br><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/2.png" alt="image.png"><br>直接看核心方法代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importExcel</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    List&lt;PhotovoltaicEarlyStageExcelReq&gt; list;</span><br><span class="line">    List&lt;PhotovoltaicEarlyStage&gt; addData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Project&gt; addData2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        list = ExcelUtils.readExcel(file.getInputStream(), PhotovoltaicEarlyStageExcelReq.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JafException</span>(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行校验和入库对象的转换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        <span class="type">PhotovoltaicEarlyStageExcelReq</span> <span class="variable">photovoltaicEarlyStageExcelReq</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        <span class="type">PhotovoltaicEarlyStage</span> <span class="variable">photovoltaicEarlyStage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhotovoltaicEarlyStage</span>();</span><br><span class="line">        <span class="type">Project</span> <span class="variable">project</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Project</span>();</span><br><span class="line">        BeanUtil.copyProperties(photovoltaicEarlyStageExcelReq,photovoltaicEarlyStage);</span><br><span class="line">        <span class="comment">//赋值，除了“项目性质”字段</span></span><br><span class="line">        String[] ignoreProperties = &#123;<span class="string">&quot;nature&quot;</span>&#125;;</span><br><span class="line">        BeanUtil.copyProperties(photovoltaicEarlyStageExcelReq,project,ignoreProperties);</span><br><span class="line">        <span class="comment">//单独给“项目性质”字段赋值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nature</span> <span class="operator">=</span> photovoltaicEarlyStageExcelReq.getNature();</span><br><span class="line">        project.setNature(ProjectNatureEnum.getCodeByDesc(nature));</span><br><span class="line">        <span class="comment">//单独给“项目类型”字段赋值</span></span><br><span class="line">        project.setType(ProjectTypeEnum.GFXM.getCode());</span><br><span class="line">        <span class="comment">//检验项目名称是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(photovoltaicEarlyStageExcelReq.getName()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JafException</span>(String.format(RMsg.IMPORT_EXCEL_CHECK_DATA_ERROR, (i + <span class="number">1</span>), <span class="string">&quot;项目名称&quot;</span>, <span class="string">&quot;不能为空！&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据项目名称获取电站信息,并校验电站信息是否存在</span></span><br><span class="line">        <span class="type">StationManage</span> <span class="variable">stationManage</span> <span class="operator">=</span> stationManageService.getDetailByProjectName(photovoltaicEarlyStageExcelReq.getName());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(stationManage)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JafException</span>(String.format(RMsg.IMPORT_EXCEL_CHECK_DATA_ERROR, (i + <span class="number">1</span>), <span class="string">&quot;项目对应的电站信息&quot;</span>, <span class="string">&quot;不存在！&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addData2.add(project);</span><br><span class="line">        addData.add(photovoltaicEarlyStage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(addData)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.saveBatch(addData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isNotEmpty(addData2))&#123;</span><br><span class="line">        projectService.saveBatch(addData2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法参数：</strong><ul>
<li>file 参数用于接受用户提供的 excel 文件。</li>
</ul>
</li>
<li><strong>方法体：</strong><ol>
<li>首先创建一个 dto 实体类PhotovoltaicEarlyStageExcelReq，其字段和 excel 中的列名相对应。</li>
<li>由于这个 excel 的字段涉及到两张表，即<strong>PhotovoltaicEarlyStage</strong> 和<strong>Project</strong> 实体类，因此分别创建对应的两个 list 集合，用于存最后需要保存到数据库的数据。</li>
<li>使用ExcelUtils 的方法，将传进来的 excel 转成对应的 list 集合。</li>
<li>遍历 list 集合，使用 BeanUtil 的 copyProperties 方法将 dto 中的数据转存至开头说的那两个实体类中，<strong>但是有些数据需要手动赋值，因为有些字段需要利用枚举将 code 转换成 name</strong>。将赋值完的实体加入对应的 list 集合中，即 b 操作对应的两个 list 集合。</li>
<li>利用 saveBatch 方法将两个 list 集合保存至数据库中。</li>
</ol>
</li>
</ul>
<h3 id="导出-excel-文件"><a href="#导出-excel-文件" class="headerlink" title="导出 excel 文件"></a>导出 excel 文件</h3><p>提供一个导出 excel 文件的接口，该接口将页面的所有数据导出至 excel 文件中，需要导出的数据稍微有点复杂，如下图：<img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/3.png" alt="image.png"><br>这些数据包括三大块五张表：基础信息、往来单位、项目计划。基础信息包括三个表：PhotovoltaicEarlyStage、Project、User 表。往来单位包括一张表：OtherUnit。项目计划包括一张表：PhotovoltaicEarlyPlan。<br>这里导出时要注意：<strong>每一个项目计划都对应着 excel 的一条记录，也就是说有 16 个项目计划，就要有 16 条 excel 记录，这些记录的基础信息、往来单位字段都是一样的</strong>。<br><strong>因此导出数据的时候，每一个工商业光伏项目对应 m 个项目计划，有 n 个工商业光伏项目记录的话，一共就需要导出 n*m 条 excel 记录，所以代码逻辑是需要两层 for 循环的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">(PhotovoltaicEarlyStagePageReq requestBody, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    List&lt;PhotovoltaicEarlyStage&gt; list = list(<span class="built_in">this</span>.getQueryWrapper(requestBody));</span><br><span class="line">    List&lt;PhotovoltaicEarlyStage&gt; finalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PhotovoltaicEarlyStage photovoltaicEarlyStage : list)&#123;</span><br><span class="line">        <span class="type">Project</span> <span class="variable">project</span> <span class="operator">=</span> projectService.getById(photovoltaicEarlyStage.getProjectId());</span><br><span class="line">        <span class="comment">//填充基础信息字段</span></span><br><span class="line">        photovoltaicEarlyStage.setProjectName(project.getName());</span><br><span class="line">        photovoltaicEarlyStage.setProjectCode(project.getCode());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">nature</span> <span class="operator">=</span> project.getNature();</span><br><span class="line">        photovoltaicEarlyStage.setProjectNatureName(ProjectNatureEnum.getDescByCode(nature));</span><br><span class="line">        userService.fillUserNameByList(list,PhotovoltaicEarlyStage::getProjectManagerUid,PhotovoltaicEarlyStage::setProjectManagerName);</span><br><span class="line">        userService.fillUserNameByList(list,PhotovoltaicEarlyStage::getAreaManagerUid,PhotovoltaicEarlyStage::setAreaManagerName);</span><br><span class="line">        <span class="comment">//填充往来单位字段</span></span><br><span class="line">        <span class="type">OtherUnit</span> <span class="variable">otherUnit</span> <span class="operator">=</span> otherUnitService.getById(photovoltaicEarlyStage.getStructuralSurveyUnitId());</span><br><span class="line">        <span class="keyword">if</span>(otherUnit!=<span class="literal">null</span>) photovoltaicEarlyStage.setStructuralSurveyUnitName(otherUnit.getName());</span><br><span class="line">        <span class="type">OtherUnit</span> <span class="variable">otherUnit1</span> <span class="operator">=</span> otherUnitService.getById(photovoltaicEarlyStage.getStructuralReviewUnitId());</span><br><span class="line">        <span class="keyword">if</span>(otherUnit1!=<span class="literal">null</span>) photovoltaicEarlyStage.setStructuralReviewUnitName(otherUnit1.getName());</span><br><span class="line">        <span class="type">OtherUnit</span> <span class="variable">otherUnit2</span> <span class="operator">=</span> otherUnitService.getById(photovoltaicEarlyStage.getDesignUnitId());</span><br><span class="line">        <span class="keyword">if</span>(otherUnit2!=<span class="literal">null</span>) photovoltaicEarlyStage.setDesignUnitName(otherUnit2.getName());</span><br><span class="line">        <span class="type">OtherUnit</span> <span class="variable">otherUnit3</span> <span class="operator">=</span> otherUnitService.getById(photovoltaicEarlyStage.getControlUnitId());</span><br><span class="line">        <span class="keyword">if</span>(otherUnit3!=<span class="literal">null</span>) photovoltaicEarlyStage.setControlUnitName(otherUnit3.getName());</span><br><span class="line">        <span class="type">OtherUnit</span> <span class="variable">otherUnit4</span> <span class="operator">=</span> otherUnitService.getById(photovoltaicEarlyStage.getConstructionUnitId());</span><br><span class="line">        <span class="keyword">if</span>(otherUnit4!=<span class="literal">null</span>) photovoltaicEarlyStage.setConstructionUnitName(otherUnit4.getName());</span><br><span class="line">        <span class="comment">//填充项目计划字段</span></span><br><span class="line">        List&lt;PhotovoltaicEarlyPlan&gt; list1 = photovoltaicEarlyPlanService.list(Wrappers.lambdaQuery(PhotovoltaicEarlyPlan.class).eq(PhotovoltaicEarlyPlan::getStageId, photovoltaicEarlyStage.getId()));</span><br><span class="line">        <span class="keyword">for</span> (PhotovoltaicEarlyPlan photovoltaicEarlyPlan : list1)&#123;</span><br><span class="line">            <span class="comment">//PhotovoltaicEarlyStage副本,防止原始PhotovoltaicEarlyStage被污染</span></span><br><span class="line">            <span class="type">PhotovoltaicEarlyStage</span> <span class="variable">photovoltaicEarlyStage1</span> <span class="operator">=</span> mapperFacade.map(photovoltaicEarlyStage,PhotovoltaicEarlyStage.class);</span><br><span class="line">            <span class="comment">//photovoltaicEarlyPlan对象部分字段 填充 到PhotovoltaicEarlyStage中</span></span><br><span class="line">            <span class="type">PhotovoltaicEarlyPlanTemplate</span> <span class="variable">photovoltaicEarlyPlanTemplate</span> <span class="operator">=</span> photovoltaicEarlyPlanTemplateService.getOne(Wrappers.lambdaQuery(PhotovoltaicEarlyPlanTemplate.class)</span><br><span class="line">                    .eq(PhotovoltaicEarlyPlanTemplate::getNodeCode, photovoltaicEarlyPlan.getNodeCode()));</span><br><span class="line">            photovoltaicEarlyStage1.setProjectNode(photovoltaicEarlyPlanTemplate.getProjectNode());</span><br><span class="line">            photovoltaicEarlyStage1.setPlanStartTime(photovoltaicEarlyPlan.getPlanStartTime());</span><br><span class="line">            photovoltaicEarlyStage1.setPlanEndTime(photovoltaicEarlyPlan.getPlanEndTime());</span><br><span class="line">            photovoltaicEarlyStage1.setActualStartTime(photovoltaicEarlyPlan.getActualStartTime());</span><br><span class="line">            photovoltaicEarlyStage1.setActualEndTime(photovoltaicEarlyPlan.getActualEndTime());</span><br><span class="line">            userService.fillUserNameByList(list1,PhotovoltaicEarlyPlan::getManagerUid,PhotovoltaicEarlyPlan::setManagerName);</span><br><span class="line">            photovoltaicEarlyStage1.setManager(photovoltaicEarlyPlan.getManagerName());</span><br><span class="line">            <span class="comment">//PhotovoltaicEarlyStage1对象加入finalList中</span></span><br><span class="line">            finalList.add(photovoltaicEarlyStage1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;PhotovoltaicEarlyStageExportExcelReq&gt; photovoltaicEarlyStageExportExcelReqs = mapperFacade.mapAsList(finalList, PhotovoltaicEarlyStageExportExcelReq.class);</span><br><span class="line">    ExcelUtils.exportExcelByClass(response,<span class="string">&quot;光伏项目&quot;</span>,photovoltaicEarlyStageExportExcelReqs, PhotovoltaicEarlyStageExportExcelReq.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要逻辑就是将需要导出的记录数据封装到一个 PhotovoltaicEarlyStage 实体类组成的 finalList 集合中，再调用mapperFacade 中的 mapAsList 方法将字段 copy 到一个由 dto 组成的集合中，这个 dto 是专门为了导出 excel 建立的 dto 实体类。最后再调用ExcelUtils 的exportExcelByClass 方法将集合中的数据导出到 excel 文件中。<br><strong>也可以使用 BeanUtil 的 copyPropertity 方法代替 mapperFacade ，其区别是：</strong><br><strong>copyPropertity 默认是浅拷贝，mapperFacade 默认是深拷贝。</strong><br><strong>几个犯错的地方：</strong></p>
<ul>
<li><p><strong>深拷贝浅拷贝问题：</strong>同一条光伏项目数据对应多条项目计划条目，这些条目的基础信息、往来单位字段都是一样的，但是项目计划的字段不一样，因此在第一层 for 循环后，需要将之前保存了基础信息等字段的实体类存一个副本，这里存副本的时候，我是用的直接赋值的方式，这种方式属于<strong>浅拷贝</strong>，<strong>拷贝的只是对象的内存地址，相当于栈中的两个引用指向了堆中的同一个对象</strong>，后面修改的时候就会对原始副本对象造成污染。后续我采用<strong>深拷贝</strong>的方式：mapperFacade.map 拷贝了原始副本，<strong>深拷贝的两个引用对应的就是堆中的两个不同的对象了，只是数据一样而已。</strong></p>
</li>
<li><p>在mapperFacade.mapAsList 的转换中出现的问题：</p>
<ul>
<li>出现原始 dto 的属性值没有移植到目标 dto 对象，原因是目标 dto 的类中没有加入@DATA注解。 因为mapAsList 底层也需要通过 set 方式进行数据移植的。</li>
<li><strong>LocalDateTime 日期格式转换错误问题：</strong> 在调用 mapperFacade.mapAsList 将集合映射到另一个 dto 集合时，出现了日期格式转换错误问题，解决方法是：自定义一个转换器类，需要实现阿里巴巴的Converter<LocalDateTime>接口，然后在注解@ExcelProperty 中添加此转换器即可。</LocalDateTime></li>
</ul>
</li>
<li><p><strong>空指针异常问题</strong>：经常出现一些字段报空指针异常错误，需要有判空操作。</p>
</li>
</ul>
<h2 id="运维管理模块"><a href="#运维管理模块" class="headerlink" title="运维管理模块"></a>运维管理模块</h2><h3 id="巡检计划和巡检记录——增删改查操作"><a href="#巡检计划和巡检记录——增删改查操作" class="headerlink" title="巡检计划和巡检记录——增删改查操作"></a>巡检计划和巡检记录——增删改查操作</h3><p><strong>巡检指对设备（即电站）进行定期检查和维护的活动，以确保其正常运行和安全性。巡检记录是关联于巡检计划的，因此删除计划之前需要先判断有无对应的记录，有的话则无法删除（踩坑点）。</strong><br><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/4.png" alt="image.png"><br>包括巡检计划和巡检记录两个表，<strong>巡检记录</strong>中又内嵌一个<strong>巡检结果表</strong>，如下图：<br><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/5.png" alt="image.png"><br>因此在巡检记录实体类中添加一个非数据库字段：<strong>由巡检结果实体组成的 list 集合</strong>。同时巡检结果实体中需要有一个字段关联该巡检记录 id。<br>常规的增删改查就不多说了，说几个做的过程中需要注意的点：</p>
<ul>
<li><strong>关联问题</strong>：巡检记录是关联于巡检计划的，因此在删除巡检计划的时候，需要判断对应的巡检记录有没有删除，如果没有删除是不允许删除巡检计划的。</li>
<li><strong>日期类字段问题</strong>：由于前端传过来的日期是字符串格式，后端是日期格式，两者不兼容，因此后端与前端交互的实体类中的日期字段需要添加<strong>日期转换格式</strong>的注解：	<ul>
<li>日期类： @DateTimeFormat(pattern &#x3D; CommonConstants.DOMAIN_DATE_PATTERN)  </li>
<li>日期+时间类： @JsonFormat(pattern &#x3D; CommonConstants.DOMAIN_TIME_PATTERN, timezone &#x3D; CommonConstants.DOMAIN_TIME_ZONE)</li>
</ul>
</li>
<li>在巡检计划表中，电站名和负责人都是以 id 的形式存储的，因此<strong>在对应的实体类中需要添加两个非数据库字段，对应电站的名称和负责人的名称</strong>。电站的名称需要关联另外一张表查询，负责人名称需要调用用户中心的接口查询。</li>
<li>类似于巡检状态这种下拉框的字段一般存于一个字典表 dim 中，表中用 int 类型存储，实体类中设置一个非数据库字段：巡检状态名称。 然后通过 dimservice 提供的接口将 int 转换成对应的名称。</li>
<li>删除接口中，由于是批量删除，所以前端传过来的应该是一个 id 字符串组成的 list 集合，需要用 <strong>@RequestBody @ApiParam(value &#x3D; “ids”,required &#x3D; true) String[] ids</strong> 接收。</li>
</ul>
<h3 id="1-2-2-故障记录和故障维修记录——增删改查操作"><a href="#1-2-2-故障记录和故障维修记录——增删改查操作" class="headerlink" title="1.2.2 故障记录和故障维修记录——增删改查操作"></a>1.2.2 故障记录和故障维修记录——增删改查操作</h3><p><strong>这两个模块主要是记录了之前巡检发电站检查出来的故障，以及对应的故障维修记录。这里要注意的是：一条故障记录可能对应多条故障维修记录。</strong><br>常规的增删改查操作，就不详细记录了。</p>
<h3 id="运维后发电对比"><a href="#运维后发电对比" class="headerlink" title="运维后发电对比"></a>运维后发电对比</h3><p><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/6.png" alt="image.png"></p>
<h3 id="运维结算"><a href="#运维结算" class="headerlink" title="运维结算"></a>运维结算</h3><p><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/7.png" alt="image.png"><br><strong>在“查看详情” 功能接口中，涉及到一个分页查询</strong>，如下图：<br><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/8.png" alt="image.png"><br>一开始没看到是一个分页查询，就直接给前端返回了一个运维记录列表 result，后面发现需要返回一个分页类型 Page 类，于是我<strong>采用 stream 流将 result 集合转化成Page 类需要的集合，以进行分页操作</strong>，具体如下面这条代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;OperationRecordRes&gt; resultList = result.stream()</span><br><span class="line">.skip((pageReq.getCurrent() - <span class="number">1</span>) * pageReq.getSize())</span><br><span class="line">.limit(pageReq.getSize())</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>**skip((pageReq.getCurrent() - 1) * pageReq.getSize())**：这部分代码调用了 <strong>skip()</strong> 方法，它的作用是跳过指定数量的元素。在这里，我们要跳过的元素数量是 <strong>(当前页数 - 1) * 每页大小</strong>。这样就实现了将流中的元素移动到当前页的起始位置。</li>
<li>限制从流中获取的元素数量，确保不超过每页的大小。</li>
<li>使用 <strong>collect()</strong> 方法，将处理后的元素收集到一个新的列表中，并返回该列表作为结果。</li>
</ul>
<p><strong>${}和#{}的使用区别：</strong></p>
<p>一般来说为了保证 sql 注入安全，通常占位符会使用#{}。<br><strong>在 xml 文件中写 sql 语句的时候，使用 order by #{}，无法按照预期的顺序，后换成${}即可。</strong>网上查询原因得知：**#{}会将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号**，而 order by 后的字段不能加双引号，否则会失效。 </p>
<h2 id="项目复盘及收获（⭐）"><a href="#项目复盘及收获（⭐）" class="headerlink" title="项目复盘及收获（⭐）"></a>项目复盘及收获（⭐）</h2><p><strong>项目介绍：</strong></p>
<p>本项目是一个b端项目，主要是为用户提供一套关于<strong>光伏项目的解决方案</strong>，后端主要是用 Java 实现的一个<strong>新能源信息化管理系统</strong>，主要管理的就是这些光伏项目。<br>解释一下<strong>光伏</strong>：<br>光伏项目分为两种：<strong>户用光伏</strong>和<strong>工商业光伏</strong>，</p>
<blockquote>
<ul>
<li><strong>户用光伏</strong> ：所谓户用光伏就是安装在居民房子上的光伏，将光伏板安装在老百姓的屋顶上（以农村居民屋顶为主），安装完成之后，电站可以并入国家电网，发的电一部分优先供给家里用，用不完的可以出售给国家电网。</li>
<li><strong>工商业光伏</strong>： 工商业光伏更多的是将光伏板放在工商业厂房、仓库上面。工商业分布式光伏主要是利用工商企业屋顶，采用多样化的分布式光伏方案，将太阳能转为电能，从而实现电量的自发自用。</li>
</ul>
</blockquote>
<p>整个管理系统大致分为三个大模块：<strong>项目管理、数据展示、系统配置</strong>。<br><strong>① 项目管理模块是该项目的主要模块，主要是跟光伏项目相关的一些功能接口，比如：</strong></p>
<p>两种光伏项目分别对应<strong>前期阶段</strong>和<strong>建设期阶段</strong>，一个项目只能对应一个阶段，并且只能从前期阶段转为建设期阶段，不能反向转换。</p>
<blockquote>
<ul>
<li><strong>光伏前期阶段：</strong> 表中包括：<strong>项目名称</strong>、<strong>项目编号</strong>、<strong>项目经理</strong>、<strong>所在区域</strong>、<strong>预计投资额</strong> 、<strong>项目计划</strong>（嵌套了一张表,包含项目的各个节点，以及计划开始时间、计划结束时间、实际开始时间、实际结束时间……）等字段。</li>
<li><strong>光伏建设期阶段：</strong> 表中包括：开工日期、竣工日期、建设进度（包括好几个进度字段，前端是下拉框的形式，因此这些字段是由一个字典表维护的）等字段。</li>
</ul>
</blockquote>
<p>除了俩个阶段之外还有很多其他的功能，比如<strong>故障管理</strong>和<strong>维修管理</strong>等功能，比如<strong>维修管理</strong>又包括<strong>维修计划</strong>和<strong>维修记录</strong>，应该是先有计划，再有记录，添加记录时需要关联计划，并且一条计划是对应多条记录的，这些都是业务上需要理解的。当时这里就由于业务理解不深刻犯了些错误（扯“删除计划时需要判断有无相关联的记录”的事情）。</p>
<p><strong>② 数据展示模块主要是将数据信息以可视化的形式展示出来，比如电站的发电量数据、售电数据等。</strong><br><strong>③ 系统配置就是一些边角料的一些功能，比如角色管理、用户管理、用户权限管理啊等等…</strong></p>
<p><strong>我主要负责项目管理这个模块，给项目添加一些新功能、新接口，并维护一些老功能</strong>。功能主要包括：<strong>常规的增删改查、导入导出数据文件excel 、导入模板的下载  等等…</strong></p>
<p><strong>开发过程中遇到的一些典型错误：</strong></p>
<ul>
<li><p><strong>深浅拷贝问题：</strong></p>
<ul>
<li>导出 excel 数据的时候，每一个工商业光伏项目对应 m 个项目计划，有 n 个工商业光伏项目记录的话，一共就需要导出 n<em>m 条 excel 记录，所以代码逻辑是需要两层 for 循环的。<strong>最终我需要的是一个 list 集合，里边是一连串的 excelDto 实体类型的对象</strong>，<strong>这个 dto 的字段就是需要导出的数据字段，最后将 list 集合导出即可。</strong>在第一层 for 循环结尾需要将当前的工商业光伏项目拷贝一份，保存副本，防止后面被污染，这里存副本的时候，我是用的直接赋值的方式，这种方式属于<strong>浅拷贝</strong>，<strong>拷贝的只是对象的内存地址，相当于栈中的两个引用指向了堆中的同一个对象</strong>，后面修改的时候就会对原始副本对象造成污染。后续我采用<strong>深拷贝</strong>的方式：mapperFacade.map 拷贝了原始副本，*<em>深拷贝的两个引用对应的就是堆中的两个不同的对象了，只是数据一样而已。</em></em></li>
</ul>
</li>
<li><p><strong>#{} 和 ${} 的区别：</strong></p>
<ul>
<li>**一般来说为了保证 sql 注入安全，通常占位符会使用#{}。在 xml 文件中写 sql 语句的时候，使用 order by #{}，无法按照预期的顺序排列，后换成${}即可。网上查询原因得知：#{}会将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号，而 order by 后的字段不能加双引号，否则会失效。 **</li>
</ul>
</li>
<li><p><strong>使用 mybatisplus 的 getOne 查询报错问题：</strong></p>
<ul>
<li>使用 getOne 查询数据的时候，如果符合条件的数据有多条，就会报 Expected one result (or null) to be returned by selectOne(), but found: 2 的错误。</li>
<li>出现这个错误的原因主要是：一般情况下项目和发电站是<strong>一对一</strong>的，但是由于某些原因数据库中出现了<strong>一对多</strong>的情况，此时你使用 getOne 来查询就会出现多条数据。 <strong>解决办法：在 getOne 语句最后加一条“.last(limit 1)”，这样就只会取出最新的那条数据了。</strong></li>
</ul>
</li>
<li><p><strong>空指针问题：</strong></p>
<ul>
<li><strong>注意判空。 事前需要基于对业务的理解，这样才知道哪些字段可能为空，哪些字段不可能为空；事后利用 dubug 调试，哪些字段出现了空指针的问题。</strong></li>
</ul>
</li>
</ul>
<p><strong>将可以复用的代码封装起来：</strong><br><strong>通过用户输入的地址信息转换成对应的邮政编码，如中国-福建省-泉州市-晋江市转换为 350582。</strong></p>
<h1 id="户用光伏智能设计项目"><a href="#户用光伏智能设计项目" class="headerlink" title="户用光伏智能设计项目"></a>户用光伏智能设计项目</h1><p>这个项目是公司刚接的新项目，我相当于是从头跟着做的。</p>
<h2 id="基础库建设模块"><a href="#基础库建设模块" class="headerlink" title="基础库建设模块"></a>基础库建设模块</h2><p>“基础库建设”模块较为特殊，该模块其实就是一张表，这张表包含 4 个一级目录，7 个二级目录，这些目录分别对应一个子表，这些子表的结构都不太一样，如图：</p>
<p><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/9.png" alt="image.png"></p>
<p>整个大表可以看做是一颗树，因此我建立了一个总表<strong>basic_classification</strong>来维护所有子目录以及它们之间的层级关系，如图：</p>
<p><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/10.png" alt="image.png"></p>
<p><strong>跟前端沟通之后，需要提前将所有子表的中文字段返回给前端，以供他进行展示</strong>。这是因为这整张大表是只对应一个接口的，而这些小表是没有对应的接口的，相当于一个异步展示的过程，所以在访问大表之后，就需要提前将所有需要展示的中文字段返回给前端。 这里我在总表中添加了一个非数据库字段：List<ChineseDim> chineseDim,该字段是一个ChineseDim 泛型的集合，每一个ChineseDim 对象都对应一个子表的字段信息，ChineseDim 对象的字段包括：<br><img src="/2024/08/07/%E6%B0%B8%E7%A6%8F%E5%AE%9E%E4%B9%A0/11.png" alt="image.png"></ChineseDim></p>
<ul>
<li><strong>关键字段：</strong><ul>
<li><strong>classification_id：</strong> 对应该子表的 id。</li>
<li><strong>name：</strong> 该表的中文字段名。</li>
<li><strong>type：</strong> 该字段的类型。（前端需要根据它判断需要输入数据的类型）</li>
<li><strong>sort：</strong> 排序字段，根据这个决定页面展示各个中文字段的顺序。</li>
</ul>
</li>
</ul>
<p>当用户访问”基础库建设”模块时，后端会查询总表，返回一个 list 集合，该集合记录了所有子目录的信息，也包括这些目录的中文字段信息。（即刚刚添加的非数据库字段），接着会调用本地的 getTree 方法将集合转换成树结构，供前端显示。</p>
<p>剩下的子表开发就比较简单了，每个子表建立相对应的数据库表，使用 mybatis-plus 提供的代码生成器生成对应的 controller、service、mapper 以及对应的实体类 Entity，再编写相应的 crud 代码即可。</p>
]]></content>
      <categories>
        <category>实习</category>
        <category>永福</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2024/08/06/Kafka/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Kafka的基本概念"><a href="#Kafka的基本概念" class="headerlink" title="Kafka的基本概念"></a>Kafka的基本概念</h1><p>Kafka是一个<strong>基于 Zookeeper 的分布式消息流平台</strong>，也是一款开源的<strong>基于发布订阅模式的消息引擎系统</strong>。</p>
<p>Kafka 的消息队列一般分为两种模式：<strong>点对点模式</strong>和<strong>发布订阅模式</strong>。</p>
<p><img src="/2024/08/06/Kafka/1.png"></p>
<p>如果一个生产者或者多个生产者产生的消息能够被多个消费者同时消费的情况，这样的消息队列成为发布订阅模式的消息队列。</p>
<p><img src="/2024/08/06/Kafka/2.jpg"></p>
<p><strong>Kafka 的系统架构图</strong></p>
<p><img src="/2024/08/06/Kafka/3.jpg"></p>
<p><strong>Kafka 的基本术语</strong></p>
<ul>
<li><strong>消息</strong>：Kafka 中的数据单元被称为<strong>消息</strong>，也被称为记录，可以把它看作数据库表中某一行的记录。</li>
<li><strong>批次</strong>：为了提高效率， 消息会<strong>分批次</strong>写入 Kafka，批次就代指的是一组消息。</li>
<li><strong>主题</strong>：消息的种类称为 <strong>主题</strong>（Topic）,可以说一个主题代表了一类消息，相当于是对消息进行分类。</li>
<li><strong>分区</strong>：主题可以被分为若干个分区（partition），同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的<strong>伸缩性</strong>。</li>
<li><strong>生产者</strong>：向主题发布消息的客户端应用程序称为<strong>生产者</strong>（Producer），生产者用于持续不断的向某个主题发送消息。</li>
<li><strong>消费者</strong>：订阅主题消息的客户端程序称为<strong>消费者</strong>（Consumer），消费者用于处理生产者产生的消息。</li>
<li><strong>消费者群组</strong>：生产者与消费者的关系就如同餐厅中的厨师和顾客之间的关系一样，一个厨师对应多个顾客，也就是一个生产者对应多个消费者，<strong>消费者群组</strong>（Consumer Group）指的就是由一个或多个消费者组成的群体。</li>
<li><strong>偏移量</strong>：<strong>偏移量</strong>（Consumer Offset）是一种元数据，它是一个不断递增的整数值，用来记录消费者发生重平衡时的位置，以便用来恢复数据。</li>
<li><strong>broker:</strong> 一个独立的 Kafka 服务器就被称为 <strong>broker</strong>，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。</li>
<li><strong>broker 集群</strong>：broker 是<strong>集群</strong> 的组成部分，broker 集群由一个或多个 broker 组成，每个集群都有一个 broker 同时充当了<strong>集群控制器</strong>的角色（自动从集群的活跃成员中选举出来）。</li>
<li><strong>副本</strong>：Kafka 中消息的备份又叫做 副本（Replica），副本的数量是可以配置的，Kafka 定义了两类副本：领导者副本（Leader Replica） 和 追随者副本（Follower Replica），前者对外提供服务，后者只是被动跟随。</li>
<li><strong>重平衡</strong>：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li>
</ul>
<p><strong>Kafka 的特性</strong></p>
<ul>
<li><strong>高吞吐、低延迟</strong>：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。</li>
<li><strong>高伸缩性</strong>：每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</li>
<li><strong>持久性、可靠性</strong>：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持<strong>数据备份</strong>防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。</li>
<li><strong>容错性</strong>：允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作。</li>
<li><strong>高并发</strong>：支持数千个客户端同时读写。</li>
</ul>
<h2 id="Kafka-的优缺点："><a href="#Kafka-的优缺点：" class="headerlink" title="Kafka 的优缺点："></a>Kafka 的优缺点：</h2><p><strong>优点：</strong></p>
<ul>
<li><strong>异步：</strong><ul>
<li>某些非必要的业务逻辑以<strong>同步</strong>的方式运行，将耗费大量时间。<strong>在使用消息队列后，将发送的消息写入消息队列，非必要的业务逻辑以异步的方式运行，这样总耗时就只有发送消息和响应消息的时间了，大大提升了响应给用户的速度。</strong></li>
</ul>
</li>
<li><strong>解耦：</strong><ul>
<li>在未使用消息队列的系统中，系统间耦合性太强，上游系统需要考虑下游系统的消息可靠性问题。<strong>在使用消息队列后，将下游需要的消息push到消息队列中，需要消息的系统自己从消息队列中订阅；如果某个系统不需要这条数据了，就取消对 MQ 消息的订阅即可，上游系统不需要做任何修改，也不需要考虑下游消费失败的情况。</strong></li>
</ul>
</li>
<li><strong>削峰：</strong><ul>
<li>在未使用消息队列的系统中，系统面对突发大流量会导致系统崩溃。<strong>在使用消息队列后，下游系统按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在大多数生产系统的业务场景中，短暂的高峰期的消息积压是允许的。这样就可以用有限的机器资源承载高并发请求。</strong></li>
</ul>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>系统可用性降低：</strong><ul>
<li>系统每增加一个组件，必然导致可用性降低（中间件宕机会导致整个系统的崩溃）。Kafka 通过 <strong>broker 集群 + replica 副本机制</strong> 保证可用性。</li>
</ul>
</li>
<li><strong>系统复杂性增加：</strong><ul>
<li>保证消息的可靠传输。（消息不丢失）</li>
<li>保证消息的幂等性。（不被重复消费）</li>
<li>保证消息消费的顺序性。</li>
</ul>
</li>
</ul>
<h1 id="Kafka是如何保证消息不丢失的？（Kafka-如何保证消息的可靠传输？）"><a href="#Kafka是如何保证消息不丢失的？（Kafka-如何保证消息的可靠传输？）" class="headerlink" title="Kafka是如何保证消息不丢失的？（Kafka 如何保证消息的可靠传输？）"></a>Kafka是如何保证消息不丢失的？（Kafka 如何保证消息的可靠传输？）</h1><p>一条消息从产生，到发送到kafka保存，到被取出消费，有三个阶段可能会出现丢失的情况，即生产者端、broker端、消费者端。 下面分别概述解决办法：</p>
<p><strong>生产者端丢失数据：</strong><br>为了提高效率，生产者发送消息到 Kafka 的时候，通常采用<strong>异步发送</strong>的方式，即发送完了之后会立即返回不会阻塞，但此时并不能保证消息一定发送成功了，有可能出现消息丢失的问题。</p>
<p><strong>解决办法：使用重载的 send 方法。</strong><br>普通的 send 方法可以将消息发送出去，但是对发送出去的消息没有掌控能力，无法得知消息是否到达了 Kafka，是一种不可靠的发送方式。<br>而重载的 send 方法，其里面有一个参数为回调函数 callback，有了这个回调函数，一旦出现消息提交失败等异常情况，就可以有针对性地进行处理，如进行消息的重发等。</p>
<p><strong>broker端丢失数据：</strong><br>数据发送到消息队列之后，由于 broker 端出的问题导致消息丢失。</p>
<p><strong>解决办法：发送确认机制 acks。</strong><br>broker 端有三种确认机制，如下图：</p>
<p><img src="/2024/08/06/Kafka/4.png" alt="image.png"></p>
<p>通常情况下默认采用 acks&#x3D;1 的机制，只要 leader 接收到数据，就会给发送端返回确认消息。只有在 leader 接收到数据之后，还没来得及同步给 follower 就挂掉了才会导致数据的丢失，但是这种情况概率极小，无特殊场景下一般采用这种机制。</p>
<p><strong>消费者端丢失数据：</strong><br>消费者端是通过 offset 偏移量来对消息进行消费的，默认是每隔 5 秒钟自动提交已经消费的偏移量 offset，如果消费端在消费消息的过程中挂掉了，而这条消息被自动提交了，那么就相当于丢了一条消息。</p>
<p><strong>解决办法：关闭自动提交 offset 机制。</strong><br>让消费端在处理完消息之后手动提交 offset，这样就可以保证消息不丢失了。</p>
<p>但是此时还可能会出现<strong>重复消费</strong>的问题，比如说刚处理完这条消息，在提交 offset 的前一瞬间挂掉了，那么下次这条消息还会被再消费一次，这里就设计到<strong>保证幂等性</strong>的问题了，不再赘述。</p>
<h1 id="Kafka-如何保证消费的顺序性？"><a href="#Kafka-如何保证消费的顺序性？" class="headerlink" title="Kafka 如何保证消费的顺序性？"></a>Kafka 如何保证消费的顺序性？</h1><p><strong>造成 Kafka 消息无序的原因</strong></p>
<p>Kafka 的设计目标是提供<strong>高吞吐量和低延迟</strong>，而不是强制保证全局有序性，所以Kafka使用多分区的概念，并且<strong>只保证单分区有序</strong>（offset）。</p>
<p><strong>解决办法</strong></p>
<ul>
<li><strong>单分区策略</strong>：一个 topic 只有一个 partition，但是这样子做毫无并发度可言，失去了 Kafka 的意义。</li>
<li><strong>基于 key 的消息分配策略</strong>：生产者在发送消息时，指定分区号或者根据业务设置相同的 key（Kafka 默认按照 key 的 hashcode 值寻找分区）。</li>
</ul>
<h1 id="Kafka-的高可用性如何保证？"><a href="#Kafka-的高可用性如何保证？" class="headerlink" title="Kafka 的高可用性如何保证？"></a>Kafka 的高可用性如何保证？</h1><p>由 <strong>broker 集群 + replica 副本机制</strong> 保证</p>
<p>对<strong>Kafka 的整体架构</strong>的基本认识：一个 Kafka 集群由多个 broker 实例组成，每个 broker 实例中有不同的 topic，每个 topic 又划分为多个 partition，这些 partition 可以存在于不同的 broker 中。这就是一个天然的分布式消息队列，也就是说<strong>一个 topic 的数据是分散在多个机器上的</strong>。</p>
<p>如果某一个 broker 节点宕机了，那么这上面的 partition 就相当于消失了。</p>
<p>Kafka 为了保证高可用性，提供了 <strong>replica 副本机制</strong>，每个 partition 的数据都会同步到不同的 broker 中，形成数据的多个 replica 副本。这些 replica 副本会选举一个 leader，其余的为 follower，消息的生产和消费都和 leader 打交道。 如果 leader 节点宕机的话，会通过选举策略选举一个新的 leader。</p>
<ul>
<li>生产数据的时候，leader 会将数据同步给 follower，并通过<strong>acks 确认机制</strong>返回给生产者。（acks 可以取 0、1、all 分别代表不同的确认机制，具体可以看上面） </li>
<li>消费数据的时候，也只会从 leader 那里取数据。（如果可以从 follower 那里取还需要保证一致性，非常麻烦）</li>
</ul>
<p>follower 副本分为两类：</p>
<ul>
<li><strong>ISR（in-sync-replica）副本</strong>：该副本是通过同步复制的方式与 leader 交互的，一致性更高。</li>
<li><strong>普通副本</strong>：该副本通过异步复制的方式与 leader 进行交互，一致性一般。</li>
</ul>
<p>因此，当 leader 挂掉之后，<strong>优先从一致性高的 ISR 副本中选举中 leader</strong>。</p>
<h1 id="Kafka-的数据清理机制"><a href="#Kafka-的数据清理机制" class="headerlink" title="Kafka 的数据清理机制"></a>Kafka 的数据清理机制</h1><ul>
<li>根据消息的保留时间，当消息保存的时间超过指定的时间，就会触发清理，默认为 7 天。<ul>
<li>log.retention.hours &#x3D; 168</li>
</ul>
</li>
<li>根据 topic 存储的数据大小，当 topic 所占的日志文件大小大于一定的阈值，则删除最久的消息。（默认关闭，需手动开启参数）</li>
</ul>
<h1 id="Kafka-的高性能如何保证？"><a href="#Kafka-的高性能如何保证？" class="headerlink" title="Kafka 的高性能如何保证？"></a>Kafka 的高性能如何保证？</h1><p><strong>先介绍一下 Kafka 的整体架构，然后可以扯出前两点：</strong></p>
<h2 id="broker-集群"><a href="#broker-集群" class="headerlink" title="broker 集群"></a>broker 集群</h2><p>Kafka 中的 broker 集群使消息分散在多台服务器中，每个 topic 的 partition 分布在不同的 broker 中，系统的吞吐量高。</p>
<h2 id="磁盘的顺序读写"><a href="#磁盘的顺序读写" class="headerlink" title="磁盘的顺序读写"></a>磁盘的顺序读写</h2><p>在 Kafka 中，一个 topic 对应多个 partition，每个 partition 又有多个 replica 副本，每个副本都对用一个 log 日志文件，这个日志文件被切分为多个子日志文件，这些子日志文件对应着磁盘上的日志文件、两个索引文件以及其他文件。如图：</p>
<p><img src="/2024/08/06/Kafka/5.png" alt="image.png"></p>
<p>在 log 中追加消息是<strong>顺序写入</strong>的，<strong>因此磁盘的读写为顺序读写，效率比随机读写高得多</strong>。</p>
<h2 id="页缓存技术"><a href="#页缓存技术" class="headerlink" title="页缓存技术"></a>页缓存技术</h2><p>在读取磁盘数据的时候，会在内存设置一段页缓存区域，从而避免了对物理磁盘的I&#x2F;O操作。如果页缓存区域没有命中数据，则会去磁盘里查找数据并将数据存入页缓存当中。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>Kafka中存在大量的网络数据持久化到磁盘（Producer到Broker）和磁盘文件通过网络发送（Broker到Consumer）的过程。这一过程的性能直接影响Kafka的整体吞吐量。</p>
<p>在传统模式下，<strong>将磁盘文件通过网络发送</strong>需要先将文件数据读入内存，然后通过Socket将内存中的数据发送出去。 这一过程需要<strong>四次拷贝和四次上下文切换</strong>。<br>Linux 2.4+内核通过<strong>sendfile</strong>系统调用，提供了零拷贝（CPU 拷贝）。只有两次上下文切换，大大提高了性能。</p>
<h2 id="分批发送"><a href="#分批发送" class="headerlink" title="分批发送"></a>分批发送</h2><p>生产者发送消息时支持批量发送消息，将多条消息积累到一个批次中，然后一次性发送给Kafka Broker，这样可以减少网络I&#x2F;O次数，显著提升吞吐量。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>java8新特性</title>
    <url>/2024/08/06/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑，Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。<br>过去给方法传动态参数的唯一方法是使用<strong>内部类</strong>。比如：</p>
<p><strong>runnable 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The runable now is using!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//用lambda</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>comparator 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; strings = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(strings, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o1 - o2;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda</span></span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);</span><br><span class="line"><span class="comment">//分解开</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (Integer o1, Integer o2) -&gt; o1 - o2;</span><br><span class="line">Collections.sort(strings, comparator);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h1><p>java 新增了<strong>java.util.stream</strong>包，它和之前的流大同小异。之前接触最多的是资源流，比如java.io.FileInputStream，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何_CRUD_。</p>
<p>Stream依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括<strong>筛选、排序、统计、计数</strong>等。可以想象成是 Sql 语句。</p>
<p><strong>Stream 流通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</strong></p>
<h2 id="流的并行处理"><a href="#流的并行处理" class="headerlink" title="流的并行处理"></a>流的并行处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">100_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;本计算机的核数：%d&quot;</span>, Runtime.getRuntime().availableProcessors()));</span><br><span class="line">        <span class="comment">// 产生1000w个随机数(1 ~ 100)，组成列表</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(total);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;total; i++)&#123;</span><br><span class="line">            list.add(random.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">prevTime</span> <span class="operator">=</span> getCurrentTime();</span><br><span class="line">        list.stream().reduce((a,b) -&gt; a+b).ifPresent(System.out::println);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;单线程计算耗时：%d&quot;</span>, getCurrentTime() - prevTime));</span><br><span class="line"></span><br><span class="line">        prevTime = getCurrentTime();</span><br><span class="line">        <span class="comment">// 只需要加上 .parallel() 就能多线程并行处理流</span></span><br><span class="line">        list.stream().parallel().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;多线程计算耗时：%d&quot;</span>, getCurrentTime() - prevTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getCurrentTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/2024/08/06/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1.png" alt="image.png"></p>
<h2 id="stream-流的使用"><a href="#stream-流的使用" class="headerlink" title="stream 流的使用"></a>stream 流的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java8新特性测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Jay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2024-05-13 20:32</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Wmyskxz&quot;</span>, <span class="string">&quot;Is&quot;</span>, <span class="string">&quot;myLearning&quot;</span>, <span class="string">&quot;Java8&quot;</span>, <span class="string">&quot;In&quot;</span>, <span class="string">&quot;Action&quot;</span>);</span><br><span class="line">        <span class="comment">//forEach遍历</span></span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Filter过滤</span></span><br><span class="line">        list.stream().filter(o -&gt; o.startsWith(<span class="string">&quot;I&quot;</span>)).forEach(System.out::println);</span><br><span class="line">        list.stream().filter(o -&gt; o.contains(<span class="string">&quot;my&quot;</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//map映射</span></span><br><span class="line">        list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//count计数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> list.stream().filter(o -&gt; o.startsWith(<span class="string">&quot;I&quot;</span>)).count();</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Reduce规约操作,将 stream 中的多个元素规约为一个元素</span></span><br><span class="line">        list.stream().reduce((o1,o2) -&gt; o1+<span class="string">&quot;---&quot;</span>+o2).ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/2024/08/06/Java8%E6%96%B0%E7%89%B9%E6%80%A7/2.png" alt="image.png"></p>
<h1 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h1><h2 id="java-util-Date-既包含日期又包含时间，而-java-time-把它们进行了分离"><a href="#java-util-Date-既包含日期又包含时间，而-java-time-把它们进行了分离" class="headerlink" title="java.util.Date 既包含日期又包含时间，而 java.time 把它们进行了分离"></a>java.util.Date 既包含日期又包含时间，而 java.time 把它们进行了分离</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java8关于时间的新特性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Jay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2024-05-13 20:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8_java_time</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">oldFormat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span>  <span class="operator">=</span> sdf.format(now);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//format HH:mm:ss</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdft.format(now);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdfdt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">datetime</span> <span class="operator">=</span> sdfdt.format(now);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, datetime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">newFormat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//format HH:mm:ss</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> dateTime.format(dateTimeFormatter);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        oldFormat();</span><br><span class="line">        newFormat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取指定日期"><a href="#获取指定日期" class="headerlink" title="获取指定日期"></a>获取指定日期</h2><p>Java8 之前获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。</p>
<p>Java8 之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getDayNew</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="comment">//获取当前月第一天：</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">firstDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;firstDayOfThisMonth : %s&quot;</span>, firstDayOfThisMonth));</span><br><span class="line">        <span class="comment">// 取本月最后一天</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">lastDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;lastDayOfThisMonth : %s&quot;</span>, lastDayOfThisMonth));</span><br><span class="line">        <span class="comment">//取下一天：</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">nextDay</span> <span class="operator">=</span> lastDayOfThisMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;nextDay : %s&quot;</span>, nextDay));</span><br><span class="line">        <span class="comment">//当年最后一天</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">lastday</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;lastday : %s&quot;</span>, lastday));</span><br><span class="line">        <span class="comment">//2024年最后一个周日，如果用Calendar是不得烦死。</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">lastMondayOf2024</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2024-12-31&quot;</span>).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;lastMondayOf2024 : %s&quot;</span>, lastMondayOf2024));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/2024/08/06/Java8%E6%96%B0%E7%89%B9%E6%80%A7/3.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2024/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种<strong>创建对象的最佳方式</strong>。它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。<br>单例设计模式分为两种：</p>
<ul>
<li><strong>饿汉式：</strong> 类加载就会导致该单实例对象被创建。</li>
<li><strong>懒汉式：</strong> 类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建。</li>
</ul>
<p><strong>饿汉式-方式1（静态变量方式）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> *      静态变量创建类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>饿汉式-方式2（静态代码块方式）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> *      在静态代码块中创建该类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>懒汉式-方式1（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>懒汉式-方式2（双重检查锁）</strong></p>
<p>对于 getInstance() 方法来说，<strong>绝大部分的操作都是读操作，读操作是线程安全的</strong>，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要<strong>调整加锁的时机</strong>。由此也产生了一种新的实现模式：双重检查锁模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检查锁模式是一种非常好的单例实现模式，<strong>解决了单例、性能、线程安全问题</strong>，上面的双重检测锁模式看上去完美无缺，其实是存在问题，<strong>在多线程的情况下，可能会出现空指针问题</strong>，出现问题的原因是JVM在实例化对象的时候会进行<strong>优化和指令重排序操作</strong>。</p>
<p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <strong>volatile <strong>关键字, <strong>volatile</strong> 关键字可以保证</strong>可见性和有序性</strong>。</p>
<blockquote>
<p>private static volatile Singleton instance;</p>
</blockquote>
<p><strong>枚举方式</strong><br>枚举类实现单例模式是极力推荐的单例实现模式，因为<strong>枚举类型是线程安全的，并且只会装载一次</strong>，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>
<p>枚举方式属于饿汉式方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式又叫做<strong>静态工厂方法模式</strong>，它是<strong>通过使用静态方法接收不同的参数来返回不同的实例对象</strong>。其只有唯一工厂（简单工厂），一个产品接口，根据简单工厂中的静态方法来创建具体产品对象。适用于产品较少，几乎不扩展的情景。<br><img src="/2024/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.png"><br><strong>代码实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**产品接口**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**具体产品实现**/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是ProductA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductC</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是ProductC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**简单工厂**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**工厂类创建产品静态方法**/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">createProduct</span><span class="params">(String productName)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (productName)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">ProductC</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**客户端(client)调用工厂类**/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleFactory</span> <span class="variable">simpleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleFactory</span>();</span><br><span class="line">        createProduct(<span class="string">&quot;A&quot;</span>).doSomething();</span><br><span class="line">        createProduct(<span class="string">&quot;B&quot;</span>).doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：封装了创建对象的过程，可以通过参数直接获取对象。对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码。</p>
<p><strong>缺点</strong>：违背<strong>开闭原则</strong>，如果需要新增其他产品类，就必须在工厂类中新增<strong>if-else</strong>逻辑判断。</p>
<p><strong>应用场景</strong>：比如在业务连接数据库时，需要支持不同的数据库，比如有dbcp、c3p0、druid等等，这个时候数据库连接方式有限，而且比较固定不容易更改，所以可以尝试采用简单工厂模式来进行管理数据库连接对象。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>有<strong>多个工厂（抽象工厂+多个具体工厂），一个产品接口&#x2F;抽象类</strong>，根据继承抽象工厂中的方法来多态创建具体产品对象，即<strong>每一个产品都对应一个工厂</strong>。适用于一个类型的多个产品。<br><img src="/2024/08/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png"><br><strong>代码实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**产品接口**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**具体产品实现**/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是ProductA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductC</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是ProductC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**工厂接口**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">	<span class="comment">/**创建Product方法,区别与工厂模式的静态方法**/</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**具体工厂实现**/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryC</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**客户端调用工厂**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">productA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>().createProduct();</span><br><span class="line">        productA.doSomething();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">productB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>().createProduct();</span><br><span class="line">        productB.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：完全实现开闭原则，实现了可扩展和更复杂的层次结构。明确了职责，具有多态性，适用于任何实体类。</li>
<li><strong>缺点</strong>：如果业务增加，会使得系统中类的个数成倍增加，提高了代码的复杂度。</li>
<li><strong>应用场景：</strong> 在 Slf4j 这个我们经常使用的日志框架中，就有工厂方法模式的应用，比如使用频率很高的获取logger对象实例中:<blockquote>
<p><strong>private Logger logger &#x3D; LoggerFactory.getLogger(Client.class);</strong></p>
</blockquote>
</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>有<strong>多个工厂（抽象工厂+多个具体工厂），多个产品接口&#x2F;抽象类</strong>，对产品子类进行分组，根据继承抽象工厂中的方法多态创建同组的不同具体产品对象。<strong>适用于多个类型的多个产品。</strong></p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**Product1类的产品接口**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product1A</span> <span class="keyword">implements</span> <span class="title class_">Product1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Product1A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product1B</span> <span class="keyword">implements</span> <span class="title class_">Product1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Product1B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Product2类的产品接口**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product2A</span> <span class="keyword">implements</span> <span class="title class_">Product1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Product2A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product2B</span> <span class="keyword">implements</span> <span class="title class_">Product1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Product2B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**抽象工厂接口**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">createProduct1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">createProduct2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**A类工厂**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">createProduct1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product1A</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">createProduct2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product2A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**B类工厂**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">createProduct1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product1B</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">createProduct2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product2B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**Client客户端调用**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FactoryA</span>().createProduct1().doSomething();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FactoryB</span>().createProduct2().doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：增加分组比较容易，而且能大大减少工厂类的数量</li>
<li><strong>缺点</strong>：因为分组，所以分组中的产品扩展就比较困难，比如再新增一个Product3，就需要改动AbstractFactory、FactoryA和FactoryB几乎所有工厂类。</li>
</ul>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p><strong>模板方法模式</strong>属于<strong>行为型模式</strong>，<strong>行为型模式</strong>用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p><strong>模板方法模式，</strong> 在一个抽象类公开定义了执行它的方法的模板，它的子类可以按需要重写方法实现。简单来说，<strong>模板方法模式就是定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</strong>，这种类型的设计模式属于行为型模式。</p>
<p>模板方法（Template Method）模式包含以下主要角色：</p>
<ul>
<li><strong>抽象类（Abstract Class）</strong>：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。<ul>
<li><strong>模板方法</strong>：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>
<li><strong>基本方法</strong>：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：<ul>
<li><strong>抽象方法</strong>(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</li>
<li><strong>具体方法</strong>(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</li>
<li><strong>钩子方法</strong>(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</li>
</ul>
</li>
</ul>
</li>
<li><strong>具体子类（Concrete Class）</strong>：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</li>
</ul>
<p><strong>代码实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        <span class="type">ConcreteClass_CaiXin</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_CaiXin</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li><strong>提高代码复用性：</strong> 将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</li>
<li><strong>实现了反向控制：</strong>通过一个父类调用其子类的操作，<strong>通过对子类的具体实现扩展不同的行为</strong>，实现了<strong>反向控制</strong> ，并符合“开闭原则”。</li>
</ul>
<p><strong>使用场景：</strong> 当要完成在某个过程，该过程要执行一系列步骤 ，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理。</p>
<p>如：AQS(AbstractQueuedSynchronizer)，抽象队列同步器 。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的<strong>ReentrantLock</strong>&#x2F;<strong>Semaphore</strong>&#x2F;<strong>CountDownLatch</strong>…</p>
<p>AQS是基于<strong>模板方法模式</strong>实现的，我们可以自定义同步器：</p>
<ul>
<li>继承AbstractQueuedSynchronizer抽象类，并重写对应的方法。</li>
<li>调用对应的模板方法，这些模板方法会调用我们重写的方法。</li>
</ul>
<p>重写的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不可重写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">     state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统常见面试题</title>
    <url>/2024/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul>
<li><strong>根本区别：</strong>进程是操作系统<strong>资源分配</strong>的基本单位，而线程是处理器<strong>任务调度和执行</strong>的基本单位。  </li>
<li><strong>资源开销</strong>：  <ul>
<li>每个进程都有独立的内存空间，进程间切换需要保存和恢复进程的状态，因此进程上下文切换的开销较大。  </li>
<li>线程间共享进程的内存空间，线程的上下文切换开销较小。</li>
</ul>
</li>
<li><strong>通信与同步</strong>：  <ul>
<li>由于进程间相互隔离，进程间的通信需要通过一些特殊机制，如<strong>管道、消息队列、信号量</strong>等。</li>
<li>由于线程共享进程的内存空间，因此它们可以直接访问共享数据，通信更方便。</li>
</ul>
</li>
<li><strong>安全性：</strong><ul>
<li>由于进程间相互隔离，一个进程的崩溃不会影响到其他进程的运行。</li>
<li>由于线程共享内存空间，一个线程的崩溃可能会影响到整个进程的运行。</li>
</ul>
</li>
</ul>
<h1 id="死锁是什么？如何解决？"><a href="#死锁是什么？如何解决？" class="headerlink" title="死锁是什么？如何解决？"></a>死锁是什么？如何解决？</h1><h2 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a><strong>死锁：</strong></h2><p>由于多个进程对资源进行抢夺，造成了这些进程同时阻塞，互相等待对方释放资源的这么一种僵局的状态。</p>
<h2 id="死锁产生的必要条件："><a href="#死锁产生的必要条件：" class="headerlink" title="死锁产生的必要条件："></a><strong>死锁产生的必要条件：</strong></h2><ul>
<li><strong>互斥条件：</strong> 多个线程不能同时使用同一个资源。</li>
<li><strong>持有并等待条件：</strong> 当前线程持有了资源A，想去申请资源B，而资源B已经被其他线程所持有，当前线程就会在持有资源A的状态下阻塞。</li>
<li><strong>不可剥夺条件：</strong> 线程持有的资源在使用完之前不会被其他线程所抢占。</li>
<li><strong>环路等待条件</strong>：两个线程获取资源的顺序构成了环形链。</li>
</ul>
<h2 id="死锁的预防："><a href="#死锁的预防：" class="headerlink" title="死锁的预防："></a><strong>死锁的预防：</strong></h2><ul>
<li><strong>破坏互斥条件：</strong> 将互斥资源改为共享资源。</li>
<li><strong>破坏持有并等待条件：</strong> 使进程在执行前一次性申请到所需的所有资源。</li>
<li><strong>破坏不可剥夺条件：</strong> 将获取资源的方式改为抢占式的。</li>
<li><strong>破坏循环等待条件：</strong> 使用资源有序分配法，规定进程获取资源的顺序以破坏死锁环路。</li>
</ul>
<h2 id="死锁的避免："><a href="#死锁的避免：" class="headerlink" title="死锁的避免："></a>死锁的避免：</h2><p>当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<h2 id="死锁的检测与解除："><a href="#死锁的检测与解除：" class="headerlink" title="死锁的检测与解除："></a>死锁的检测与解除：</h2><ul>
<li>Java可以使用jstack查看进程信息，jstack会在最后给出进程的分析信息。</li>
<li>使用图形化工具<strong>jconsole，</strong>用于对JVM中内存，线程和类等的监控，其下有<strong>检测死锁</strong>功能。</li>
</ul>
<p>通过死锁检测程序检测是否发生了死锁，若发生了死锁，应设法解除当前的死锁状态：</p>
<ul>
<li><strong>立即结束所有进程的执行，重新启动操作系统。</strong></li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
</ul>
<h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><ul>
<li><strong>管道：</strong>管道的实质是一个<strong>内核缓冲区</strong>，进程以<strong>先进先出</strong>的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据。<ul>
<li><strong>pipe匿名管道：</strong>用于<strong>具有亲缘关系的进程</strong>之间的通信，例如父进程和子进程，它通过pipe()系统调用来创建并打开。</li>
<li><strong>FIFO命名管道：</strong>命名管道的名字对应于一个<strong>磁盘索引节点</strong>，有了这个文件名，<strong>任何进程都有权限对它进行访问</strong>。Linux中通过系统调用makefifo()来创建一个命名管道。</li>
</ul>
</li>
</ul>
<p><strong>管道的通信效率较低，因此不适合进程间频繁地交换数据。</strong></p>
<ul>
<li><strong>消息队列：</strong><ul>
<li><strong>是保存在内核中的消息链表，</strong> 用户进程可以向消息队列添加消息，也可以向消息队列读取消息。 </li>
<li><strong>消息体</strong>是用户<strong>自定义</strong>的数据类型，与管道通信相比，其优势是不需要按照队列次序，可以根据自定义条件接收特定类型的消息。</li>
<li>消息队列的生命周期随内核，进程结束了也不会消失。</li>
</ul>
</li>
</ul>
<p><strong>消息队列不适合大数据的传输，因为在内核中每个消息体都有一个最大长度的限制。且消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。</strong></p>
<ul>
<li><strong>共享内存：</strong>各进程<strong>取出一块虚拟地址空间来，映射到相同的物理内存中，</strong>这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，大大<strong>提高进程间通信的速度</strong>。</li>
<li><strong>信号量：</strong>信号量其实是一个<strong>整型计数器</strong>，主要用于实现<strong>进程间的互斥与同步</strong>，解决共享内存产生的<strong>访问数据冲突</strong>问题。主要包括两种操作：等待（wait）和释放（signal）。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计网常见面试题</title>
    <url>/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="TCP-IP-网络模型"><a href="#TCP-IP-网络模型" class="headerlink" title="TCP&#x2F;IP 网络模型"></a>TCP&#x2F;IP 网络模型</h1><p>对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而<strong>对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备</strong>，就协商出了一套<strong>通用的网络协议</strong>。<br>TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层，网络接口层</strong>。<br><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/1.png"></p>
<p><strong>应用层</strong></p>
<p>应用层是不用去关心数据是如何传输的，只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。<strong>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</strong>。</p>
<p><strong>传输层:</strong></p>
<p><strong>传输层的作用在于为运行在不同主机上的应用进程之间提供逻辑通信</strong>（这里的逻辑通信指的是在传输层角度看来两个进程间直接进行通信，实际上还是通过下层提供的服务）。传输层有两个传输协议，分别是 TCP 和 UDP：</p>
<ul>
<li><strong>TCP</strong>：提供面向连接的，可靠的数据传输服务。</li>
<li><strong>UDP</strong>：提供无连接的，尽最大努力的数据传输（不保证数据传输的可靠性），简单高效。</li>
</ul>
<p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此<strong>当传输层的数据包大小超过 MSS（TCP 最大报文段长度），就要将数据包分块</strong> ，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 TCP 段。</p>
<p><strong>网络层:</strong></p>
<p>我们不希望传输层处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能交给网络层。</p>
<p>网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。</p>
<p>网络层将数据从一个设备传输到另一个设备，需要依赖<strong>IP地址</strong>和<strong>子网掩码</strong>进行寻址找到对应的子网，再去寻找对应的主机。  </p>
<p><strong>除了寻址能力， IP 协议还有另一个重要的能力就是路由。</strong> 实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p>
<p><strong>网络接口层:</strong></p>
<p><strong>负责将数据转换为数字信号在物理设备之间传输</strong>。在生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p>
<p><strong>四个层的封装格式如下图：</strong><br><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/2.png"><br>网络接口层的传输单位是<strong>帧</strong>（frame），IP 层的传输单位是<strong>包</strong>（packet），TCP 层的传输单位是<strong>段</strong>（segment），HTTP 的传输单位则是<strong>消息或报文</strong>（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>
<h1 id="从输入-URL-到页面展示到底发生了什么？（⭐）"><a href="#从输入-URL-到页面展示到底发生了什么？（⭐）" class="headerlink" title="从输入 URL 到页面展示到底发生了什么？（⭐）"></a>从输入 URL 到页面展示到底发生了什么？（⭐）</h1><ul>
<li><strong>检查缓存</strong>：浏览器接收到⽤户请求，先检查浏览器缓存是否有缓存该资源，如果有直接返回。</li>
<li><strong>DNS解析</strong>：发送到DNS(域名服务器)获得域名对应的WEB服务器的IP地址。<strong>（扯一下域名解析过程）</strong></li>
<li><strong>TCP连接</strong>：客户端浏览器与WEB服务器建立TCP连接。<strong>（扯一下三次握手）</strong></li>
<li><strong>发送HTTP请求</strong>：客户端浏览器向目标WEB服务器发送相应的HTTP或HTTPS请求。<strong>（扯下HTTP和HTTPS）</strong></li>
<li><strong>服务器处理请求并返回 HTTP 报文</strong>：WEB服务器响应请求，返回指定的URL数据或错误信息；如果设定重定向，则重定向到新的URL地址。</li>
<li><strong>浏览器解析渲染页面</strong>：客户端浏览器下载数据，解析HTML源文件，在页面中进行显示。</li>
<li><strong>连接结束</strong>：断开TCP连接。</li>
</ul>
<h1 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h1><h2 id="HTTP是什么？"><a href="#HTTP是什么？" class="headerlink" title="HTTP是什么？"></a>HTTP是什么？</h2><p><strong>HTTP 是在互联网中约束两设备之间传输超文本数据的 约定 和 规范。</strong></p>
<h2 id="HTTP-常见的状态码："><a href="#HTTP-常见的状态码：" class="headerlink" title="HTTP 常见的状态码："></a>HTTP 常见的状态码：</h2><p><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/3.png"></p>
<ul>
<li>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</li>
<li>2xx 类状态码表示服务器成功处理了客户端的请求，常见的有：<ul>
<li>「200 OK」是最常见的成功状态码，表示一切正常。</li>
<li>「204 No Content」也是常见的成功状态码，但响应头没有 body 数据。</li>
</ul>
</li>
<li>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向，常见的有：<ul>
<li>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「302 Found」即临时重定向，请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
<li>「304 Not Modified」缓存重定向，告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
</li>
<li>4xx 类状态码表示客户端发送的报文有误，服务器无法处理。常见的有：<ul>
<li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「404 Not Found」表示请求的资源在服务器上不存在，所以无法提供给客户端。</li>
</ul>
</li>
<li>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，常见的有：<ul>
<li>「500 Internal Server Error」与 400 类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
</li>
</ul>
<h2 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h2><ul>
<li><strong>Host</strong>：客户端发送请求时，用来指定服务器的域名。</li>
<li><strong>Content-Length</strong> ：表明服务器返回数据的数据长度。</li>
<li><strong>Connection</strong> ：常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</li>
<li><strong>Content-Encoding</strong> ：说明数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。</li>
</ul>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><ul>
<li><strong>请求行，</strong> 包括以下内容：<ul>
<li>请求方法：如get、post。</li>
<li>请求路径：url</li>
<li>版本号</li>
</ul>
</li>
<li><strong>请求头</strong>：包含一些字段(见3.3)，服务端据此获取客户端的信息。</li>
<li><strong>请求体</strong>：传递请求参数。</li>
</ul>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><ul>
<li><strong>响应行</strong>：<ul>
<li>版本信息</li>
<li>状态码及描述</li>
</ul>
</li>
<li><strong>响应头</strong>：一些字段，包含服务器的一些基本信息。</li>
<li><strong>响应体</strong>：返回的数据。</li>
</ul>
<h1 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h1><ul>
<li><strong>语义（主要区别）</strong>：GET 通常用于获取或查询资源；而 POST 通常用于创建或修改资源。</li>
<li><strong>幂等</strong>：GET 请求是幂等的，即多次重复执行不会改变资源的状态；而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li>
<li><strong>格式</strong>：GET 请求的参数通常放在 URL 中，形成查询字符串；POST 请求的参数通常放在请求体（body）中。</li>
<li><strong>缓存</strong>：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点缓存起来，以提高性能； POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li>
</ul>
<h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><p>对于一些具有重复性的 HTTP 请求，可以把这些 <strong>「请求-响应」</strong> 的数据都<strong>缓存在本地，提高访问速度</strong>，降低服务器压力。</p>
<p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。  当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，其设置了过期时间大小。当浏览器再次请求访问服务器中的该资源时，会先根据Cache-Control 中设置的过期时间，来判断该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器。</p>
<ul>
<li><strong>强制缓存</strong>：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，无需向服务器发送请求。</li>
<li><strong>协商缓存</strong>：向服务器发送请求，服务器会根据请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并通知浏览器从缓存中读取资源。</li>
</ul>
<h1 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h1><h2 id="HTTP-与-HTTPS-的区别："><a href="#HTTP-与-HTTPS-的区别：" class="headerlink" title="HTTP 与 HTTPS 的区别："></a>HTTP 与 HTTPS 的区别：</h2><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
</ul>
<h2 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h2><ul>
<li><strong>混合加密的方式实现信息的机密性</strong>，解决了窃听的风险。<ul>
<li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li>
<li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续不再使用非对称加密。</li>
</ul>
</li>
<li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的标识，用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。<blockquote>
<p><strong>对称加密：</strong> 只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>非对称加密：</strong> 用公钥和私钥，公钥可任意分发，私钥保密，解决了密钥交换问题但速度慢。</p>
</blockquote>
<h2 id="HTTPS-是如何建立连接的？"><a href="#HTTPS-是如何建立连接的？" class="headerlink" title="HTTPS 是如何建立连接的？"></a>HTTPS 是如何建立连接的？</h2><ul>
<li><strong>客户端向服务器索要并验证服务器的公钥。</strong></li>
<li><strong>双方协商生产「会话秘钥」。</strong></li>
<li><strong>双方采用「会话秘钥」进行加密通信。</strong></li>
</ul>
<h2 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h2><ul>
<li>使用<strong>长连接</strong>的方式改善了 HTTP&#x2F;1.0 <strong>短连接</strong>造成的性能开销。</li>
<li>支持<strong>管道</strong>（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul>
<h2 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h2><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<ul>
<li><strong>头部压缩</strong>：如果同时发送多个请求，且头部是一样的，那协议会自动进行压缩。</li>
<li><strong>二进制格式</strong>：不再像 HTTP&#x2F;1.1 采用纯文本格式，头信息和数据体都是二进制且统称为帧。</li>
<li><strong>并发传输</strong>：引入了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</li>
<li><strong>服务器推送</strong>：客户端和服务器双方都可以建立 Stream，减少消息传递次数。</li>
</ul>
<h2 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h2><p>HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p>
<ul>
<li>HTTP&#x2F;1.1属于 HTTP 层队头阻塞。</li>
<li>HTTP&#x2F;2 属于 TCP 层队头阻塞。</li>
</ul>
<p>所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<h2 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h2><p> 通过<strong>session</strong>和<strong>cookie</strong>机制协同保存用户的状态。Session的作用就是通过服务端记录用户的状态，<strong>当用户进行操作时，服务端给该用户创建特定的 Session 之后就可以标识这个用户</strong>并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。最后通过在 Cookie 中附加一个 Session ID 来方式来跟踪这个Session。</p>
<p><strong>使用 Session 维护用户登录状态的过程如下：</strong></p>
<ol>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ol>
<p>如果cookie被禁用的话，可以利用 <strong>URL 重写</strong>把 Session ID 直接附加在 URL 路径的后面。</p>
<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><h2 id="什么是-WebSocket"><a href="#什么是-WebSocket" class="headerlink" title="什么是 WebSocket?"></a>什么是 WebSocket?</h2><p><strong>WebSocket</strong> 是一种基于 TCP 连接的<strong>全双工</strong>通信协议，即客户端和服务器可以同时发送和接收数据。其本质上是<strong>应用层</strong>的协议，<strong>用于弥补 HTTP 协议在持久通信能力上的不足</strong>。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<h2 id="WebSocket-和-HTTP-有什么区别？"><a href="#WebSocket-和-HTTP-有什么区别？" class="headerlink" title="WebSocket 和 HTTP 有什么区别？"></a>WebSocket 和 HTTP 有什么区别？</h2><ul>
<li>WebSocket 是一种<strong>双向实时通信协议</strong>，而 HTTP 是一种<strong>单向通信协议</strong>。</li>
<li>WebSocket 使用 ws:&#x2F;&#x2F; 或 wss:&#x2F;&#x2F; 作为协议前缀，HTTP 使用 http:&#x2F;&#x2F; 或 https:&#x2F;&#x2F; 作为协议前缀。</li>
<li>WebSocket 可以支持扩展，实现部分自定义的子协议，如支持压缩、加密等。</li>
</ul>
<h1 id="Ping命令"><a href="#Ping命令" class="headerlink" title="Ping命令"></a>Ping命令</h1><p>ping命令用来测试网络中主机之间的连通性和网络延迟。</p>
<p><strong>工作原理：</strong><br><strong>基于网络层的</strong> <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p>
<p>PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。</p>
<ul>
<li>PING 命令会向目标主机发送 ICMP Echo Request。</li>
<li>如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题，</strong>属于应用层协议，使用UDP传输。<br><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/4.png"><br>先以<strong>递归</strong>的方式查询<strong>本地 DNS 服务器</strong>，再以<strong>迭代</strong>的方式查询其余服务器。</p>
<p><strong>DNS解析过程：</strong></p>
<ul>
<li>先查询缓存以及硬盘里的hosts文件。</li>
<li>请求本地dns服务器，本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信。</li>
<li>本地DNS服务器以迭代的方式请求根域名服务器、顶级域名服务器、权威域名服务器 …最终查询到ip地址。</li>
</ul>
<h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><p><strong>TCP是面向连接的、可靠的、基于字节流的传输层协议。（基于这三个性质扯知识点）</strong></p>
<h2 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h2><ul>
<li><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。</li>
<li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
</ul>
<h2 id="什么时候选择-TCP，什么时候选-UDP"><a href="#什么时候选择-TCP，什么时候选-UDP" class="headerlink" title="什么时候选择 TCP，什么时候选 UDP?"></a>什么时候选择 TCP，什么时候选 UDP?</h2><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h2 id="HTTP-基于-TCP-还是-UDP？"><a href="#HTTP-基于-TCP-还是-UDP？" class="headerlink" title="HTTP 基于 TCP 还是 UDP？"></a>HTTP 基于 TCP 还是 UDP？</h2><p><strong>HTTP&#x2F;3.0 之前是基于 TCP 协议的，而 HTTP&#x2F;3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。</strong> 主要是为了解决 HTTP&#x2F;2 中存在的队头阻塞问题。</p>
<p>这是由于 HTTP&#x2F;2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p>
<h2 id="使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h2><p><strong>使用TCP的协议：</strong></p>
<ul>
<li><strong>HTTP 协议</strong>（HTTP&#x2F;3.0 之前）：是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>HTTPS 协议</strong>：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议。</li>
<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。</li>
<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>
<li><strong>POP3&#x2F;IMAP 协议</strong>：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>
<li><strong>Telnet 协议</strong>：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>
<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>
</ul>
<p><strong>使用UDP的协议：</strong></p>
<ul>
<li><strong>HTTP 协议（HTTP&#x2F;3.0 ）</strong>： HTTP&#x2F;3.0 弃用 TCP，改用基于 UDP 的 QUIC 协议 。</li>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址。</li>
<li><strong>DNS</strong>：域名系统（DNS，Domain Name System）将人类可读的域名转换为机器可读的 IP 地址。实际上，DNS 同时支持 UDP 和 TCP 协议。</li>
</ul>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>
<ul>
<li>一次握手 : 客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认；</li>
<li>二次握手 : 服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态</li>
<li>三次握手 : 客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成 TCP 三次握手。</li>
</ul>
<h2 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手?"></a>为什么需要三次握手?</h2><p><strong>三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<ol>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常。</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常。</li>
</ol>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ul>
<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 FIN-WAIT-1 状态。</li>
<li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li>
<li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了</li>
</ul>
<p><strong>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</strong></p>
<blockquote>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
</blockquote>
<h2 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h2><ul>
<li><strong>基于数据块传输</strong>：应用数据被分割成数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>重传机制</strong> : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答。</li>
<li><strong>流量控制</strong> : 当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。<strong>接收方的接收能力由滑动窗口表示</strong>，表示接收方还有多少缓冲区可以用来接收数据。<strong>网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量</strong>。<strong>发送方发送数据的大小是滑动窗口和拥塞窗口的最小值</strong>，<strong>这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</strong></li>
</ul>
<h2 id="什么是TCP粘包-拆包？发生的原因？"><a href="#什么是TCP粘包-拆包？发生的原因？" class="headerlink" title="什么是TCP粘包&#x2F;拆包？发生的原因？"></a>什么是TCP粘包&#x2F;拆包？发生的原因？</h2><p>由于 <strong>TCP</strong> 传输协议是<strong>面向字节流</strong>的传输协议，<strong>没有消息保护边界</strong>，所以发送方发送的多个数据包，接收方应用层不知如何区分，可能会被当成一个包来处理，这就是粘包；或者，发送方将一个打包分成多个小包发送，而接收方将它们当成多个包进行处理，这就是拆包。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li><strong>将首尾字符用特殊字符分隔。</strong></li>
<li><strong>使用变长协议，在报文头中指定当前报文中数据的长度。</strong>(如HTTP协议)</li>
</ul>
<h2 id="TCP的几种状态"><a href="#TCP的几种状态" class="headerlink" title="TCP的几种状态"></a>TCP的几种状态</h2><p><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/5.jpg"><br><strong>三次握手：</strong></p>
<ul>
<li><strong>CLOSED</strong>：初始状态，表示TCP连接是“关闭着的”或“未打开的”。</li>
<li><strong>LISTEN</strong> ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。</li>
<li><strong>SYN_RCVD</strong> ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。</li>
<li><strong>SYN_SENT</strong> ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</li>
<li><strong>ESTABLISHED</strong> ：表示TCP连接已经成功建立。</li>
</ul>
<p><strong>四次挥手：</strong></p>
<ul>
<li><strong>FIN_WAIT_1</strong> ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。</li>
<li><strong>FIN_WAIT_2</strong> ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。</li>
<li><strong>TIME_WAIT</strong> ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）</li>
<li><strong>CLOSING</strong>：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。</li>
<li><strong>CLOSE_WAIT</strong>：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</li>
<li><strong>LAST_ACK</strong>：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。</li>
</ul>
<h2 id="什么是半连接队列？"><a href="#什么是半连接队列？" class="headerlink" title="什么是半连接队列？"></a>什么是半连接队列？</h2><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。</p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP&#x2F;IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>
<h1 id="NAT的作用是什么？"><a href="#NAT的作用是什么？" class="headerlink" title="NAT的作用是什么？"></a>NAT的作用是什么？</h1><p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>
<p>NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。</p>
<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><h2 id="什么是-Mac-地址？"><a href="#什么是-Mac-地址？" class="headerlink" title="什么是 Mac 地址？"></a>什么是 Mac 地址？</h2><p><strong>MAC地址</strong>：MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。<br>MAC 地址具有可携带性、永久性，永久地标识一个设备的身份，不论它到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<h2 id="ARP-协议有什么用？"><a href="#ARP-协议有什么用？" class="headerlink" title="ARP 协议有什么用？"></a>ARP 协议有什么用？</h2><p>它解决的是<strong>网络层地址和链路层地址之间的转换问题</strong>。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，<strong>ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</strong></p>
<h1 id="应用层常见协议"><a href="#应用层常见协议" class="headerlink" title="应用层常见协议"></a>应用层常见协议</h1><p><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/6.png"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>Java框架</title>
    <url>/2024/08/05/%E6%A1%86%E6%9E%B6%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h1><p>所谓单例就是所有的请求都用一个对象来处理，而多例则指每个请求用一个新的对象来处理。<br>结论：<strong>线程不安全</strong>。<br><strong>Spring框架中有一个@Scope注解，默认的值就是singleton，单例的。一般在spring的bean都是注入无状态的对象(如service)，无状态对象没有线程安全问题；</strong>但如果在bean中定义了可修改的成员变量，所有线程都共享一个单例bean，此时需要考虑线程安全问题，可使用多例或者加锁解决。<br><strong>为什么bean默认是单例的？</strong><br><strong>Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</strong></p>
<h1 id="什么是AOP？（⭐）"><a href="#什么是AOP？（⭐）" class="headerlink" title="什么是AOP？（⭐）"></a>什么是AOP？（⭐）</h1><p>   即<strong>面向切面编程</strong>。<strong>将与核心业务无关的代码（即交叉业务）独立的抽取出来，形成一个独立的组件，然后以横向交叉的方式应用到业务流程当中。有利于降低模块之间的耦合。</strong><br><img src="/2024/08/05/%E6%A1%86%E6%9E%B6%E7%AF%87/d4c0bf4c308d4e8cb6da4fc12fde095a.png"></p>
<h1 id="项目中哪里使用了AOP？"><a href="#项目中哪里使用了AOP？" class="headerlink" title="项目中哪里使用了AOP？"></a>项目中哪里使用了AOP？</h1><ul>
<li><strong>记录操作日志。</strong><ul>
<li>使用 aop 中的环绕通知 +切点表达式。</li>
<li>切点表达式用来定义通知（Advice）往哪些方法上切入 。</li>
</ul>
</li>
<li><strong>spring实现事务。</strong></li>
</ul>
<h1 id="Spring中的事务是如何实现的？"><a href="#Spring中的事务是如何实现的？" class="headerlink" title="Spring中的事务是如何实现的？"></a>Spring中的事务是如何实现的？</h1><p>使用了 <strong>@Transactional</strong> 注解后事务的自动提交功能就会关闭，由spring帮助实现事务的控制。<strong>spring实现的事务本质就是由aop完成：对方法前后进行拦截，在执行方法之前 开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</strong></p>
<h1 id="Spring中事务失效的场景有哪些？"><a href="#Spring中事务失效的场景有哪些？" class="headerlink" title="Spring中事务失效的场景有哪些？"></a>Spring中事务失效的场景有哪些？</h1><ul>
<li>异常捕获处理，自己处理了异常，没有抛出，spring不会进行回滚操作。<ul>
<li>解决：捕获异常后，手动抛出。</li>
</ul>
</li>
<li>spring默认只会滚非检查异常，如抛出检查异常，也会导致事务失效。<ul>
<li>解决：@Transactional注解上配置rollbackFor属性为Exception，任意异常都会回滚。</li>
</ul>
</li>
<li>事务方法不是public修饰的，也会导致事务失效。</li>
</ul>
<h1 id="Spring的bean的生命周期（⭐）"><a href="#Spring的bean的生命周期（⭐）" class="headerlink" title="Spring的bean的生命周期（⭐）"></a>Spring的bean的生命周期（⭐）</h1><p>   <strong>Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</strong><br>   spring在实例化bean之前，会根据BeanDefinition获取bean的定义信息，如：类的全路径、是否单例、是否延迟加载等等…</p>
<ol>
<li><strong>调用构造函数实例化bean。（这一步属于bean的创建阶段）</strong></li>
<li><strong>bean的依赖注入。(如：set注入、autowire注入等)</strong></li>
<li><strong>检查bean是否实现了Aware结尾的相关接口，并重写相关方法。（BeanNameAware、BeanFactoryAware等，通过实现这些接口可以获取bean的相关信息）</strong></li>
<li><strong>bean后处理器的before方法。</strong></li>
<li><strong>bean的初始化方法。</strong></li>
<li><strong>bean后处理器的after方法。（这五步属于bean的赋值阶段）</strong></li>
<li><strong>使用bean。</strong></li>
<li><strong>销毁bean。</strong></li>
</ol>
<h1 id="Spring中的循环依赖"><a href="#Spring中的循环依赖" class="headerlink" title="Spring中的循环依赖"></a>Spring中的循环依赖</h1><p><strong>即 两个或多个实例存在相互依赖的关系，A对象赋值需要用到B对象，B对象赋值需要用到A对象，有点像死锁。</strong></p>
<ul>
<li><strong>singleton + set注入：</strong><ul>
<li>spring可以解决此情况的循环依赖问题：<strong>在set注入下，“实例化Bean”和“给Bean属性赋值”两个动作可以分开，又因为bean是单例的，所以在实例化完之后可以直接“曝光”。</strong></li>
</ul>
</li>
<li><strong>prototype + set注入：</strong><ul>
<li>spring无法解决多例+set 注入的循环依赖，因为 bean 的实例化和赋值虽然是分开的，但是每一次实例的对象都不是同一个，但是只要其中一个bean对象改为单例就能解决。</li>
</ul>
</li>
<li><strong>singleton + 构造注入:</strong><ul>
<li><strong>spring无法解决。</strong> 构造注入会导致 <strong>“实例化Bean”</strong> 和 <strong>“给Bean属性赋值”</strong> 两个动作无法分开，单例bean来不及“曝光”。<strong>可以使用注解@Lazy懒加载</strong>，什么时候需要对象再进行bean对象的创建。</li>
</ul>
</li>
</ul>
<h2 id="spring解决循环依赖的三级缓存："><a href="#spring解决循环依赖的三级缓存：" class="headerlink" title="spring解决循环依赖的三级缓存："></a><strong>spring解决循环依赖的三级缓存：</strong></h2><ul>
<li><strong>一级缓存：</strong> 存储的是完整的单例Bean对象，这个Bean对象已经赋值过了。</li>
<li><strong>二级缓存：</strong> 存储的是早期的单例Bean对象，这个Bean对象属性还没有赋值。</li>
<li><strong>三级缓存：</strong> 存储的是单例工厂对象，每一个单例Bean对象都会对应一个单例工厂对象。</li>
</ul>
<p><strong>解决流程：</strong></p>
<ul>
<li>先实例化A对象，同时创建其工厂对象存入三级缓存。</li>
<li>A对象属性赋值需要B对象，实例化B对象，同时创建B的工厂对象，存入三级缓存。</li>
<li>B属性赋值需要注入A对象，于是从三级缓存中获取A的工厂对象，生成A对象存入二级缓存。</li>
<li>B通过二级缓存里获取A对象，属性赋值成功，于是B对象创建成功，存入一级缓存。</li>
<li>此时A对象从一级缓存中获取B对象，注入成功，并将A对象存入一级缓存。</li>
<li>将二级缓存的临时对象A清除。</li>
</ul>
<h1 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h1><p><strong>基于前后端分离开发的执行流程：</strong></p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>方法上添加了@ResponseBody，通过HttpMessageConverter将返回结果转换为JSON并响应</li>
</ul>
<h1 id="Springboot自动配置原理（⭐）"><a href="#Springboot自动配置原理（⭐）" class="headerlink" title="Springboot自动配置原理（⭐）"></a>Springboot自动配置原理（⭐）</h1><p>在Spring Boot项目中的引导类上有一个注解 <strong>@SpringBootApplication</strong>，这个注解是对三个注解进行了封装，分别是：<br><strong>@SpringBootConfiguration</strong>：声明自己是spring的一个配置类，可替换xml文件。<br><strong>@EnableAutoConfiguration</strong>：实现自动化配置的核心注解。<br><strong>@ComponentScan</strong> : 扫描被@Component (@Service,@Controller)注解的 bean，默认扫描该类所在包下的所有类，可以自定义不扫描某些 bean。</p>
<h1 id="Spring框架常见注解（⭐）"><a href="#Spring框架常见注解（⭐）" class="headerlink" title="Spring框架常见注解（⭐）"></a>Spring框架常见注解（⭐）</h1><p><strong>Spring：</strong></p>
<ul>
<li><strong>@Component、@Controller、@Service、@Repository：</strong> 将实体类对象实例化到spring中，纳入spring管理。</li>
<li><strong>@Autowired</strong>：对类成员变量、方法及构造函数进行自动装配，默认根据类型自动装配。</li>
<li><strong>@Qualifier :</strong> 结合@Autowired一起使用，用于根据名称进行自动装配。(同一接口有多个实现类，Autowired不知道装配哪个类型)</li>
<li><strong>@Scope :</strong> 标注Bean的作用范围。</li>
<li><strong>@Configuration :</strong> 指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解。</li>
<li><strong>@ComponentScan：</strong> 用于指定 Spring 在初始化容器时要扫描的包。</li>
<li><strong>@Bean：</strong> 使用在方法上，标注将该方法的返回值存储到Spring容器中。</li>
<li><strong>@Import：</strong> 使用@Import导入的类会被Spring加载到IOC容器中。</li>
<li><strong>@Aspect、@Before、@After、@Around、@Pointcut：</strong> 用于切面编程（AOP）</li>
</ul>
<p><strong>SpringMVC：</strong></p>
<ul>
<li><strong>@RequestMapping：</strong> 用于将任意HTTP 请求映射到控制器方法上。<ul>
<li><strong>各种衍生注解，如：</strong> @GetMapping、@PostMapping、@PutMapping等。</li>
</ul>
</li>
<li><strong>@RequestBody：</strong> 将前端传过来的 json数据转化为java对象。</li>
<li><strong>@RequestParam：</strong> 将请求参数绑定到你控制器的方法参数上。</li>
<li><strong>@PathViriable：</strong> 从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形参。</li>
<li><strong>@ResponseBody：</strong> 将controller方法返回的java对象转化为json对象响应给客户端。</li>
<li><strong>@RequestHeader：</strong> 将请求头中的参数值映射到控制器的参数中。</li>
<li><strong>@RestController：</strong> @Controller + @ResponseBody</li>
</ul>
<p><strong>SpringBoot：</strong></p>
<ul>
<li><strong>@SpringBootConfiguration</strong>：用于定义配置类，可替换xml文件。</li>
<li><strong>@EnableAutoConfiguration</strong>：打开自动配置功能。</li>
<li><strong>@ComponentScan</strong>：扫描被@Component (@Service,@Controller)注解的 bean。</li>
</ul>
<h1 id="MyBatis执行流程"><a href="#MyBatis执行流程" class="headerlink" title="MyBatis执行流程"></a>MyBatis执行流程</h1><ul>
<li><strong>读取MyBatis核心配置文件</strong>：mybatis-config.xml，加载运行环境和映射文件。运行环境包括：事务管理器的配置 + 数据源的配置 ，见MyBatis核心配置文件详解。</li>
<li><strong>加载映射文件</strong>：映射文件即SQL映射文件(mapper.xml)，配置了操作数据库的SQL语句。</li>
<li><strong>构造会话工厂SqlSessionFactory对象</strong>：使用SqlSessionFactoryBuilder对象构建。</li>
<li><strong>创建会话对象SqlSession</strong>：由会话工厂创建，对象中包含了执行SQL语句的所有方法，每个线程都应该有它自己的 SqlSession 实例。</li>
<li><strong>Executor执行器</strong>：是MyBatis的核心，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责维护查询缓存。</li>
<li><strong>MappedStatement对象</strong>：MappedStatement是对解析的SQL语句的封装，一个MappedStatement代表了一个sql语句标签。</li>
<li><strong>输入参数映射</strong>：输入参数类型可以是基本数据类型，也可以是Map、List、POJO等复杂数据类型。</li>
<li><strong>封装结果集</strong>：可以将结果集封装成基本数据类型，也可以是Map、List、POJO等复杂数据类型。</li>
</ul>
<h1 id="Mybatis是否支持延迟加载？底层原理是什么？"><a href="#Mybatis是否支持延迟加载？底层原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？底层原理是什么？"></a>Mybatis是否支持延迟加载？底层原理是什么？</h1><p><strong>Mybatis支持延迟加载：</strong></p>
<ul>
<li>延迟加载是加载策略的一种，分为<strong>延迟加载</strong>和<strong>直接加载</strong>两种策略，延迟加载主要体现在关联查询中。即需要用到数据时才加载，不需要用到就不加载，又叫<strong>懒加载</strong>。</li>
<li><strong>⼀对多，多对多</strong>的情况下通常采⽤<strong>延迟加载</strong>。</li>
<li>在Mybatis配置文件中，可以配置<strong>lazyLoadingEnabled</strong>决定是否启用延迟加载，默认关闭。</li>
</ul>
<p><strong>底层原理：</strong></p>
<ul>
<li>使用<strong>CGLIB</strong>创建目标对象的代理对象。</li>
<li>当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询。</li>
<li>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了。</li>
</ul>
<h1 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h1><p>MyBatis的缓存会将 select 语句的查询结果放到缓存（内存）当中，下一次还是这条select语句的话，直接从缓存中取。因此，<strong>缓存只针对于DQL语句，也就是说缓存机制只对应select语句。</strong></p>
<ul>
<li><strong>一级缓存：</strong><ul>
<li><strong>作用域</strong>：SqlSession。</li>
<li><strong>默认开启</strong>，只要同一个SqlSession对象执行同一select语句就会走缓存。</li>
<li><strong>缓存失效的情况</strong>：<ul>
<li>①手动情况了一级缓存：sqlSession.clearCache();</li>
<li>②进行了增删改操作。</li>
</ul>
</li>
</ul>
</li>
<li><strong>二级缓存：</strong><ul>
<li><strong>作用域：</strong> SqlSessionFactory</li>
<li><strong>使用二级缓存需要四个条件：</strong><ul>
<li>①在配置文件中开启缓存，默认开启。</li>
<li>②在需要使用二级缓存的SqlMapper.xml文件中添加配置：<cache>。</cache></li>
<li>③使用二级缓存的实体类对象必须是可序列化的，即实现Serializable接口。</li>
<li>④SqlSession对象关闭后，一级缓存才会写入二级缓存。</li>
</ul>
</li>
<li><strong>缓存失效的情况：</strong><ul>
<li>进行了增删改操作。</li>
</ul>
</li>
<li><strong>相关配置：</strong><ul>
<li>eviction：指定从缓存中移除某个对象的淘汰算法。默认采用LRU策略。</li>
<li>flushInterval：二级缓存的刷新时间间隔。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h1><ul>
<li><strong>#{}：</strong> 先编译 sql 语句，再给占位符传值，底层是PreparedStatement实现。可以防止 <strong>sql注入</strong>，比较常用。</li>
<li><strong>${}：</strong> 先进行sql语句拼接，然后再编译sql语句，底层是Statement实现。存在 <strong>sql 注入</strong> 现象。只有在需要进行sql语句关键字拼接的情况下才会用到。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2024/08/05/JUC%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="进程与线程的区别？"><a href="#进程与线程的区别？" class="headerlink" title="进程与线程的区别？"></a>进程与线程的区别？</h2><ul>
<li><strong>进程：进程是程序的一次执行过程，是操作系统资源分配的基本单位。</strong>程序由指令和数据组成，指令要运行就得加载至CPU，数据要读写就得加载至内存，在指令运行过程中还需要用到磁盘、网络等设备。<strong>进程就是用来加载指令、管理内存以及IO 的</strong>。</li>
<li><strong>线程：一个线程就是一个指令流，是操作系统中最小的调度单位</strong>，负责将指令流中的一条条指令以一定的顺序交给 CPU 执行。</li>
<li><strong>两者区别</strong>：<ul>
<li><strong>关系</strong>：进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务。</li>
<li><strong>内存</strong>：不同的进程使用不同的内存空间，同一进程下的所有线程共享内存空间。</li>
<li><strong>开销</strong>：线程更轻量，线程上下文切换开销要比进程上下文切换开销低。</li>
</ul>
</li>
</ul>
<h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<h2 id="创建线程的方式（⭐）"><a href="#创建线程的方式（⭐）" class="headerlink" title="创建线程的方式（⭐）"></a>创建线程的方式（⭐）</h2><ul>
<li><p><strong>继承Thread类：</strong>继承 Thread 类，并重写了其 run () 方法，之后直接调用 start () 即可实现多线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过集成 Thread 类实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread</span>().start()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现runnable接口</strong>：定义一个线程执行的任务（run 方法里面的逻辑）并没有创建线程。它首先通过 MyRunnable 类实现 Runnable 接口，然后重写 run () 方法，之后还要把这个实现了 run () 方法的实例传到 Thread 类中才可以实现多线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过实现 Runnable 方式实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 1、创建MyRunnable实例</span></span><br><span class="line"><span class="type">MyRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="comment">//2.创建Thread对象</span></span><br><span class="line"><span class="comment">//3.将MyRunnable放入Thread实例中</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line"><span class="comment">//4.通过线程对象操作线程(运行、停止)</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现Callable接口</strong>：Callable 与 Runnable 名字还有点像，区别在于 Runnable 是无返回值的。它们的本质都是定义线程要做的任务（call 或 run 方法里面的逻辑），而不是说他们本身就是线程。但无论有无返回值，它们都是需要被线程执行。</p>
</li>
<li><p><strong>线程池创建线程</strong></p>
</li>
</ul>
<h3 id="runnable和Callable的区别："><a href="#runnable和Callable的区别：" class="headerlink" title="runnable和Callable的区别："></a>runnable和Callable的区别：</h3><ul>
<li>Runnable 接口 run 方法没有返回值； Callable 接口 call 方法有返回值，是个泛型，和Future 、 FutureTask 配合可以用来获取异步执行的结果。</li>
<li>Callalbe 接口支持返回执行结果，需要调用 FutureTask.get() 得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部使用try-catch消化，不能继续上抛。</li>
</ul>
<h3 id="线程中的run-和-start-的区别："><a href="#线程中的run-和-start-的区别：" class="headerlink" title="线程中的run()和 start()的区别："></a>线程中的run()和 start()的区别：</h3><ul>
<li>**start():**用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li>
<li>**run():**封装了要被线程执行的代码，可以被调用多次。</li>
</ul>
<p><strong>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行，会把 run() 方法当成一个 main 线程下的普通方法去执行。</strong></p>
<h2 id="线程的状态及其生命周期（⭐）"><a href="#线程的状态及其生命周期（⭐）" class="headerlink" title="线程的状态及其生命周期（⭐）"></a>线程的状态及其生命周期（⭐）</h2><ul>
<li><strong>新建状态(New)：</strong> 线程对象被创建出来，但没有执行start()。</li>
<li><strong>可执行状态(RUNNABLE)：</strong> 线程调用start()方法转为可执行状态。</li>
<li><strong>阻塞状态(Blocked)：</strong> 没有获取锁则进入阻塞状态，获得锁再切换为可执行状态。</li>
<li><strong>等待状态(wating)：</strong> 线程调用了wait()方法进入等待状态，其他线程调用notify()唤醒后可切换为可执行状态。</li>
<li><strong>计时等待状态(TIME_WAITING)：</strong> 线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态。</li>
<li><strong>终止状态(TERMINATED)：</strong> 该线程已经运行完毕。</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/9.png"></p>
<h2 id="新建-T1、T2、T3-三个线程，如何保证按顺序执行？（⭐）"><a href="#新建-T1、T2、T3-三个线程，如何保证按顺序执行？（⭐）" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证按顺序执行？（⭐）"></a>新建 T1、T2、T3 三个线程，如何保证按顺序执行？（⭐）</h2><p>使用线程类的<strong>join()<strong>方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</strong>如：在t2线程里添加代码:t1.join(); 在t3线程里添加代码t2.join()；</strong></p>
<blockquote>
<p><strong>join()方法的作用：</strong><br><strong>使主线程(即调用t.join方法的线程)挂起，并等待子线程 t 执行完毕后才会被唤醒。</strong></p>
</blockquote>
<h2 id="notify-和-notifyAll-的区别"><a href="#notify-和-notifyAll-的区别" class="headerlink" title="notify()和 notifyAll()的区别"></a>notify()和 notifyAll()的区别</h2><ul>
<li><strong>notifyAll：</strong> 唤醒所有wait的线程。</li>
<li><strong>notify：</strong> 随机唤醒一个 wait 线程。</li>
</ul>
<h2 id="sleep-方法和-wait-方法的异同"><a href="#sleep-方法和-wait-方法的异同" class="headerlink" title="sleep() 方法和 wait() 方法的异同"></a>sleep() 方法和 wait() 方法的异同</h2><ul>
<li><strong>相同点：</strong> 都可以让线程进入阻塞状态。</li>
<li><strong>不同点：</strong><ul>
<li><strong>方法归属：</strong> sleep是Thread的静态本地方法，wait()是Object类的本地方法。</li>
<li><strong>醒来时机：</strong> sleep执行完线程会自动苏醒；wait需要其他线程调用notify或notifyAll。</li>
<li><strong>锁特性：</strong> 调用wait方法需要获取对象锁，唤醒后会释放锁；调用sleep不需要获取锁也不会释放锁。</li>
</ul>
</li>
</ul>
<h2 id="如何停止一个正在运行的线程？（⭐）"><a href="#如何停止一个正在运行的线程？（⭐）" class="headerlink" title="如何停止一个正在运行的线程？（⭐）"></a>如何停止一个正在运行的线程？（⭐）</h2><ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>
<li>使用stop方法强行终止（不推荐，方法已作废）。</li>
<li>使用interrupt方法中断线程。</li>
</ul>
<h2 id="使用两个线程交替打印1-100（⭐）"><a href="#使用两个线程交替打印1-100（⭐）" class="headerlink" title="使用两个线程交替打印1-100（⭐）"></a>使用两个线程交替打印1-100（⭐）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用两个线程交替打印1-100</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Jay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2024-05-27 21:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">print_1_to_100</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//此处需要加关键字volatile保证变量之间的可见性，否则程序将会阻塞在while循环中动不了（有点类似死锁）。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">thread1</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">thread2</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">99</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(print_1_to_100.flag == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1: &quot;</span> + i );</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                print_1_to_100.flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(print_1_to_100.flag == <span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2: &quot;</span> + i );</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                print_1_to_100.flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/2024/08/05/JUC%E7%AF%87/4.png"></p>
<h1 id="线程中的并发安全"><a href="#线程中的并发安全" class="headerlink" title="线程中的并发安全"></a>线程中的并发安全</h1><h2 id="synchronized关键字的底层原理（⭐）"><a href="#synchronized关键字的底层原理（⭐）" class="headerlink" title="synchronized关键字的底层原理（⭐）"></a>synchronized关键字的底层原理（⭐）</h2><blockquote>
<p><strong>回答思路：宏观介绍一下synchronized的大致功能—&gt;底层实现monitor—&gt;锁升级</strong></p>
</blockquote>
<ul>
<li><strong>synchronized</strong>用于<strong>解决多线程的并发安全问题</strong>，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</li>
<li><strong>synchronized</strong>底层是由<strong>monitor</strong>实现的，在线程获取锁成功过后需要和monitor对象进行关联，即将对象头的mark word字段存储monitor的地址，并将<strong>monitor的owner字段指向该线程</strong>。</li>
<li>由于monitor是操作系统级别的对象，<strong>在实现线程之间的切换时需要从用户态转换到内核态，成本较高，因此synchronized属于重量级锁</strong>，效率低下。 jdk1.6之后引入了锁升级减少了锁的开销，如：轻量级锁、偏向锁等。<ul>
<li>monitor有三个字段：<ul>
<li><strong>Owner</strong>：存储当前获取锁的线程的，只能有一个线程可以获取。</li>
<li><strong>EntryList</strong>：关联没有抢到锁的线程，处于Blocked状态的线程。</li>
<li><strong>WaitSet</strong>：关联调用了wait方法的线程，处于Waiting状态的线程 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="锁升级："><a href="#锁升级：" class="headerlink" title="锁升级："></a>锁升级：</h2><p>介绍锁升级之前，需要先介绍一下<strong>Java对象的内存结构</strong>。在HotSpot虚拟机中，<strong>对象的内存结构</strong>包括三个字段：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充。</strong></p>
<ul>
<li>其中对象头有两个字段：<ul>
<li><strong>Klass pointer：</strong> 指向方法区中存的类元数据，<strong>通过这个指针来确定这个对象是哪个类的实例</strong>。</li>
<li><strong>Mark word：</strong> 对象的hashcode，分代年龄，锁状态，类元数据指针等信息，如下图。</li>
</ul>
</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/3.png"><br><strong>由于阻塞一个线程涉及到操作系统用户态和内核态的转换，开销较大，因此jdk1.6之后，synchronized锁进行了优化，锁一共分为四种状态：</strong></p>
<ul>
<li><strong>无锁状态</strong></li>
<li><strong>偏向锁：</strong>用于<strong>解决锁的重入问题</strong>。共享资源首次被访问时，JVM会对该共享资源对象做一些设置，比如将对象头中是否偏向锁标志位置为1，<strong>对象头中的线程ID设置为当前线程ID，后续当前线程再次访问这个共享资源时，会根据偏向锁标识跟线程ID进行比对是否相同，比对成功则直接获取到锁</strong>，进入临界区域，这也是synchronized锁的可重入功能。</li>
<li><strong>轻量级锁：</strong> 当前锁是偏向锁的时候，有另外的线程访问，则会升级成轻量级锁。<strong>轻量级锁通过自旋等待（CAS操作）来尝试获取锁</strong>，避免线程立即挂起。如果自旋等待达到一定次数仍无法获取锁，则会升级为重量级锁。</li>
<li><strong>重量级锁</strong></li>
</ul>
<h2 id="谈谈-JMM（Java-内存模型）（⭐）"><a href="#谈谈-JMM（Java-内存模型）（⭐）" class="headerlink" title="谈谈 JMM（Java 内存模型）（⭐）"></a>谈谈 JMM（Java 内存模型）（⭐）</h2><p>首先搞清楚<strong>java内存区域</strong>和<strong>java内存模型</strong>的区别：</p>
<ul>
<li><strong>java内存区域</strong>：定义的是jvm在运行时如何如何分区存储程序数据。</li>
<li><strong>java内存模型</strong>：和java并发编程相关，描述了Java程序中各种变量(线程共享变量)的访问规则<br>，目的是为了简化多线程编程。</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/10.png"></p>
<ul>
<li>所有的<strong>共享变量</strong>都存储于<strong>主内存</strong>，这里所说的变量指的是<strong>实例变量</strong>和<strong>类变量</strong>。不包含局部变量，因为<strong>局部变量是线程私有的，因此不存在竞争问题。</strong></li>
<li>每一个线程还存在自己的<strong>工作内存</strong>，线程的工作内存，保留了被线程使用的变量的工作副本。</li>
<li><strong>线程对变量的所有操作(读，写)都必须在工作内存中完成</strong>，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程之间交互需要通过<strong>主内存</strong>完成。</li>
</ul>
<h2 id="谈谈CAS（⭐）"><a href="#谈谈CAS（⭐）" class="headerlink" title="谈谈CAS（⭐）"></a>谈谈CAS（⭐）</h2><p><strong>CAS</strong>全称是：<strong>Compare And Swap(比较再交换)，它体现的是一种乐观锁的思想， 在无锁情况下保证多线程操作共享数据的原子性</strong>。<br> 高并发的场景下，乐观锁相比悲观锁来说，<strong>不存在锁竞争造成线程阻塞</strong>，也不会有死锁的问题，在性能上往往会更胜一筹。但是，<strong>如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升</strong>。<br>CAS 的思想很简单，<strong>就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新</strong>，不相等则自旋重试。<br><strong>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）</strong>。sun.misc包下的<strong>Unsafe</strong>类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作。</p>
<blockquote>
<p><strong>CAS引出的ABA问题</strong>：就是在比较并交换时，存在一个时间差，在这期间数据可能会被修改多次，只不过最终结果和最初结果恰巧相同。<br><strong>解决办法</strong>：使用AtomicStampedReference类可以解决ABA问题。这个类维护了一个版本号Stamp，在进行CAS操作的时候，不仅要比较当前值，还要比较版本号。只有两者都相等，才执行更新操作。</p>
</blockquote>
<h2 id="谈谈volatile（⭐）"><a href="#谈谈volatile（⭐）" class="headerlink" title="谈谈volatile（⭐）"></a>谈谈volatile（⭐）</h2><h3 id="可见性问题："><a href="#可见性问题：" class="headerlink" title="可见性问题："></a>可见性问题：</h3><p>可见性问题和<strong>Java内存模型(JMM)<strong>有关，在JMM中，存在</strong>主内存</strong>和<strong>工作内存</strong>，主内存存的是共享变量，工作内存是线程私有的，线程对数据的操作是在工作内存当中进行的，此时数据的改动对于主内存以及其他工作内存是不可见的。当一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li><strong>保证线程间的可见性</strong>：一个线程修改了某个变量的值，该新值对其他线程来说是立即可见的。<ul>
<li>volatile关键字可以保证变量的可见性，如果我们将变量声明为 volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li>
</ul>
</li>
<li><strong>禁止指令重排序：</strong> 用volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</li>
</ul>
<h2 id="谈谈AQS（⭐）"><a href="#谈谈AQS（⭐）" class="headerlink" title="谈谈AQS（⭐）"></a>谈谈AQS（⭐）</h2><p>AQS全称AbstractQueuedSynchronizer，即<strong>抽象队列同步器</strong>。它是<strong>构建锁或者其他同步组件的基础框架</strong>，常见的实现类有：<strong>ReentrantLock</strong>(阻塞式锁)、<strong>Semaphore</strong>(信号量)、<strong>CountDownLatch</strong>(倒计时锁)。AQS与Synchronized的区别如下图：<br><img src="/2024/08/05/JUC%E7%AF%87/6.png"><br><strong>AQS 核心思想</strong>：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。<br><strong>AQS的核心框架实现：</strong></p>
<ul>
<li>AQS内部维护了一个先进先出的<strong>双向队列CLH</strong>，队列中存储排队等候唤醒的线程。<ul>
<li>CLH队列是一个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。<strong>每个线程被封装成队列中的一个节点，节点保存着线程的引用、前驱节点、后继节点等信息</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/11.png"></p>
<ul>
<li>AQS内部还维护了一个属性<strong>state</strong>，由 <strong>volatile <strong>修饰。相当于资源，默认为0(无锁状态)。当有线程修改了state为1，则该线程获取了资源。状态信息state可以通过</strong>getState</strong>和<strong>setState</strong>方法获取和修改，这些方法由final修饰，无法更改。</li>
<li>使用<strong>CAS</strong>操作保证各线程对state修改的原子性。即<strong>compareAndSetState</strong>方法。</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/5.png"></p>
<h2 id="AQS底层的实现类（⭐）"><a href="#AQS底层的实现类（⭐）" class="headerlink" title="AQS底层的实现类（⭐）"></a>AQS底层的实现类（⭐）</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul>
<li>ReentrantLock表示可重入锁，属于独占式锁，同一线程可多次获取锁。</li>
<li>ReentrantLock主要利用CAS+AQS队列来实现。</li>
<li>ReentrantLock支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁。</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li>synchronized 和 ReentrantLock都是一次只允许一个线程访问某个资源，<strong>Semaphore (信号量)可以控制同时访问特定资源的线程数量</strong>，通常用于那些资源有明确访问数量限制的场景比如<strong>限流</strong>。</li>
<li>Semaphore 的使用：假设有 N个线程来获取 Semaphore 中的共享资源，以下代码表示同一时刻 只有N 个线程能获取到共享资源，其他线程都会阻塞。直到有线程释放了共享资源，其他阻塞的线程才能获取到资源。</li>
<li>Semaphore也支持公平锁和非公平锁：<ul>
<li><strong>公平模式：</strong> 调用 <strong>acquire()</strong> 方法的顺序遵循 FIFO；</li>
<li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>
</li>
</ul>
<h2 id="谈谈ConcurrentHashMap-（⭐）"><a href="#谈谈ConcurrentHashMap-（⭐）" class="headerlink" title="谈谈ConcurrentHashMap （⭐）"></a>谈谈ConcurrentHashMap （⭐）</h2><ul>
<li><strong>底层数据结构：</strong><ul>
<li>JDK1.7及之前之前采用** 分段数组(segment) + 链表**实现。</li>
<li>JDK1.8开始底层的数据结构和JDK1.8HashMap一样，采用<strong>数组+链表&#x2F;红黑树</strong>实现。</li>
</ul>
</li>
<li><strong>加锁方式：</strong><ul>
<li>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock。</li>
<li>JDK1.8放弃了Segment分段锁的设计，采用** CAS + synchronized **保证线程安全，锁粒度更细。CAS控制数组节点的添加，synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发安全问题。</li>
</ul>
</li>
</ul>
<p>jdk1.7：<br><img src="/2024/08/05/JUC%E7%AF%87/7.png"><br>jdk1.8：<br><img src="/2024/08/05/JUC%E7%AF%87/2.png"></p>
<h2 id="Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）"><a href="#Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）" class="headerlink" title="Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）"></a>Java中怎么保证多线程的执行安全？（导致并发程序出现安全问题的根本原因是什么？）</h2><p>满足Java并发编程的三大特性：</p>
<ul>
<li><strong>原子性：</strong> 一段程序执行是不可分割的，要么全部执行成功，要么全部失败。<ul>
<li>可以使用synchronized和lock保证程序的原子性。</li>
</ul>
</li>
<li><strong>可见性：</strong> 一个线程对共享变量的修改对另一个线程可见。<ul>
<li>可以使用volatile(推荐)保证可见性，synchronized、Lock也可以。</li>
</ul>
</li>
<li><strong>有序性：</strong> 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<ul>
<li>可以通过volatile关键字来保证一定的“有序性”，synchronized和Lock也可以。</li>
</ul>
</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="什么是线程池？为什么要用线程池？（⭐）"><a href="#什么是线程池？为什么要用线程池？（⭐）" class="headerlink" title="什么是线程池？为什么要用线程池？（⭐）"></a>什么是线程池？为什么要用线程池？（⭐）</h2><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。<strong>线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制</strong>。池化技术的好处：</p>
<ul>
<li><strong>降低资源消耗</strong>。重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当有任务时，可以不需要等待线程的创建就能立即执行。</li>
</ul>
<h4 id="线程池的关闭方式："><a href="#线程池的关闭方式：" class="headerlink" title="线程池的关闭方式："></a>线程池的关闭方式：</h4><ul>
<li><strong>shutdown</strong>：使线程池状态从 <strong>RUNNING</strong> 转变为 <strong>SHUTDOWN</strong>，该状态下不再处理新任务，但会将工作队列中的任务执行结束。</li>
<li><strong>shutdownNow</strong>：使线程池状态将会从 <strong>RUNNING</strong> 转变为 <strong>STOP</strong>，该状态下新任务旧任务都不再处理，并且会中断线程。</li>
</ul>
<h2 id="线程池的核心参数（⭐）"><a href="#线程池的核心参数（⭐）" class="headerlink" title="线程池的核心参数（⭐）"></a>线程池的核心参数（⭐）</h2><p>线程池有七个参数：</p>
<ul>
<li><strong>corePoolSize</strong>：核心线程数目</li>
<li><strong>maximumPoolSize</strong>：最大线程数目 &#x3D; 核心线程 + 临时线程的最大数目</li>
<li><strong>workQueue</strong>：当没有空闲核心线程时，新来任务会加入到此队列排队，当队列满时会创建临时线程执行任务</li>
<li><strong>keepAliveTime</strong>：临时线程的生存时间，若生存时间内没有新任务，此线程资源会释放</li>
<li><strong>unit</strong>：临时线程生存时间的单位</li>
<li><strong>threadFactory：线程工厂，可以定制线程对象的创建，如设置线程名字、是否是守护线程等</strong></li>
<li><strong>handler</strong>：拒绝策略 - 当所有线程都在繁忙，队列也放满时，会触发拒绝策略<ul>
<li>1.<strong>AbortPolicy</strong>：直接抛出异常，默认策略；</li>
<li>2.<strong>CallerRunsPolicy</strong>：用调用者所在的线程来执行任务；</li>
<li>3.<strong>DiscardOldestPolicy</strong>：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>4.<strong>DiscardPolicy</strong>：直接丢弃任务。</li>
</ul>
</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/8.png"></p>
<h2 id="线程池中有哪些常见的阻塞队列（⭐）"><a href="#线程池中有哪些常见的阻塞队列（⭐）" class="headerlink" title="线程池中有哪些常见的阻塞队列（⭐）"></a>线程池中有哪些常见的阻塞队列（⭐）</h2><ul>
<li><strong>ArrayBlockingQueue</strong>：基于数组结构的有界阻塞队列，FIFO。</li>
<li><strong>LinkedBlockingQueue</strong>：基于链表结构的有界阻塞队列，FIFO。</li>
<li><strong>DelayedWorkQueue</strong> ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的。</li>
<li><strong>SynchronousQueue</strong>：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li>
</ul>
<p><strong>ArrayBlockingQueue</strong>的<strong>LinkedBlockingQueue</strong>区别：</p>
<ul>
<li>LinkedBlockingQueue默认无界，支持有界；ArrayBlockingQueue强制有界。</li>
<li>LinkedBlockingQueue底层是单向链表实现；ArrayBlockingQueue基于数组实现。</li>
<li>LinkedBlockingQueue头尾各一把锁，效率较高；ArrayBlockingQueue只有一把锁。</li>
</ul>
<h2 id="如何确定核心线程数？（⭐）"><a href="#如何确定核心线程数？（⭐）" class="headerlink" title="如何确定核心线程数？（⭐）"></a>如何确定核心线程数？（⭐）</h2><ul>
<li><strong>CPU密集型任务：</strong> 这类任务消耗的主要是 CPU 资源，可将线程核心数设置为 <strong>N（CPU 核心数）+1。</strong><ul>
<li><strong>多出来的一个核心线程是为了防止各种原因导致任务暂停而带来的影响</strong>。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的线程可以充分利用 CPU 的空闲时间。</li>
</ul>
</li>
<li><strong>I&#x2F;O密集型任务</strong>：这类任务系统会将大部分时间用在I&#x2F;O交互上，这段时间CPU是空闲的，可以交给其他线程使用，因此可以多配置一些线程，常用的值为<strong>2N（CPU核心数）</strong>。</li>
</ul>
<h2 id="如何创建线程池？线程池有哪些种类？（⭐）"><a href="#如何创建线程池？线程池有哪些种类？（⭐）" class="headerlink" title="如何创建线程池？线程池有哪些种类？（⭐）"></a>如何创建线程池？线程池有哪些种类？（⭐）</h2><ul>
<li><strong>方式一：</strong>使用<strong>ThreadPoolExecutor</strong>构造函数来创建。</li>
</ul>
<p><img src="/2024/08/05/JUC%E7%AF%87/1.png"></p>
<ul>
<li><strong>方式二：</strong>使用<strong>Executors</strong>工具类来创建。<ul>
<li>newFixedThreadPool：创建一个定长线程池，控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newSingleThreadExecutor：创建一个单线程的线程池，若多余的任务被提交到该线程池，其会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newScheduledThreadPool：可执行延迟任务的线程池，支持定时及周期性任务执行。</li>
</ul>
</li>
</ul>
<h2 id="为什么不推荐使用内置线程池（Executors）？（⭐）"><a href="#为什么不推荐使用内置线程池（Executors）？（⭐）" class="headerlink" title="为什么不推荐使用内置线程池（Executors）？（⭐）"></a>为什么不推荐使用内置线程池（Executors）？（⭐）</h2><ul>
<li>采用无界的阻塞队列，可能会堆积大量的任务，最终导致内存溢出。</li>
<li>允许创建的线程数为<strong>Integer.MAX_VALUE</strong>，也可能导致内存溢出。</li>
</ul>
<h2 id="谈谈对ThreadLocal的理解（⭐）"><a href="#谈谈对ThreadLocal的理解（⭐）" class="headerlink" title="谈谈对ThreadLocal的理解（⭐）"></a>谈谈对ThreadLocal的理解（⭐）</h2><p><strong>ThreadLocal</strong>，<strong>本地线程变量，ThreadLocal可以让每个线程绑定自己的变量，该变量对其他线程而言是封闭且隔离的。</strong></p>
<h3 id="ThreadLocal的原理："><a href="#ThreadLocal的原理：" class="headerlink" title="ThreadLocal的原理："></a>ThreadLocal的原理：</h3><p><strong>ThreadLocal的set方法源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。<br>        每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。<br><strong>ThreadLocal的get方法源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">get</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T) e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.refersTo(key))</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocal-的应用场景："><a href="#ThreadLocal-的应用场景：" class="headerlink" title="ThreadLocal 的应用场景："></a>ThreadLocal 的应用场景：</h3><ul>
<li><p><strong>解决高并发条件下多线程访问共享变量产生的并发安全问题。</strong></p>
<blockquote>
<p><strong>例如：项目中@Autowired默认是单例模式，那么负责连接数据库的connection也是单例的，如果多个线程同时获取connection请求连接数据库的话，就会产生并发安全问题。底层的解决方案就是使用ThreadLocal，每个线程请求连接数据库的时候，会先从自己的ThreadLocal中获取connection对象，达到各个线程隔离的效果。</strong></p>
</blockquote>
</li>
<li><p><strong>ThreadLocal 用作每个线程内需要独立保存信息</strong>，以便<strong>供其他方法更方便地获取</strong>该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过 ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。</p>
<blockquote>
<p><strong>例如：项目中拦截器中获取到的用户信息，可以让不同方法直接使用，避免了各个类传参的麻烦。</strong></p>
</blockquote>
</li>
</ul>
<h3 id="ThreadLocal-的弊端："><a href="#ThreadLocal-的弊端：" class="headerlink" title="ThreadLocal 的弊端："></a>ThreadLocal 的弊端：</h3><p><strong>内存泄漏：</strong> 如果我们使用线程池创建的线程，那么该线程很长一段时间都不会消失，而ThreadLocalMap中的value值属于强引用，不会被垃圾回收，而key是弱引用，此时就会产生<strong>内存泄漏</strong>的问题。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2024/08/05/JVM%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JVM的组成："><a href="#JVM的组成：" class="headerlink" title="JVM的组成："></a>JVM的组成：</h1><h2 id="JVM-概述-⭐"><a href="#JVM-概述-⭐" class="headerlink" title="JVM 概述(⭐)"></a>JVM 概述(⭐)</h2><h3 id="JVM是什么？"><a href="#JVM是什么？" class="headerlink" title="JVM是什么？"></a>JVM是什么？</h3><p><strong>jvm(Java Virtual Machine)，</strong>是Java程序的运行环境（java二进制字节码的运行环境）。</p>
<ul>
<li><strong>优点：</strong><ul>
<li>一次编写，到处运行。(jvm屏蔽了各种操作系统)</li>
<li>自动内存管理，垃圾回收机制。</li>
</ul>
</li>
</ul>
<h3 id="JVM由哪些部分组成，运行流程是什么？"><a href="#JVM由哪些部分组成，运行流程是什么？" class="headerlink" title="JVM由哪些部分组成，运行流程是什么？"></a>JVM由哪些部分组成，运行流程是什么？</h3><p><img src="/2024/08/05/JVM%E7%AF%87/1.png"><br><strong>JVM 的主要组成部分  :</strong></p>
<ul>
<li><strong>ClassLoader（类加载器）</strong></li>
<li><strong>Runtime Data Area（运行时数据区，内存分区）</strong></li>
<li><strong>Execution Engine（执行引擎）</strong></li>
<li><strong>Native Method Library（本地库接口）</strong></li>
</ul>
<p><strong>运行流程：</strong></p>
<ul>
<li><strong>类加载器</strong>把Java字节码文件加载进内存中。</li>
<li><strong>运行时数据区</strong>分为堆、栈、方法区、程序计数器等，各自存储各个类型的数据。</li>
<li><strong>执行引擎</strong>将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的<strong>本地库接口</strong>来实现整个程序的功能。</li>
</ul>
<h2 id="什么是程序计数器？"><a href="#什么是程序计数器？" class="headerlink" title="什么是程序计数器？"></a>什么是程序计数器？</h2><p><strong>程序计数器</strong>是<strong>线程私有</strong>的，用于记录正在执行的<strong>字节码指令的地址</strong>。<br>        java虚拟机对于多线程任务是通过线程轮流切换并分配线程执行时间来完成的。如果当前被执行的这个线程所分配的执行时间用完了【挂起】，处理器会切换到另外的一个线程上执行。当这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。 <strong>为了使线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。</strong><br>        程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h2 id="介绍一下Java的堆-⭐"><a href="#介绍一下Java的堆-⭐" class="headerlink" title="介绍一下Java的堆(⭐)"></a>介绍一下Java的堆(⭐)</h2><ul>
<li><strong>堆是线程共享的区域</strong>：主要用来保存<strong>对象实例</strong>，<strong>数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出<strong>OutOfMemoryError</strong>异常。</li>
<li><strong>组成：年轻代+老年代：</strong><ul>
<li><strong>年轻代</strong>被划分为三部分，Eden区和两个大小严格相同的Survivor区。</li>
<li><strong>老年代</strong>主要保存生命周期长的对象，一般是一些老的对象。</li>
</ul>
</li>
<li>Jdk1.7和1.8的区别：<ul>
<li>1.7中有有一个<strong>永久代（方法区）</strong>，存储的是类信息、静态变量、常量、编译后的代码。</li>
<li>1.8移除了永久代，把数据存储到了<strong>本地内存的元空间</strong>中，<strong>防止内存溢出</strong>。</li>
</ul>
</li>
</ul>
<h2 id="虚拟机栈-⭐"><a href="#虚拟机栈-⭐" class="headerlink" title="虚拟机栈(⭐)"></a>虚拟机栈(⭐)</h2><h3 id="什么是虚拟机栈？"><a href="#什么是虚拟机栈？" class="headerlink" title="什么是虚拟机栈？"></a>什么是虚拟机栈？</h3><ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈。</li>
<li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存。</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li>
</ul>
<h3 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h3><p>不涉及，<strong>垃圾回收</strong>主要指就是<strong>堆内存</strong>，当栈帧弹栈以后，内存就会释放。</p>
<h3 id="栈帧内存分配越大越好吗？"><a href="#栈帧内存分配越大越好吗？" class="headerlink" title="栈帧内存分配越大越好吗？"></a>栈帧内存分配越大越好吗？</h3><p>未必，默认的栈内存通常为1024k 。栈内存不变下，栈帧过大会导致线程数变少。</p>
<h3 id="方法内的局部变量是否线程安全？"><a href="#方法内的局部变量是否线程安全？" class="headerlink" title="方法内的局部变量是否线程安全？"></a>方法内的局部变量是否线程安全？</h3><ul>
<li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的。</li>
<li>如果局部变量逃离了方法的作用范围(如出现在<strong>形参</strong>或<strong>返回值</strong>)，需要考虑线程安全。</li>
</ul>
<h3 id="什么情况下会导致栈内存溢出？"><a href="#什么情况下会导致栈内存溢出？" class="headerlink" title="什么情况下会导致栈内存溢出？"></a>什么情况下会导致栈内存溢出？</h3><ul>
<li><strong>栈帧过多</strong>导致栈内存溢出，如：递归调用</li>
<li><strong>栈帧过大</strong>导致栈内存溢出。</li>
</ul>
<h3 id="堆栈的区别是什么？"><a href="#堆栈的区别是什么？" class="headerlink" title="堆栈的区别是什么？"></a>堆栈的区别是什么？</h3><ul>
<li><strong>栈内存</strong>一般会用来存储<strong>局部变量</strong>和<strong>方法调用</strong>，但<strong>堆内存</strong>是用来存储<strong>Java对象</strong>和<strong>数组</strong>的。堆有GC垃圾回收，而栈没有。</li>
<li><strong>栈内存</strong>是<strong>线程私有</strong>的，而<strong>堆内存</strong>是<strong>线程共享</strong>的。</li>
<li><strong>两者异常错误不同，栈内存或者堆内存不足都会抛出异常</strong>：   <ul>
<li>栈空间不足：java.lang.StackOverFlowError。      </li>
<li>堆空间不足：java.lang.OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h2 id="介绍一下方法区-⭐"><a href="#介绍一下方法区-⭐" class="headerlink" title="介绍一下方法区(⭐)"></a>介绍一下方法区(⭐)</h2><h3 id="方法区概述"><a href="#方法区概述" class="headerlink" title="方法区概述"></a>方法区概述</h3><ul>
<li><strong>方法区</strong>(Method Area)是各个<strong>线程共享</strong>的内存区域。</li>
<li>主要存储类<strong>的信息、运行时常量池。</strong></li>
<li>虚拟机启动的时候创建，关闭虚拟机时释放。</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace。</li>
</ul>
<p><strong>永久代</strong>是 <strong>JDK 1.8 之前</strong>的方法区实现，<strong>JDK 1.8 <strong>及以后方法区的实现变成了</strong>元空间</strong>。永久代在堆中，而元空间在本地内存，发生OOM的概率比永久代小。<br><img src="/2024/08/05/JVM%E7%AF%87/2.png"></p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li><strong>常量池</strong>：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li>当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>直接内存</strong>不受 JVM 内存回收管理，属于操作系统的内存，常见于 NIO 操作时，用于数据缓冲区，NIO读写性能比IO高。两者区别见下图：<br><img src="/2024/08/05/JVM%E7%AF%87/3.png"><br><img src="/2024/08/05/JVM%E7%AF%87/4.png"><br> <strong>传统阻塞IO</strong> <strong>的数据传输要走两次缓存区，而NIO只需走一次。</strong></p>
<h1 id="类加载器："><a href="#类加载器：" class="headerlink" title="类加载器："></a>类加载器：</h1><h2 id="什么是类加载器，类加载器有哪些-⭐"><a href="#什么是类加载器，类加载器有哪些-⭐" class="headerlink" title="什么是类加载器，类加载器有哪些?(⭐)"></a>什么是类加载器，类加载器有哪些?(⭐)</h2><p><img src="/2024/08/05/JVM%E7%AF%87/5.png"><br><strong>类加载器</strong>（ClassLoader ）的主要作用就是将<strong>类的字节码文件</strong>加载到<strong>JVM</strong> 中 ，从而让 Java 程序能够启动起来。类加载器根据各自加载范围的不同，划分为<strong>四种类加载器</strong>：</p>
<ul>
<li>启动类加载器(BootStrap ClassLoader)：<ul>
<li><strong>该类用来加载 Java 的核心类，并不继承 ClassLoader 类</strong>，其是由 C++ 编写实现。</li>
</ul>
</li>
<li>扩展类加载器(ExtClassLoader)：<ul>
<li>该类是ClassLoader的子类，主要加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类库。</li>
</ul>
</li>
<li>应用类加载器(AppClassLoader)：<ul>
<li>该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。</li>
</ul>
</li>
<li>自定义类加载器：<ul>
<li>开发者自定义类继承ClassLoader，实现自定义类加载规则。</li>
</ul>
</li>
</ul>
<h2 id="双亲委派模型-⭐"><a href="#双亲委派模型-⭐" class="headerlink" title="双亲委派模型(⭐)"></a>双亲委派模型(⭐)</h2><p><strong>该机制的核心思想是，当一个类需要被加载时，首先委托给其父类加载器，如果父类加载器无法加载，则由当前类加载器自己尝试加载。</strong><br>除了启动类加载器外，其他所有类加载器都需要继承抽象类<strong>ClassLoader</strong>，这个抽象类中定义了三个关键方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个类加载器都有个父加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//查找一下这个类是不是已经加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span>( c == <span class="literal">null</span> )&#123;</span><br><span class="line">          <span class="comment">//先委派给父加载器去加载，注意这是个递归调用</span></span><br><span class="line">          <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">              c = parent.loadClass(name);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果父加载器为空，查找Bootstrap加载器是不是加载过了</span></span><br><span class="line">              c = findBootstrapClassOrNull(name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父加载器没加载成功，调用自己的findClass去加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> c；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)&#123;</span><br><span class="line">       <span class="comment">//1. 根据传入的类名name，到在特定目录下去寻找类文件，把.class文件读入内存</span></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">       <span class="comment">//2. 调用defineClass将字节数组转成Class对象</span></span><br><span class="line">       <span class="keyword">return</span> defineClass(buf, off, len)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将字节码数组解析成一个Class对象，用native方法实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>JVM 的类加载器是分层次的，它们有父子关系，而<strong>这个关系不是继承维护，而是组合，每个类加载器都持有一个 parent 字段，指向父加载器</strong>。</li>
<li><strong>loadClass 方法的主要职责就是实现双亲委派机制</strong>：首先检查这个类是不是已经被加载过了，如果加载过了直接返回，否则委派给父加载器加载，这是一个递归调用，<strong>一层一层向上委派，最顶层的类加载器（启动类加载器）无法加载该类时，再一层一层向下委派给子类加载器加载</strong>。</li>
</ul>
<h3 id="为什么采用双亲委派机制？"><a href="#为什么采用双亲委派机制？" class="headerlink" title="为什么采用双亲委派机制？"></a>为什么采用双亲委派机制？</h3><ul>
<li><strong>唯一性：</strong>防止加载同一个类，通过委托询问上级是否已经加载过该.class，如果加载过了，则不需要重新加载。保证了数据安全。</li>
<li><strong>安全性：</strong> 保证类库 API 不会被修改，即使被修改了也不会被加载。</li>
</ul>
<h3 id="如何破坏双亲委派机制？"><a href="#如何破坏双亲委派机制？" class="headerlink" title="如何破坏双亲委派机制？"></a>如何破坏双亲委派机制？</h3><p>如果想不遵循双亲委派的类加载顺序，需要自定义类加载器，并重写findClass和loadClass方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1、获取class文件二进制字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            <span class="type">String</span> <span class="variable">namePath</span> <span class="operator">=</span> name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">classFile</span> <span class="operator">=</span> <span class="string">&quot;C:\\study\\myStudy\\ZooKeeperLearning\\zkops\\target\\classes\\&quot;</span> + namePath + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(classFile));</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、字节码加载到 JVM 的方法区，</span></span><br><span class="line">        <span class="comment">// 并在 JVM 的堆区建立一个java.lang.Class对象的实例</span></span><br><span class="line">        <span class="comment">// 用来封装 Java 类相关的数据和方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 直接自己加载</span></span><br><span class="line">        clazz = <span class="built_in">this</span>.findClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己加载不了，再调用父类loadClass，保持双亲委托模式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类装载的执行过程-⭐"><a href="#类装载的执行过程-⭐" class="headerlink" title="类装载的执行过程(⭐)"></a>类装载的执行过程(⭐)</h2><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了7 个阶段：<br><img src="/2024/08/05/JVM%E7%AF%87/6.png" alt="image.png"></p>
<ul>
<li><strong>加载</strong> : 通过class的<strong>全限定类名</strong>，把该类的代码数据加载到内存中。</li>
<li><strong>链接</strong>：<ul>
<li>**验证 **: 验证类是否符合JVM规范，安全性检查。</li>
<li><strong>准备(⭐)</strong> : 为类变量(静态变量)分配内存并设置类变量初始值（jvm的初始值）。（<strong>如果静态变量被final修饰的话，那么会被赋值为用户设置的初始值</strong>）</li>
<li><strong>解析</strong> : 把常量池中的符号引用转换为直接引用。<ul>
<li><strong>符号引用</strong>：以一组符号来描述所引用的目标。</li>
<li><strong>直接引用</strong>：可以理解为一个内存地址，或者一个偏移量。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
</li>
</ul>
</li>
<li><strong>初始化(⭐)</strong> : 直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码。此阶段会对类的<strong>静态变量，静态代码块、成员变量</strong>等执行初始化操作(开发人员设置的初始值)。<ul>
<li><strong>初始化顺序：静态变量-&gt;静态代码块-&gt;成员变量-&gt;构造函数</strong></li>
</ul>
</li>
<li>**使用 **: JVM 开始从入口方法开始执行用户的程序代码。</li>
<li><strong>卸载</strong> : 当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。<blockquote>
<p><strong>ps：非静态变量属于对象，不属于类，类加载的几个阶段都只针对类变量。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="一个对象从创建到回收在内存中经历了哪些过程？"><a href="#一个对象从创建到回收在内存中经历了哪些过程？" class="headerlink" title="一个对象从创建到回收在内存中经历了哪些过程？"></a>一个对象从创建到回收在内存中经历了哪些过程？</h2><ol>
<li><strong>检查类是否加载：</strong> 当需要创建一个类的实例对象时，需要先判断该类是否被成功加载过了，若没有加载，要先进行类的加载，如果加载过了，会在堆区有一个类的class对象，方法区会有类的相关元数据信息。</li>
<li><strong>分配内存：</strong> 类加载成功后，jvm就能够确定对象的大小了，然后jvm会在堆内存划分一块对象大小的内存空间出来，分配给新生对象。jvm分配内存有两种方式：<ol>
<li><strong>指针碰撞法：</strong> 当堆中内存较规整的时候，会维护一个内存指针，通过移动指针的方式给对象分配内存空间。</li>
<li><strong>空闲列表：</strong> 当堆中内存较为凌乱，会维护一个空闲列表，当对象需要分配内存时，从空闲列表中找到一块足够对象大小的内存，分给新生对象。这种方式可能会产生一些<strong>内存碎片</strong>。<ol>
<li><strong>当多个线程同时分配内存时，这里会有线程安全问题。解决办法有两种：</strong><ol>
<li><strong>cas+重试机制：</strong> 就是通过cas操作移动指针，只有一个线程可以移动成功，移动失败的线程重试，直到成功为止。</li>
<li><strong>本地线程分配缓冲(TLAB)：</strong> 当线程开启时，就为每个线程分配一块较大的空间，然后线程内部创建对象的时候，就从自己的空间分配，当自己的空间分配完了再从堆中分配内存。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>初始化：</strong> 就是对分配的这一块内存初始化为零值，也就是给实例对象的成员变量赋值为零值，引用类型为null，int类型赋值为0等等操作。</li>
<li><strong>设置对象头：</strong> 对象分为 <strong>对象头，实例数据区，对齐填充位</strong>。设置对象头，就是设置对象头中对象的hashcode，分代年龄，锁状态，类元数据指针等信息。<ol>
<li><strong>对象头：</strong> 对象头分为mark word，Klass pointer 两个字段，mark word 保存了对象的hashcode 值，分代年龄，锁状态等信息。</li>
<li><strong>实例数据区：</strong> 保存对象成员变量的值，引用类型的话保存的是内存地址。</li>
<li><strong>对齐填充位：</strong> 填充占用的内存的大小，使其为8字节的整数倍。</li>
</ol>
</li>
<li><strong>执行初始化方法：</strong> 给对象的成员变量设置程序员指定值的初始值，并且会执行构造方法。</li>
</ol>
<h1 id="垃圾回收："><a href="#垃圾回收：" class="headerlink" title="垃圾回收："></a>垃圾回收：</h1><h2 id="对象什么时候可以被垃圾器回收-？-⭐"><a href="#对象什么时候可以被垃圾器回收-？-⭐" class="headerlink" title="对象什么时候可以被垃圾器回收 ？(⭐)"></a>对象什么时候可以被垃圾器回收 ？(⭐)</h2><p>如果没有任何的引用指向该对象了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p>
<p><strong>定位垃圾</strong>的方式：</p>
<ul>
<li><strong>引用计数法</strong>：给对象中添加一个引用计数器，每被引用一次计数器就+1，反之-1。引用数为0时代表该对象可被回收。（缺点：循环引用时会出现内存泄漏）</li>
<li><strong>可达性分析算法</strong>：通过一系列的称为 “GC Roots”（肯定不能当做垃圾回收的对象） 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<ul>
<li><strong>可以作为GC Root的对象：</strong><ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
<li>JNI（Java Native Interface）引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JVM-垃圾回收算法-⭐"><a href="#JVM-垃圾回收算法-⭐" class="headerlink" title="JVM 垃圾回收算法(⭐)"></a>JVM 垃圾回收算法(⭐)</h2><ul>
<li><strong>标记清除算法</strong>：先根据可达性分析算法得出的垃圾进行标记，再对这些标记为可回收的内容进行垃圾回收。<ul>
<li><strong>缺点</strong>：<strong>通过标记清除算法清理出来的内存，碎片化较为严重。</strong></li>
</ul>
</li>
<li><strong>标记整理算法</strong>：和上述类似，在清理完垃圾之后，会对存活对象进行整理，从而<strong>解决了碎片化的问题。</strong><ul>
<li><strong>缺点</strong>：<strong>对象需要移动，效率较低。</strong></li>
</ul>
</li>
<li><strong>复制算法</strong>：将原有的内存空间一分为二，每次只用其中的一块,正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。<strong>无碎片、效率较高。</strong><ul>
<li><strong>缺点</strong>：<strong>内存使用率低。</strong></li>
</ul>
</li>
</ul>
<h2 id="分代收集算法-⭐"><a href="#分代收集算法-⭐" class="headerlink" title="分代收集算法(⭐)"></a>分代收集算法(⭐)</h2><p>根据对象存活周期的不同将内存分为几块。一般将 Java <strong>堆</strong> 分为 <strong>新生代</strong> 和<strong>老年代</strong>，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br><img src="/2024/08/05/JVM%E7%AF%87/7.png"><br>在<strong>新生代</strong>中，每次收集都会有大量对象死去，所以可以选择 <strong>”标记-复制“</strong> 算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择 <strong>“标记-清除”</strong> 或 <strong>“标记-整理”</strong> 算法进行垃圾收集。<br><strong>对象回收分代回收的过程：</strong></p>
<ul>
<li>新创建的对象首先会分配到伊甸园。</li>
<li>当伊甸园内存不足，标记伊甸园和幸存区from中的存活对象。</li>
<li>使用复制算法将存活对象复制到to中，然后释放from和eden的内存。</li>
<li>一段时间后eden内存又不足，标记eden和to中存活的对象，复制到from中。</li>
<li>当幸存区对象熬过几次回收(15次)，晋身至老年代中。(幸存区内存不足或大对象会提前晋身)</li>
</ul>
<h3 id="MinorGC、-Mixed-GC-、-FullGC的区别是什么？"><a href="#MinorGC、-Mixed-GC-、-FullGC的区别是什么？" class="headerlink" title="MinorGC、 Mixed GC 、 FullGC的区别是什么？"></a><strong>MinorGC、 Mixed GC 、 FullGC的区别是什么？</strong></h3><ul>
<li><p><strong>MinorGC</strong>： 发生在新生代的垃圾回收，暂停时间短（ STW ）。</p>
</li>
<li><p><strong>FullGC</strong> ： 新生代 + 老年代完整垃圾回收，暂停时间长（ STW ），应尽力避免。</p>
<blockquote>
<p>触发FullGC的两种情况：<br>①在 MinorGC之前，会判断老年代中是否容得下新生代的对象，容不下会触发FullGC。<br>②在MinorGC之后老年代发生OOM。</p>
</blockquote>
</li>
<li><p><strong>Mixed GC</strong>： 新生代 + 老年代部分区域的垃圾回收， G1 收集器特有 。</p>
<blockquote>
<p>STW （ Stop-The-World ）：暂停所有应用程序线程，等待垃圾回收的完成 。</p>
</blockquote>
</li>
</ul>
<h2 id="JVM-垃圾回收器-⭐"><a href="#JVM-垃圾回收器-⭐" class="headerlink" title="JVM 垃圾回收器(⭐)"></a>JVM 垃圾回收器(⭐)</h2><ul>
<li><strong>串行垃圾收集器</strong>：垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（ STW ），等待垃圾回收的完成，<strong>适用于单机模式的虚拟机</strong>。<ul>
<li><strong>Serial</strong>：作用于新生代，采用复制算法。</li>
<li><strong>Serial Old</strong>： 作用于老年代，采用标记 - 整理算法。</li>
</ul>
</li>
<li><strong>并行垃圾收集器</strong>：（ JDK8 默认使用此垃圾回收器）<ul>
<li><strong>ParNew收集器</strong>：是<strong>Serial收集器的多线程并行版本</strong>，除了<strong>同时使用多条线程进行垃圾收集</strong>之外，其余的行为与Serial收集器完全一致。（除serial之外唯一能和CMS配合的）</li>
<li><strong>Parallel Scavenge收集器</strong>：新生代收集器，基于<strong>标记-复制算法</strong>实现，<strong>和ParNew非常相似，区别在于该收集器更加关注吞吐量</strong>（高效利用CPU）。</li>
<li><strong>Parallel Old收集器</strong>：是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</li>
</ul>
</li>
<li><strong>CMS收集器：</strong>主要作用于老年代<strong>，</strong>以获取<strong>最短回收停顿时间</strong>为目标的收集器，给用户带来良好的交互体验。<ul>
<li>基于<strong>标记-清除算法</strong>实现，整个过程分四个步骤：<strong>初始标记</strong>和<strong>重新标记</strong>耗时较短，需要<strong>STW</strong>暂停其他线程；而整个过程中耗时最长的<strong>并发标记</strong>和<strong>并发清除</strong>阶段中，垃圾收集器线程可以与用户线程并行工作。<ol>
<li>初始标记：标记GCRoots能直接关联到的对象，速度很快。</li>
<li>并发标记：标记GC Roots的间接关联对象，这个过程耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动。</li>
<li>并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ol>
</li>
</ul>
</li>
<li>G1收集器：<ul>
<li>应用于新生代和老年代，JDK9之后默认使用的收集器。</li>
<li>将java堆划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备。</li>
<li>采用标记复制算法，兼顾响应时间和吞吐量。</li>
<li><strong>分为四个阶段：</strong><ul>
<li><strong>初始标记</strong>：标记一下GC Roots能直接关联到的对象，这个阶段需要停顿线程，但耗时很短。</li>
<li><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li><strong>最终标记</strong>：需要对用户线程做一个短暂的暂停，解决上一阶段的漏标问题。</li>
<li><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把这些Region中的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</strong></p>
</blockquote>
<h2 id="强引用、软引用、弱引用、虚引用的区别？"><a href="#强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用的区别？"></a>强引用、软引用、弱引用、虚引用的区别？</h2><ul>
<li><strong>强引用</strong>：最传统的“引用”的定义，只要强引用关系还存在，<strong>垃圾收集器就永远不会回收掉被强引用的对象</strong>。</li>
<li><strong>软引用</strong>：如果内存空间足够，垃圾回收器就不会回收它，<strong>如果内存空间不足了，才会回收这些对象的内存</strong>。</li>
<li><strong>弱引用</strong>：强度比软引用更弱，当垃圾回收器开始工作时，无论内存空间是否充足都会对弱引用对象进行回收。</li>
<li><strong>虚引用</strong>：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>主要用来跟踪对象被垃圾回收器回收的活动</strong>。</li>
</ul>
<h1 id="jvm实践："><a href="#jvm实践：" class="headerlink" title="jvm实践："></a>jvm实践：</h1><h2 id="JVM调优的参数可以在哪里设置参数值？"><a href="#JVM调优的参数可以在哪里设置参数值？" class="headerlink" title="JVM调优的参数可以在哪里设置参数值？"></a>JVM调优的参数可以在哪里设置参数值？</h2><ul>
<li><strong>war包部署在tomcat中设置 修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件</strong></li>
<li><strong>jar包部署在启动参数设置 java -Xms512m -Xmx1024m -jar xxxx.jar</strong></li>
</ul>
<h2 id="JVM调优的参数都有哪些？（⭐）"><a href="#JVM调优的参数都有哪些？（⭐）" class="headerlink" title="JVM调优的参数都有哪些？（⭐）"></a>JVM调优的参数都有哪些？（⭐）</h2><ul>
<li><strong>设置堆空间大小</strong>：设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。<ul>
<li>-Xms：设置堆的初始化大小</li>
<li>-Xmx：设置堆的最大大小</li>
</ul>
</li>
<li><strong>虚拟机栈的大小</strong>：每个线程默认会开启1M的内存，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。<ul>
<li>-Xss   对每个线程stack大小的调整,-Xss128k</li>
</ul>
</li>
<li><strong>年轻代中Eden区和两个Survivor区的大小比例：</strong><ul>
<li>-XXSurvivorRatio&#x3D;8，表示年轻代中的分配比率：survivor:eden &#x3D; 2:8</li>
</ul>
</li>
<li><strong>年轻代晋升老年代阈值：默认为15。</strong><ul>
<li>-XX:MaxTenuringThreshold&#x3D;threshold</li>
</ul>
</li>
<li><strong>设置垃圾回收收集器：</strong><ul>
<li>-XX:+UseParallelGC</li>
<li>-XX:+UseG1GC</li>
</ul>
</li>
</ul>
<h2 id="JVM-调优的工具"><a href="#JVM-调优的工具" class="headerlink" title="JVM 调优的工具"></a>JVM 调优的工具</h2><ul>
<li><strong>命令工具：</strong><ul>
<li><strong>jps</strong>：输出JVM中运行的进程状态信息。	</li>
<li><strong>jstack</strong>：查看java进程内线程的堆栈信息。</li>
<li><strong>jmap</strong>：用于生成堆转存快照。</li>
<li><strong>jhat</strong>：用于分析jmap生成的堆转存快照。</li>
<li><strong>jstat</strong>：是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。</li>
</ul>
</li>
<li><strong>可视化工具：</strong><ul>
<li><strong>jconsole</strong>： 对 jvm 的内存，线程，类进行监控，是一个基于 jmx 的 GUI 性能监控工具。<ul>
<li>打开方式：java 安装目录 bin 目录下 直接启动 jconsole.exe 就行。</li>
</ul>
</li>
<li><strong>VisualVM</strong>：故障处理工具，能够监控线程，内存情况，查看方法的CPU时间和内存中的对象，已被GC的对象，反向查看分配的堆栈。<ul>
<li>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java内存泄露的排查思路"><a href="#Java内存泄露的排查思路" class="headerlink" title="Java内存泄露的排查思路"></a>Java内存泄露的排查思路</h2><p><strong>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况。</strong></p>
<ol>
<li>通过jmap或设置jvm参数获取堆内存快照dump</li>
<li>通过工具， VisualVM去分析dump文件，VisualVM可以加载离线的dump文件</li>
<li>通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</li>
<li>找到对应的代码，通过阅读上下文的情况，进行修复即可</li>
</ol>
<h2 id="CPU飙高排查方案与思路（⭐）"><a href="#CPU飙高排查方案与思路（⭐）" class="headerlink" title="CPU飙高排查方案与思路（⭐）"></a>CPU飙高排查方案与思路（⭐）</h2><ol>
<li>使用top命令查看占用cpu的情况，查看是哪一个进程占用cpu较高。</li>
<li>使用ps命令查看进程中的线程信息。</li>
<li>使用jstack命令查看进程中线程的信息，并定位到出问题的具体线程，最终定位问题。</li>
</ol>
<h2 id="什么是-OOM？如何分析及解决-OOM-问题-（⭐）"><a href="#什么是-OOM？如何分析及解决-OOM-问题-（⭐）" class="headerlink" title="什么是 OOM？如何分析及解决 OOM 问题?（⭐）"></a>什么是 OOM？如何分析及解决 OOM 问题?（⭐）</h2><h3 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h3><p>OOM，全称“Out Of Memory”，即内存溢出，来源于java.lang.OutOfMemoryError。当 JVM没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error。<br><strong>最常见的OOM情况有以下三种：</strong></p>
<ul>
<li>java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</li>
<li>java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m -XX:MaxPermSize&#x3D;256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</li>
<li>java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。</li>
</ul>
<h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><p>原因不外乎有两点：</p>
<ul>
<li>分配的内存少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。</li>
<li>应用占用内存太多，并且用完没释放，浪费了。此时就会造成<strong>内存泄露</strong>甚至<strong>内存溢出</strong>。</li>
</ul>
<h3 id="How？"><a href="#How？" class="headerlink" title="How？"></a>How？</h3><p><strong>如何预防？</strong></p>
<ul>
<li><strong>及时释放资源，防止内存泄漏</strong><ul>
<li>内存泄漏是导致OOM的一个重要原因。我们需要在代码中及时释放不再使用的内存，避免长时间占用内存资源。比如在Java中，使用finally块或try-with-resources语句，确保资源及时释放。</li>
</ul>
</li>
<li><strong>调整内存配置</strong><ul>
<li>针对不同的应用需求，合理配置内存参数。例如，在Java中，可以通过调整JVM的堆内存大小（-Xmx和-Xms参数）来满足应用的内存需求。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2024/08/05/Redis%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Redis常见数据类型及其应用场景（⭐）"><a href="#Redis常见数据类型及其应用场景（⭐）" class="headerlink" title="Redis常见数据类型及其应用场景（⭐）"></a>Redis常见数据类型及其应用场景（⭐）</h1><pre><code>    Redis 中比较常见的数据类型有：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。 
</code></pre>
<ul>
<li><p><strong>String</strong>：一般用于存储一些常规数据，如Session、Token、序列化后的对象，还可以用来实现分布式锁。</p>
</li>
<li><p><strong>Hash</strong>：适合用于存储对象信息。</p>
</li>
<li><p><strong>List</strong>：底层为一个双向链表，支持从左右两边获取元素以及弹出元素，可以使用range命令查看范围内的元素。 List可用作消息队列，但一般不推荐使用。</p>
</li>
<li><p><strong>Set</strong>：无序集合，集合内元素没有顺序且唯一。 基于set可以轻易的实现交集、并集、差集的操作，因此Set常用于实现共同关注、共同好友等功能。</p>
</li>
<li><p><strong>Zset</strong>：类似于Set，只是每个元素加了一个score字段，元素会根据score的大小进行排序，并且可以根据score值进行范围查询。常用于实现排行榜等功能。</p>
<pre><code>还有特殊的数据类型：
</code></pre>
</li>
<li><p><strong>BitMap</strong> ：底层是一个由0、1组成的二进制串，常用命令：setbit key offset value；getbit key offset； 通常用于用户签到等场景：key为[当前年份：用户id]，offset为[当前天数]。</p>
</li>
<li><p><strong>HyperLogLog</strong> ：能够使用极少的内存来统计巨量的数据，如统计百万级访问量网页的用户点击次数。在 Redis 中实现的 HyperLogLog，只需要12K内存就能统计2^64个数据。 但是计数存在一定的误差，标准误差为 0.81% 。</p>
</li>
<li><p><strong>Geospatial</strong>：主要用于存储地理位置信息，通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>
</li>
</ul>
<h1 id="Redis有什么优点和缺点？"><a href="#Redis有什么优点和缺点？" class="headerlink" title="Redis有什么优点和缺点？"></a>Redis有什么优点和缺点？</h1><p><strong>优点：</strong></p>
<ul>
<li><strong>速度快</strong>：Redis是基于内存的，并且是单线程的，还采用了IO多路复用模型。</li>
<li><strong>支持丰富的数据类型。</strong></li>
<li><strong>提供了持久化策略</strong>：RDB和AOF等持久化策略。</li>
<li><strong>提供高并发和高可用的Redis集群</strong>。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Redis是内存数据库，存储的数据量有限，需要制定数据过期策略定期删除数据。</li>
</ul>
<h1 id="什么是缓存穿透-怎么解决-（⭐）"><a href="#什么是缓存穿透-怎么解决-（⭐）" class="headerlink" title="什么是缓存穿透 ? 怎么解决 ?（⭐）"></a>什么是缓存穿透 ? 怎么解决 ?（⭐）</h1><pre><code>    缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存就形同虚设（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。
  
</code></pre>
<p> <strong>解决方案：</strong></p>
<ul>
<li><strong>缓存空对象</strong>：如果该数据在缓存和数据库中都不存在，就缓存一个空值到redis中，并且超时时间设置得短一点，如2分钟，以防占用太多redis空间。</li>
<li><strong>布隆过滤</strong>：布隆过滤器是由初始值都为 0 的位图数组和若干个个哈希函数组成的数据结构，通常用于从海量数据中判断某数字是否存在，应用场景如缓存穿透、垃圾邮件过滤。布隆过滤器会通过若干个哈希函数计算数据的哈希值并取模，在位图中对应位置设为1。客户端的所有请求都会先通过该过滤器进行过滤，由于哈希的性质，若该过滤器都查不到数据，则直接返回错误信息；若查到了则放行，但也不一定存在该数据(存在哈希冲突)。</li>
</ul>
<h1 id="什么是缓存击穿-怎么解决-（⭐）"><a href="#什么是缓存击穿-怎么解决-（⭐）" class="headerlink" title="什么是缓存击穿? 怎么解决 ?（⭐）"></a>什么是缓存击穿? 怎么解决 ?（⭐）</h1><pre><code>    缓存击穿也叫热点Key问题，一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。
</code></pre>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>互斥锁</strong>：只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求。<ul>
<li>优点：强一致性。</li>
<li>缺点：性能差。</li>
</ul>
</li>
<li><strong>逻辑过期</strong>：①在缓存中多设置一个逻辑过期字段，而不真正设置过期时间。②查询时，通过过期字段来判断当前key是否过期。③<strong>若过期，则另外开一个线程去数据库查询并同步缓存数据，当前线程则返回旧数据。</strong><ul>
<li>优点：性能高，具有高可用性。</li>
<li>缺点：无法保证数据绝对一致。</li>
</ul>
</li>
</ul>
<h1 id="什么是缓存雪崩-怎么解决-（⭐）"><a href="#什么是缓存雪崩-怎么解决-（⭐）" class="headerlink" title="什么是缓存雪崩? 怎么解决 ?（⭐）"></a>什么是缓存雪崩? 怎么解决 ?（⭐）</h1><pre><code>    缓存雪崩是指在同一时间段，大量缓存的key同时失效，或者Redis服务宕机，导致大量请求到达数据库。
</code></pre>
<p><strong>解决方案：</strong></p>
<ul>
<li>给不同的Key的TTL添加随机值，让其在不同时间段分批失效。</li>
<li>利用Redis集群提高服务的可用性。（哨兵模式，集群模式）</li>
<li>给缓存业务添加降级限流策略。（保底策略）</li>
<li>给业务添加多级缓存。（可以理解为穿了好几件防弹衣）。</li>
</ul>
<h1 id="mysql如何与redis进行同步？（⭐）"><a href="#mysql如何与redis进行同步？（⭐）" class="headerlink" title="mysql如何与redis进行同步？（⭐）"></a>mysql如何与redis进行同步？（⭐）</h1><p>业务中有优惠券秒杀功能，要求实时性比较高，因此采用读写锁保证redis和mysql的强一致性。 主要采用redisson实现的读写锁，读的时候添加共享锁（读锁），保证读读不互斥，读写互斥；更新数据的时候添加排他锁（写锁），读读、读写都互斥。 这样可以防止写数据的时候其他线程读数据，避免了脏数据。</p>
<blockquote>
<p><strong>缓存的更新策略：当用户修改数据时，应该先删缓存还是先修改数据库？</strong></p>
<ul>
<li><strong>先删缓存</strong>：修改数据库的途中，有别的线程来访问该数据就会把脏数据读入缓存。</li>
<li><strong>先更新数据库</strong>：删完缓存还没提交事务的这段时间空隙，有别的线程来访问数据也会访问到脏数据并读入内存，但是发生的机率较小。</li>
</ul>
</blockquote>
<p><strong>延时双删：</strong> 延时双删也是分布式系统中保持redis和mysql一致性的常用策略，但不具有强一致性。</p>
<ul>
<li><strong>延时双删：当前为写操作时，先删除redis中的缓存，再更新数据库，短暂延时之后再次删除redis中的缓存。</strong><ul>
<li>为什么要两次删除redis缓存？<ul>
<li>防止数据库还没更新完，有别的线程读取了数据库的脏数据，并更新redis缓存。</li>
</ul>
</li>
<li>为什么要延时删除？<ul>
<li>数据库一般是主从模式，需要给主节点一些时间同步数据到从节点中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="redis做为缓存，数据的持久化是怎么做的？（⭐）"><a href="#redis做为缓存，数据的持久化是怎么做的？（⭐）" class="headerlink" title="redis做为缓存，数据的持久化是怎么做的？（⭐）"></a>redis做为缓存，数据的持久化是怎么做的？（⭐）</h1><pre><code>    Redis是内存数据库，宕机后数据会消失，需要提供持久化策略。在Redis中提供了两种数据持久化的方式：RDB 和 AOF。
</code></pre>
<ul>
<li><strong>RDB（Redis DataBase）</strong>：是一个快照文件，它把redis内存存储的数据写到磁盘上，当redis 宕机恢复数据的时候，方便从 RDB 的快照文件中恢复数据。<ul>
<li><strong>优点</strong>：RDB是二进制压缩文件，占用空间小，便于传输，恢复数据速度较快。</li>
<li><strong>缺点</strong>：两次RDB期间有空档期，此期间若Redis宕机了可能会造成数据的丢失。</li>
<li><strong>创建RDB文件的两个命令</strong>：<ul>
<li><strong>SAVE</strong>：会阻塞Redis服务器进程，直到RDB文件创建完毕为止。</li>
<li><strong>BGSAVE</strong>：会派生出一个子进程负责创建RDB文件，父进程继续处理命令请求。</li>
</ul>
</li>
</ul>
</li>
<li><strong>AOF（append only file）</strong>：当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。（AOF会记录过程，RDB只管结果）<ul>
<li><strong>优点</strong>：数据的完整性较高。</li>
<li><strong>缺点</strong>：文件较大，恢复速度较慢。</li>
</ul>
</li>
<li><strong>RDB-AOF混合持久化</strong>：该模式会将生成相应的RDB数据，写入AOF文件中，重写后的新 AOF 文件前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。这样用户可以同时获得RDB持久化和AOF持久化的优点。</li>
</ul>
<h1 id="Redis的数据过期策略有哪些-（⭐）"><a href="#Redis的数据过期策略有哪些-（⭐）" class="headerlink" title="Redis的数据过期策略有哪些 ?（⭐）"></a>Redis的数据过期策略有哪些 ?（⭐）</h1><p>Redis的过期删除策略：惰性删除 + 定期删除两种策略进行配合使用。</p>
<ul>
<li><strong>惰性删除</strong>：设置该key过期时间后，不去管它，当需要该key时，再检查其是否过期，如果过期，我们就删掉它，反之返回该key。<ul>
<li>优点：对CPU友好，只在使用该key时才进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</li>
<li>缺点：对内存不友好，过期的key将一直存在于内存中不会释放。</li>
</ul>
</li>
<li><strong>定期删除：</strong> 每隔一段时间，我们就对一些key进行检查，删除里面过期的key。<ul>
<li>优点：可以通过限制删除操作执行的时长来减少对 CPU性能的影响。</li>
<li>缺点：这个操作时长难以把控。</li>
</ul>
</li>
</ul>
<h1 id="redis的数据淘汰策略"><a href="#redis的数据淘汰策略" class="headerlink" title="redis的数据淘汰策略"></a>redis的数据淘汰策略</h1><p><strong>Redis支持8种不同策略来选择要删除的key：</strong></p>
<ul>
<li><strong>noeviction</strong>： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li>
<li><strong>volatile-ttl</strong>： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰。</li>
<li><strong>allkeys-random</strong>：对全体key ，随机进行淘汰。</li>
<li><strong>volatile-random</strong>：对设置了TTL的key ，随机进行淘汰。</li>
<li><strong>allkeys-lru</strong>： 对全体key，基于LRU算法进行淘汰。</li>
<li><strong>volatile-lru</strong>： 对设置了TTL的key，基于LRU算法进行淘汰。</li>
<li><strong>allkeys-lfu</strong>： 对全体key，基于LFU算法进行淘汰。</li>
<li><strong>volatile-lfu</strong>： 对设置了TTL的key，基于LFU算法进行淘汰。</li>
</ul>
<h2 id="LRU和LFU两种策略："><a href="#LRU和LFU两种策略：" class="headerlink" title="LRU和LFU两种策略："></a>LRU和LFU两种策略：</h2><ul>
<li><strong>LRU（Least Recently Used）：</strong> 最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li>
<li><strong>LFU（Least Frequently Used）：</strong> 最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li>
</ul>
<h2 id="数据库有1000万数据-Redis只能缓存20w数据-如何保证Redis中数据都是热点数据"><a href="#数据库有1000万数据-Redis只能缓存20w数据-如何保证Redis中数据都是热点数据" class="headerlink" title="数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中数据都是热点数据 ?"></a>数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中数据都是热点数据 ?</h2><p>使用<strong>allkeys-lru</strong>(最近最少使用)淘汰策略，留下来的都是经常访问的热点数据。</p>
<h2 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h2><p>看数据淘汰策略是什么，如果是默认的配置（ noeviction ），会直接报错。</p>
<h1 id="Redis分布式锁的实现"><a href="#Redis分布式锁的实现" class="headerlink" title="Redis分布式锁的实现"></a>Redis分布式锁的实现</h1><p>   项目中的 <strong>优惠券秒杀抢单功能</strong> 存在<strong>超卖问题</strong>，可以使用<strong>Synchronized</strong>锁解决。但如果是在集群模式下， 多台服务器会对应多个jvm， <strong>synchronized</strong>锁可以锁住单台服务器的多线程，多台服务器就锁不住了，此时需要有一个多服务器共享的锁监视器，即<strong>分布式锁</strong>。<br>   Redis实现<strong>分布式锁</strong>主要利用Redis的<strong>setnx命令(SET if not exists)</strong> ，该命令需要<strong>设置锁的过期时间</strong>，以<strong>防止服务宕机从而导致锁永远无法释放</strong>的问题。这个过期时间设置长了会影响性能，设置短了又可能会提前释放锁导致线程安全问题，这就需要<strong>合理的控制锁的有效时长</strong>。</p>
<h2 id="Redisson实现分布式锁如何合理的控制锁的有效时长？"><a href="#Redisson实现分布式锁如何合理的控制锁的有效时长？" class="headerlink" title="Redisson实现分布式锁如何合理的控制锁的有效时长？"></a>Redisson实现分布式锁如何合理的控制锁的有效时长？</h2><p>   于是我们使用采用<strong>redisson</strong>实现的<strong>分布式锁</strong>，底层是<strong>setnx和lua脚本</strong>（保证原子性）。在redisson的分布式锁中，提供了一个<strong>WatchDog(看门狗）机制：一个线程获取锁成功以后，会定期给锁续期（默认每10s续期一次）。</strong></p>
<h2 id="Redisson的这个锁，可以重入吗？"><a href="#Redisson的这个锁，可以重入吗？" class="headerlink" title="Redisson的这个锁，可以重入吗？"></a>Redisson的这个锁，可以重入吗？</h2><p>   <strong>可重入，这样做是为了避免死锁的产生</strong>。多个锁重入需要判断是否是同一线程，<strong>在redis中进行存储的时候使用的hash结构，来存储线程信息和重入的次数：大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数。</strong></p>
<h2 id="Redisson锁能解决主从数据一致的问题吗？"><a href="#Redisson锁能解决主从数据一致的问题吗？" class="headerlink" title="Redisson锁能解决主从数据一致的问题吗？"></a>Redisson锁能解决主从数据一致的问题吗？</h2><p>   不能解决，但可以使用redisson提供的红锁来解决，但是使用红锁性能太低了，如果业务中非要保证数据的强一致性，建议采用zookeeper实现的分布式锁。</p>
<h1 id="Redis的集群方案（⭐）"><a href="#Redis的集群方案（⭐）" class="headerlink" title="Redis的集群方案（⭐）"></a>Redis的集群方案（⭐）</h1><p>Redis中提供的集群方案总共有三种：<strong>主从集群</strong>、<strong>哨兵模式</strong>、<strong>Redis</strong> <strong>分片集群。</strong></p>
<h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><p>单节点Redis的并发能力是有上限的，要<strong>进一步提高Redis的并发能力</strong>，可以搭建<strong>主从集群</strong>，实现<strong>读写分离</strong>。一般都是<strong>一主多从，主节点负责写数据，从节点负责读数据</strong>，主节点写入数据之后，需要把数据同步到从节点中。<br>主从同步数据的流程：分为<strong>全量同步</strong>和<strong>增量同步</strong>。</p>
<ul>
<li><strong>全量同步：</strong> 从节点第一次与主节点建立连接的时候使用全量同步。<ul>
<li>从节点请求主节点<strong>同步数据</strong>，从节点会携带自己的<strong>replication</strong> <strong>id</strong>和<strong>offset</strong>偏移量。	</li>
<li>主节点判断是否是第一次请求，主要判断依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己replication id和offset发送给从节点，让从节点与主节点的信息保持一致。 </li>
<li>此时主节点会执行bgsave生成rdb文件，同时将此时收到的写命令缓存起来，将 rdb 文件发送给从节点去同步，接着将缓存中的写命令也发送给从节点同步。（<strong>同步数据的过程中，主节点和从节点都是正常工作的，并且从节点是基于旧数据对外提供服务的</strong>）</li>
</ul>
</li>
<li><strong>增量同步：</strong><ul>
<li>从节点请求主节点同步数据，主节点还是判断是不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。</li>
</ul>
</li>
</ul>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis提供了<strong>哨兵（Sentinel）机制</strong>来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p>
<ul>
<li><strong>监测</strong>：Sentinel 会基于心跳机制不断检查master和slave是否按预期工作：<ul>
<li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li>
<li>客观下线：若超过一半的sentinel都认为该实例主观下线，则该实例客观下线。</li>
</ul>
</li>
<li><strong>选主</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。 下面是哨兵选举的规则：<ul>
<li>首先判断主与从节点断开时间长短，如断开时间太长则不选举该从节点。</li>
<li>然后判断从节点的slave-priority值，越小优先级越高。</li>
<li>如果优先值相等，则判断从节点的offset值，越大优先级越高</li>
</ul>
</li>
<li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端。</li>
</ul>
<h2 id="Redis-哨兵模式的数据丢失问题："><a href="#Redis-哨兵模式的数据丢失问题：" class="headerlink" title="Redis 哨兵模式的数据丢失问题："></a>Redis 哨兵模式的数据丢失问题：</h2><p><strong>异步复制导致的数据丢失：</strong><br>由于主从复制的过程是异步的，所以可能有部分数据还没复制到从节点，主节点就宕机了，此时这部分数据就会丢失。<br><strong>脑裂导致的数据丢失：</strong><br>脑裂是由于网络等原因，使得哨兵无法心跳感知到主节点，于是通过选举的方式产生了一个新的主节点，于是就有了两个主节点，这样会导致客户端在老主节点那更新数据，新的主节点无法同步更新数据。<br><strong>解决方案：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<ul>
<li>配置参数：要求至少有 1 个从节点，数据复制和同步的延迟不能超过 10 秒。如果所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。 这样就能<strong>将发生的数据丢失降低到可控范围之内</strong>。</li>
</ul>
<h1 id="怎么保证Redis的高并发高可用？"><a href="#怎么保证Redis的高并发高可用？" class="headerlink" title="怎么保证Redis的高并发高可用？"></a>怎么保证Redis的高并发高可用？</h1><p>首先可以搭建<strong>主从集群(解决高并发)<strong>，再加上使用redis中的</strong>哨兵模式(解决高可用)<strong>，</strong>哨兵模式可以实现主从集群的自动故障恢复</strong>，里面就包含了对主从服务的<strong>监控、自动故障恢复、通知</strong>；<br>        如果master故障，Sentinel会将一个slave提升为master。 当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证redis的高并发高可用。</p>
<h1 id="redis的分片集群"><a href="#redis的分片集群" class="headerlink" title="redis的分片集群"></a>redis的分片集群</h1><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决： <strong>海量数据存储</strong>问题 和 <strong>高并发写</strong>的问题。<br><strong>分片集群的作用：</strong></p>
<ul>
<li>集群中有多个master，每个master保存不同数据。（解决海量数据存储和高并发写的问题）</li>
<li>每个master都可以有多个slave节点。(解决高并发读的问题)</li>
<li>master之间通过ping监测彼此健康状态。</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点。(路由)</li>
</ul>
<h2 id="Redis分片集群中数据是怎么存储和读取的？"><a href="#Redis分片集群中数据是怎么存储和读取的？" class="headerlink" title="Redis分片集群中数据是怎么存储和读取的？"></a><strong>Redis分片集群中数据是怎么存储和读取的？</strong></h2><ul>
<li>Redis 分片集群引入了<strong>哈希槽</strong>的概念，Redis 集群有 16384 个哈希槽。</li>
<li>将16384个插槽分配到不同的<strong>master</strong>节点。</li>
<li>读写数据：<strong>根据key的有效部分计算哈希值</strong>，<strong>对16384取余</strong>。（有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分）<strong>余数做为插槽，寻找插槽所在的节点</strong>。</li>
</ul>
<h1 id="Redis-为什么是单线程的？为什么性能快？（⭐）"><a href="#Redis-为什么是单线程的？为什么性能快？（⭐）" class="headerlink" title="Redis 为什么是单线程的？为什么性能快？（⭐）"></a>Redis 为什么是单线程的？为什么性能快？（⭐）</h1><p>Redis <strong>单线程</strong>并不是说 Redis 服务器就只有一个线程，而是指<strong>在处理客户端请求（如增删改查）的时候只有一个线程</strong>，但其实在其他操作的时候是有可能多个线程的，比如说持久化。<strong>Redis</strong>执行<strong>BGSAVE</strong>指令，进行快照持久化时，就会<strong>fork</strong>出一个子进程，然后子进程去创建快照，完成持久化操作。</p>
<p><strong>为什么 Redis 采用单线程？</strong> </p>
<p>通常在<strong>涉及到频繁 I&#x2F;O 操作的时候可以采用多线程</strong>，<strong>（磁盘I&#x2F;O是一个比较耗时的操作，所以对于需要进行磁盘I&#x2F;O的程序，我们可以使用多线程，在某个线程进行I&#x2F;O时，CPU切换到当前程序的其他线程执行，以此减少CPU的等待时间）</strong> 以提高 CPU 的利用率，<strong>但是 Redis 是基于内存的，不涉及到什么IO操作，使用多线程并不能有效提升效率</strong>，相反，使用多线程还需要考虑高并发情况下的线程安全问题，以及各种不必要的上下文切换，影响效率。</p>
<p><strong>Redis 为什么快？</strong></p>
<ul>
<li>Redis是基于C语言编写，是基于内存操作，执行速度非常快。</li>
<li>采用单线程，避免不必要的上下文切换，多线程还需要考虑线程安全问题。</li>
<li>使用了I&#x2F;O多路复用模型，非阻塞IO。</li>
</ul>
<h1 id="I-O多路复用模型"><a href="#I-O多路复用模型" class="headerlink" title="I&#x2F;O多路复用模型"></a>I&#x2F;O多路复用模型</h1><p>Redis是纯内存操作，执行速度非常快，它的<strong>性能瓶颈是网络延迟和内存，而不是执行速度</strong>，<strong>I&#x2F;O多路复用模型主要就是实现了高效的网络请求。</strong></p>
<ul>
<li><strong>阻塞IO：用户区进程在“内核区准备数据”和“拷贝数据”两个阶段都处于阻塞状态。</strong></li>
<li><strong>非阻塞IO：第一个阶段是非阻塞，第二阶段阻塞。虽然是非阻塞，但都是忙等，没有提高性能，还会使CPU空转，使用率暴涨。</strong></li>
<li><strong>IO多路复用：是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</strong><ul>
<li><strong>监听Socket的方式：</strong><ul>
<li><strong>select：</strong> 轮询监听各个Socket，监听个数上限为1024。</li>
<li><strong>poll：</strong> 也要轮询监听，但是监听上限大于select方法。</li>
<li><strong>epoll：</strong> 不必轮询监听，当socket准备好了通知一下即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>redis使用<strong>I&#x2F;O多路复用</strong>结合<strong>事件的处理器</strong>来应对多个Socket请求，</p>
<ul>
<li><strong>连接应答处理器</strong></li>
<li><strong>命令回复处理器</strong>，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</li>
<li><strong>命令请求处理器</strong>，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程。</li>
</ul>
<p><img src="/2024/08/05/Redis%E7%AF%87/1.png"></p>
<h1 id="什么是大Key问题？如何解决？"><a href="#什么是大Key问题？如何解决？" class="headerlink" title="什么是大Key问题？如何解决？"></a>什么是大Key问题？如何解决？</h1><p>BigKey的具体表现是Redis中的key对应的value很大，占用的redis空间比较大，本质上是大value问题。在读取大key的时候，由于读取的内容较多，占用较大的带宽，造成网络带宽的阻塞。 解决方案：</p>
<ul>
<li><strong>针对BigKey进行拆分：</strong> 将大key拆分成多个小key的键值对，读取的时候使用mget批量读取。</li>
<li><strong>压缩对应BigKey的value</strong>：可以通过序列化等方法对value进行压缩，使其变为较小的value。</li>
<li><strong>清理无效的数据</strong>：主要是针对像是<strong>list</strong>和<strong>set</strong>这种类型，在使用的过程中，<strong>list</strong>和<strong>set</strong>中对应的内容不断增加，需要定时的对list和set进行清理。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2024/08/02/MySQL%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="常规："><a href="#常规：" class="headerlink" title="常规："></a>常规：</h1><h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><ul>
<li><strong>1NF</strong> : 表中字段的数据不可再拆分。(原子性)</li>
<li><strong>2NF</strong> : 在满足第一范式的情况下，遵循唯一性，消除部分依赖。即，表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。(一个表只能描述一件事情)</li>
<li><strong>3NF</strong> : 在满足第二范式的情况下，消除传递依赖。即，在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。<span id="more"></span></li>
</ul>
<h2 id="主键和外键的区别？"><a href="#主键和外键的区别？" class="headerlink" title="主键和外键的区别？"></a>主键和外键的区别？</h2><ul>
<li><strong>主键：唯一标识一条记录。不能有重复的，不允许为空 。</strong></li>
<li><strong>外键：表的外键是另一表的主键, 用于和其他表建立联系。外键可以有重复的, 可以是空值。</strong></li>
</ul>
<h2 id="CHAR-和-VARCHAR-的区别是什么？"><a href="#CHAR-和-VARCHAR-的区别是什么？" class="headerlink" title="CHAR 和 VARCHAR 的区别是什么？"></a>CHAR 和 VARCHAR 的区别是什么？</h2><p>**        两者的主要区别在于：CHAR 是定长字符串，VARCHAR 是变长字符串。**</p>
<ul>
<li><strong>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。</strong></li>
<li><strong>VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</strong></li>
</ul>
<h2 id="DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a>DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h2><p>DECIMAL 和 FLOAT 的区别是：</p>
<ul>
<li><strong>DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。</strong></li>
<li><strong>DECIMAL 可以存储精确的小数值，FLOAT&#x2F;DOUBLE 只能存储近似的小数值。</strong></li>
</ul>
<h2 id="NULL-和-‘-‘-的区别是什么？"><a href="#NULL-和-‘-‘-的区别是什么？" class="headerlink" title="NULL 和 ‘ ‘ 的区别是什么？"></a>NULL 和 ‘ ‘ 的区别是什么？</h2><ul>
<li><strong>类型</strong>：null表示的是一个对象的值，而非一个字符串，而””表示的是一个长度为0的空字符串。</li>
<li><strong>内存分配</strong>：null不分配内存空间;而””会分配内存空间。 如：<ul>
<li>String aaa &#x3D; null ; 表示声明一个字符串对象的引用，但指向为null（未指向任何的内存空间）；</li>
<li>String bbb &#x3D; “”;表示声明一个字符串类型的引用，其值为””空字符串（指向空字符串的内存空间）；</li>
</ul>
</li>
<li>查询 NULL 值时，必须使用 IS NULL 或 IS NOT NULL 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而’’是可以使用这些比较运算符的。</li>
</ul>
<h2 id="Boolean-类型如何表示？"><a href="#Boolean-类型如何表示？" class="headerlink" title="Boolean 类型如何表示？"></a><a href="https://so.csdn.net/so/search?q=Boolean&spm=1001.2101.3001.7020">Boolean</a> 类型如何表示？</h2><p>MySQL 中没有专门的布尔<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">类型</a>，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</p>
<h2 id="MySQL-基础架构及执行过程-⭐执行一条select语句期间发生了什么"><a href="#MySQL-基础架构及执行过程-⭐执行一条select语句期间发生了什么" class="headerlink" title="MySQL 基础架构及执行过程(⭐执行一条select语句期间发生了什么)"></a>MySQL 基础架构及执行过程(⭐执行一条select语句期间发生了什么)</h2><p><img src="/2024/08/02/MySQL%E7%AF%87/1.png"><br>** MySQL 的架构共分为两层：Server 层和存储引擎层：**</p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。<strong>MySQL 大多数的核心功能模块都在这实现</strong>，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的<strong>内置函数</strong>（如日期、时间、数学和加密函数等）和<strong>所有跨存储引擎的功能</strong>（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。<strong>我们常说的索引数据结构，就是由存储引擎层实现的</strong>，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树。</li>
</ul>
<p><strong>一条SQL查询语句的执行过程：</strong></p>
<ul>
<li><strong>连接器</strong>： 包括TCP三次握手、身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存</strong>： 执行查询语句的时候，会先查询缓存（由于每次更新操作都会删除所有缓存，因此缓存功能较为鸡肋，在MySQL 8.0 版本后移除）。</li>
<li><strong>解析器</strong>： 没有命中缓存的话，SQL 语句就会经过解析器，通过<strong>词法分析</strong>识别出关键字、表名等，构建出<strong>语法树</strong>，接着再做<strong>语法分析</strong>判断语句是否符合MySQL语法。</li>
<li><strong>优化器</strong>： 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器</strong>： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>
<li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>
</ul>
<h2 id="MySQL-存储引擎MyISAM-和-InnoDB-有什么区别？（⭐）"><a href="#MySQL-存储引擎MyISAM-和-InnoDB-有什么区别？（⭐）" class="headerlink" title="MySQL 存储引擎MyISAM 和 InnoDB 有什么区别？（⭐）"></a>MySQL 存储引擎MyISAM 和 InnoDB 有什么区别？（⭐）</h2><p>MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。</p>
<pre><code>    MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎，之前默认存储引擎是MyISAM，两者区别如下：
</code></pre>
<ul>
<li><strong>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</strong></li>
<li><strong>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</strong><ul>
<li>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别，并可以解决幻读问题（基于 MVCC 和 Next-Key Lock）。</li>
</ul>
</li>
<li><strong>MyISAM 不支持外键，而 InnoDB 支持。</strong></li>
<li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li>
<li>MyISAM 和 InnoDB 都使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>InnoDB 的性能比 MyISAM 更强大。<blockquote>
<p><strong>MyISAM引擎和InnoDB引擎的使用场景：</strong><br><strong>MyISAM</strong>：适用于以<strong>读数据为主、低并发、不需要事务支持</strong>的业务场景。<br><strong>InnoDB</strong>：适用于<strong>需要经常修改数据、高并发、需要事务支持</strong>的业务场景。</p>
</blockquote>
</li>
</ul>
<h2 id="事务的四大特性（⭐）"><a href="#事务的四大特性（⭐）" class="headerlink" title="事务的四大特性（⭐）"></a>事务的四大特性（⭐）</h2><ul>
<li><strong>原子性</strong>(Atomicity)：事务是一个不可分割的工作单位，事务内的操作要么全部执行成功，要么全部回滚。</li>
<li><strong>一致性</strong>(Consistency)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li>
<li><strong>隔离性</strong>(Isolation)：一个事务所做的修改操作在提交之前，对于其他事务来说是不可见的。</li>
<li><strong>持久性</strong>(Durability)：事务一旦被提交，它对数据库中数据的改变就是永久性的。<blockquote>
<p>   <strong>redo log保证了持久性，undo log保证了原子性，锁和MVCC机制保证了隔离性，三者共同保证了一致性。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="MySQL事务隔离级别（⭐）"><a href="#MySQL事务隔离级别（⭐）" class="headerlink" title="MySQL事务隔离级别（⭐）"></a>MySQL事务隔离级别（⭐）</h2><p>事务隔离要实际解决的问题：</p>
<ul>
<li><strong>脏读</strong>：读了其他事务未提交的数据。</li>
<li><strong>不可重复读</strong>：同一事务先后读取同一条<strong>记录</strong>，但两次读取的数据不同。</li>
<li><strong>幻读</strong>：在一个事务中，两次查询返回的数据<strong>结果集</strong>不同，通常是针对插入语句的。</li>
</ul>
<p><img src="/2024/08/02/MySQL%E7%AF%87/2.png"><br>**        <strong>数据库事务隔离级别分为四个等级,分别为 : <strong>读未提交</strong>( read-uncommitted)、</strong>读已提交(<strong>read committed)、</strong>可重复读**(repeatable read)、<strong>串行序列化</strong>(serializable)。</p>
<ul>
<li>对于<strong>「读未提交」</strong>隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于<strong>「串行化」</strong>隔离级别的事务来说，通过加读写锁的方式来避免并行访问；<strong>在读写数据时会锁住整张表，效率比较低，因此innodb引擎默认级别为可重复读。</strong></li>
<li>对于<strong>「读已提交」</strong>和<strong>「可重复读」</strong>隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li>
</ul>
<p><strong>重点说一下「读已提交」和「可重复读」是如何实现的？</strong><br>首先这俩个隔离级别都是通过 <strong>Read View <strong>实现的，</strong>Read View</strong>是一个快照文件，记录了四个和事务有关的字段，如下图：<br><img src="/2024/08/02/MySQL%E7%AF%87/3.png"><br>还有两个隐藏字段：<strong>事务id（创建这条记录的事务id）、回滚指针（指向该记录的旧版本）</strong>，如下图：<br><img src="/2024/08/02/MySQL%E7%AF%87/4.png"><br><strong>「读已提交」：</strong><br><strong>RC 隔离级别只会读到别的事务提交的数据，但是存在不可重复读的问题，即在同一事务中，由于别的事务提交了数据，导致前后两次读的数据不一致。下面说说为什么会这样：</strong><br>RC 隔离级别每次读取数据都会生成一个新的<strong>Read view</strong>，该快照文件里头有一个字段会记录<strong>当前活跃的事务id集合</strong>，<strong>RC 隔离级别会判断当前这条记录的事务id是否存在于集合当中，若存在，说明这条记录是还未提交过的事务修改的，这时就不会读这个版本的记录，而是沿着undo log 找到旧版本的记录； 若不存在，说明修改这条记录的事务已经提交了，这时就可以读取这条记录</strong>。 <strong>由于RC每次读取数据都会生成新的read view，因此中途别的事务提交了的数据是会被读到的，因此有不可重复读的问题</strong>。<br><strong>「可重复读」：</strong><br>启动事务时生成一个 <strong>Read View</strong>，然后<strong>整个事务期间都在用这个 Read View</strong>，这样就保证了在事务期间读到的数据都是事务启动前的记录。</p>
<h3 id="可重复读又是如何解决幻读问题的？"><a href="#可重复读又是如何解决幻读问题的？" class="headerlink" title="可重复读又是如何解决幻读问题的？"></a>可重复读又是如何解决幻读问题的？</h3><p>采用<strong>锁+MVCC</strong>机制解决。<br><strong>针对当前读：</strong>读取的是最新的数据，使用<strong>next-key lock（记录锁+间隙锁）</strong>的方式解决幻读问题。当在执行读操作时，会加上 next-key lock，此时如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。<br><strong>针对（普通读）快照读：</strong>普通的 select 语句，采用<strong>mvcc机制</strong>解决幻读问题，并不会对记录加锁。 </p>
<h2 id="解释一下-undo-log、redo-log-和-bin-log"><a href="#解释一下-undo-log、redo-log-和-bin-log" class="headerlink" title="解释一下 undo log、redo log 和 bin log"></a>解释一下 undo log、redo log 和 bin log</h2><ul>
<li><strong>redo log（重做日志）：</strong>是 <strong>Innodb 存储引擎层</strong>生成的日志，实现了事务中的<strong>持久性</strong>，主要用于<strong>数据库故障的数据恢复</strong>；</li>
<li><strong>undo log（回滚日志）：</strong>是 <strong>Innodb 存储引擎层</strong>生成的日志，实现了事务中的<strong>原子性，主要用于事务回滚和 MVCC。</strong></li>
<li><strong>binlog （归档日志）</strong>：是 <strong>Server 层</strong>生成的日志，主要<strong>用于数据备份和主从复制</strong>。</li>
</ul>
<p><strong>redo log 和 bin log有什么区别？</strong></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；redo log 是 Innodb 存储引擎实现的日志；</li>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志；redo log 是循环写，日志空间大小是固定，日志文件写满了MySQL就会发生阻塞。</li>
</ul>
<p><strong>为什么需要redo log？</strong><br>首先要知道innodb存储引擎中提供了<strong>缓冲池（Buffer Pool）</strong>来提高数据库的读写性能：</p>
<ul>
<li>当读取数据时，如果数据存在于** Buffer Pool **中，客户端就会直接读取 Buffer Pool 中的数据。</li>
<li>当修改数据时，如果数据存在于** Buffer Pool **中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li>
</ul>
<p>但是问题来了，<strong>Buffer Pool <strong>是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</strong>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了</strong>。</p>
<h2 id="事务中的隔离性是如何保证的呢？（⭐）"><a href="#事务中的隔离性是如何保证的呢？（⭐）" class="headerlink" title="事务中的隔离性是如何保证的呢？（⭐）"></a>事务中的隔离性是如何保证的呢？（⭐）</h2><p><strong>事务的隔离性是由锁和mvcc实现的。</strong><br>**        <strong>mvcc的意思是</strong>多版本并发控制<strong>。</strong>指维护一个数据的多个版本，使得读写操作没有冲突**，它的底层实现主要分为三个部分：</p>
<ul>
<li><strong>隐藏字段：</strong><ul>
<li>**trx_id(事务id)**：记录每一次操作的事务id，是自增的。</li>
<li>**roll_pointer(回滚指针)**：指向上一个事务版本的地址。</li>
</ul>
</li>
<li><strong>undo log：</strong><ul>
<li>回滚日志，存储老版本数据，形成一条版本链。</li>
<li>版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表。</li>
</ul>
</li>
<li><strong>readView</strong>：解决的是一个事务查询选择版本的问题。<ul>
<li>根据readView的匹配规则和当前的一些事务id判断该访问哪个版本的数据。</li>
<li>不同的隔离级别快照读也不一样，最终的访问的结果不一样：<ul>
<li>RC（读已提交） ：每一次执行快照读时生成ReadView。</li>
<li>RR（可重复读）：仅在事务中第一次执行快照读时生成ReadView，后续复用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="MySQL主从同步原理（⭐）"><a href="#MySQL主从同步原理（⭐）" class="headerlink" title="MySQL主从同步原理（⭐）"></a>MySQL主从同步原理（⭐）</h2><pre><code>    MySQL主从复制的核心就是**二进制日志（binlog）**，里面记录了所有DDL和DML语句。
</code></pre>
<ul>
<li>主库在事务提交时，会将数据变更记录在binlog中。</li>
<li>从库读取主库的binlog，写入从库的中继日志Relay log中。</li>
<li>从库读取中继日志，写入到自己的数据库中。</li>
</ul>
<h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><blockquote>
<p>drop&gt; truncate &gt;delete</p>
</blockquote>
<p><strong>delete：用于删除表中的行，并且保留表结构，删除的行可以通过回滚日志回滚。</strong><br><strong>truncate ：TRUNCATE 用于删除表中的所有数据，但保留表的结构。</strong><br><strong>drop：DROP 用于删除整个表（包括表的结构和数据）。</strong></p>
<h2 id="什么是视图？"><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h2><pre><code>    **视图是一个表或多个表的查询子集，其作用是方便用户对数据的操作。**
</code></pre>
<ul>
<li><strong>简单</strong>：视图可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li>
<li><strong>安全性</strong>：通过视图，用户只能查询和修改指定的数据，这样可以防止敏感信息被未授权的用户查看，增强机密信息的安全性。</li>
</ul>
<h2 id="MySQL的表级锁和行级锁（⭐）"><a href="#MySQL的表级锁和行级锁（⭐）" class="headerlink" title="MySQL的表级锁和行级锁（⭐）"></a>MySQL的表级锁和行级锁（⭐）</h2><pre><code>    **MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性能非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。**
</code></pre>
<ul>
<li><strong>表级锁</strong>： MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。</li>
<li><strong>行级锁</strong>： MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。<ul>
<li><strong>记录锁</strong>（Record Lock）：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁</strong>（Gap Lock）：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁</strong>（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。<strong>记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</strong><blockquote>
<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="索引相关："><a href="#索引相关：" class="headerlink" title="索引相关："></a>索引相关：</h1><p><strong>扯①索引的作用（优缺点）+②存储引擎（底层数据结构）+③创建索引的原则</strong><br><strong>索引是一种用于快速查询和检索数据的数据结构，本质可以看成是一种排序好的数据结构。</strong><br>索引的优缺点：</p>
<ul>
<li><strong>优点：大大加快 数据的检索速度，降低数据库的IO成本。</strong></li>
<li><strong>缺点：创建索引和维护索引需要耗费大量时间，索引的存储也需要消耗一定的空间。</strong></li>
</ul>
<h2 id="索引的底层数据结构选型（⭐）"><a href="#索引的底层数据结构选型（⭐）" class="headerlink" title="索引的底层数据结构选型（⭐）"></a>索引的底层数据结构选型（⭐）</h2><pre><code>    索引底层数据结构存在很多种类型，常见的索引结构有:** B 树， B+树 和 Hash、红黑树**。在 MySQL 中，**无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。**
    下面分别介绍几种索引结构以及为什么要选择B+树做索引结构。
</code></pre>
<ul>
<li><p><strong>哈希表</strong>是键值对的集合，通过key可以快速地检索到对应的值，因此哈希表可以快速检索数据。然而，因为hash索引是精确查找，不支持范围查询，因此不使用hash作为索引结构。</p>
</li>
<li><p><strong>AVL树</strong>(平衡二叉查找树)解决了二叉查找树最坏情形退化成链表的情况，但是需要不断地旋转操作来保持树地平衡，I&#x2F;O磁盘操作次数较多。</p>
</li>
<li><p><strong>红黑树</strong>不和AVL树一样追求绝对平衡，只追求大致平衡，但因此红黑树的高度也会较高，检索数据时也需要较多的IO磁盘。</p>
</li>
<li><p><strong>B树</strong>，全称多路平衡查找树，B+ 树是 B 树的一种变体，二者区别如下：</p>
<ul>
<li><p>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他节点只存放 key，相当于索引。</p>
</li>
<li><p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
</li>
<li><p>B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>
<p>   <strong>选用B+树的主要原因:</strong></p>
</li>
</ul>
</li>
<li><p>阶数更多，路径更短。</p>
</li>
<li><p>磁盘读写代价 更低，非叶子节点只存储指针，叶子节点存储数据。</p>
</li>
<li><p>B+ 树便于扫库和区间查询，叶子节点是一个双向链表。</p>
</li>
</ul>
<h2 id="MySQL中，如何定位慢查询"><a href="#MySQL中，如何定位慢查询" class="headerlink" title="MySQL中，如何定位慢查询?"></a>MySQL中，如何定位慢查询?</h2><p>MySQL中也提供了<strong>慢日志查询</strong>的功能，可以在MySQL的系统配置文件中开启这个慢日志的功能，并且也可以设置SQL执行超过多少时间来记录到一个日志文件中。</p>
<h2 id="那这个SQL语句执行很慢-如何分析呢？"><a href="#那这个SQL语句执行很慢-如何分析呢？" class="headerlink" title="那这个SQL语句执行很慢, 如何分析呢？"></a>那这个SQL语句执行很慢, 如何分析呢？</h2><p>可以使用MySQL自带的explain来查看这条SQL语句的执行计划，如下图：<br><img src="/2024/08/02/MySQL%E7%AF%87/5.png"><br>可以从以下三个方面进行分析：</p>
<ul>
<li>通过key和key_len检查是否命中了索引。</li>
<li>通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描。<ul>
<li>type 性能由好到差为：</li>
<li>system：查询系统中的表。</li>
<li>const：根据主键查询。</li>
<li>eq ref：主键索引查询或唯一索引查询。</li>
<li>ref：索引查询。</li>
<li>range：范围查询。</li>
<li>index：全索引扫描。</li>
<li>all：全盘扫描。</li>
</ul>
</li>
<li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。</li>
</ul>
<h2 id="什么是聚簇索引什么是非聚簇索引-（⭐）"><a href="#什么是聚簇索引什么是非聚簇索引-（⭐）" class="headerlink" title="什么是聚簇索引什么是非聚簇索引 ?（⭐）"></a>什么是聚簇索引什么是非聚簇索引 ?（⭐）</h2><ul>
<li><strong>聚簇索引</strong>（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个，一般是主键索引。</li>
<li><strong>非聚簇索引</strong>（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个。</li>
</ul>
<h2 id="什么是回表查询-（⭐）"><a href="#什么是回表查询-（⭐）" class="headerlink" title="什么是回表查询?（⭐）"></a>什么是回表查询?（⭐）</h2><p> <strong>通过二级索引找到对应的主键值，再通过主键值到聚集索引中查找整行数据的过程。</strong></p>
<h2 id="什么是覆盖索引-（⭐）"><a href="#什么是覆盖索引-（⭐）" class="headerlink" title="什么是覆盖索引?（⭐）"></a>什么是覆盖索引?（⭐）</h2><p><strong>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</strong></p>
<ul>
<li>使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</li>
<li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *</li>
</ul>
<h2 id="MYSQL超大分页怎么处理"><a href="#MYSQL超大分页怎么处理" class="headerlink" title="MYSQL超大分页怎么处理 ?"></a>MYSQL超大分页怎么处理 ?</h2><pre><code>    超大分页一般都是在数据量比较大时，我们使用了limit 分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决：
</code></pre>
<p>先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了。  由于查询id的时候走的覆盖索引，效率相对较高。        </p>
<h2 id="索引创建原则有哪些？（⭐）"><a href="#索引创建原则有哪些？（⭐）" class="headerlink" title="索引创建原则有哪些？（⭐）"></a>索引创建原则有哪些？（⭐）</h2><ul>
<li><strong>针对数据量较大，且查询比较频繁的表。(10w数据量)</strong></li>
<li><strong>针对常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</strong></li>
<li><strong>尽量使用联合索引，避免回表，提升效率。</strong></li>
<li><strong>控制索引的数量，索引越多，维护索引的成本越高，会影响到增删改的效率。</strong></li>
<li><strong>尽量选择区分度高的列作为索引。</strong></li>
<li>如果是字符串类型的字段作为索引，且字段较长，建立前缀索引。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。</li>
</ul>
<h2 id="什么情况下索引会失效-（⭐）"><a href="#什么情况下索引会失效-（⭐）" class="headerlink" title="什么情况下索引会失效 ?（⭐）"></a>什么情况下索引会失效 ?（⭐）</h2><ul>
<li><strong>违反最左前缀法则。（主要针对联合索引）</strong></li>
<li><strong>范围查询右边的列，不能使用索引 。</strong></li>
<li><strong>索引列上进行运算操作， 索引将失效。</strong></li>
<li><strong>字符串不加单引号，造成索引失效。(发生了类型转换)</strong></li>
<li><strong>以%开头的Like模糊查询，索引失效。（%结尾不会失效）</strong></li>
</ul>
<h2 id="谈一谈你对sql的优化的经验"><a href="#谈一谈你对sql的优化的经验" class="headerlink" title="谈一谈你对sql的优化的经验"></a>谈一谈你对sql的优化的经验</h2><ul>
<li><strong>表的设计优化。</strong><ul>
<li>如设置合适的数值类型（int、bigint、tinyint），字符串类型（char、varchar）</li>
</ul>
<p>		</p>
</li>
<li><strong>索引优化：索引创建原则、避免索引失效。</strong><ul>
<li>见以上第8、9点。</li>
</ul>
</li>
<li><strong>SQL语句优化。</strong><ul>
<li><strong>如：select语句指明具体字段，尽量避免使用select * ，防止回表查询。</strong></li>
<li><strong>SQL语句尽量避免造成索引失效的写法。</strong></li>
<li><strong>尽量用union all代替union，union会去重，多一次过滤操作，效率低。</strong></li>
<li><strong>Join优化 能用inner join 就不用left join right join，如必须使用 一定要以小表为驱动。</strong></li>
</ul>
</li>
<li><strong>主从复制、读写分离。</strong><ul>
<li>数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。</li>
</ul>
</li>
<li><strong>分库分表。</strong></li>
</ul>
<h2 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h2><p>现在，几乎所有的系统都支持邮箱登录，那么如何在邮箱这样的字段上建立合理的索引呢？<br><strong>MySQL 是支持前缀索引的</strong>，因此给邮箱字段添加索引有两种方法：</p>
<ul>
<li><strong>定义字符串的一部分作为索引。</strong><ul>
<li><strong>占用空间更小，但是可能会增加额外的扫描次数，影响性能。</strong></li>
</ul>
</li>
<li><strong>定义整个字符串作为索引。</strong><ul>
<li><strong>占用空间较大，但是只要扫描一次。</strong></li>
</ul>
</li>
</ul>
<p><strong>sql语句：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index <span class="title function_">index1</span><span class="params">(email)</span>;</span><br><span class="line">或</span><br><span class="line">mysql&gt; alter table SUser add index <span class="title function_">index2</span><span class="params">(email(<span class="number">6</span>)</span>);</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>技术</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2024/08/02/%E9%9B%86%E5%90%88%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div style="text-align: center; font-size: 24px;">
<b>  集合总体框架图：  </b>
</div>

<p><img src="/2024/08/02/%E9%9B%86%E5%90%88%E7%AF%87/1.png"></p>
<h1 id="单列集合汇总"><a href="#单列集合汇总" class="headerlink" title="单列集合汇总"></a>单列集合汇总</h1><h2 id="List-Set-Queue-Map-的区别"><a href="#List-Set-Queue-Map-的区别" class="headerlink" title="List, Set, Queue, Map 的区别"></a>List, Set, Queue, Map 的区别</h2><ul>
<li>List：底层基于object[]数组，存储的元素有序、可重复。</li>
<li>Set：底层基于HashMap实现，存储的元素无序，不可重复。</li>
<li>Queue：单端队列，存储的元素有序、可重复。</li>
<li>Map：使用键值对（key-value）存储，key 是无序的、不可重复的。<span id="more"></span></li>
</ul>
<h2 id="HashSet、LinkedHashSet-和-TreeSet-的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 的异同"></a>HashSet、LinkedHashSet 和 TreeSet 的异同</h2><p><strong>三者都是Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</strong><br>三者主要区别在于底层实现的数据结构不同：</p>
<ul>
<li>HashSet底层基于哈希表，元素无序，不可重复。</li>
<li>LinkedHashSet底层基于链表和哈希表，元素具有唯一性和有序性(元素顺序满足FIFO)</li>
<li>TreeSet底层基于红黑树，支持对元素自定义排序规则。</li>
</ul>
<h2 id="ArrayList-和-Array（数组）的区别？"><a href="#ArrayList-和-Array（数组）的区别？" class="headerlink" title="ArrayList 和 Array（数组）的区别？"></a>ArrayList 和 Array（数组）的区别？</h2><ul>
<li>Array的大小固定；ArrayList可以动态扩容。</li>
<li>ArrayList允许使用泛型确保类型安全；Array不行。</li>
<li>ArrayList具备基本的增删改查操作；Array只能下标进行查询，没有动态增删改元素的能力。</li>
<li>Array既可以存储基本数据类型也可以存储对象；ArrayList只能存储对象，对于基本数据类型，需要将其转化为对应的包装类。</li>
</ul>
<h2 id="ArrayList-与-LinkedList-区别-（⭐）"><a href="#ArrayList-与-LinkedList-区别-（⭐）" class="headerlink" title="ArrayList 与 LinkedList 区别?（⭐）"></a>ArrayList 与 LinkedList 区别?（⭐）</h2><ul>
<li><strong>底层数据结构</strong>：ArrayList底层使用object[]数组，LinkedList底层使用双向链表。</li>
<li><strong>是否支持快速随机访问</strong>：ArrayList支持，LinkedList不支持。</li>
<li><strong>插入和删除是否受元素位置的影响</strong>：<ul>
<li>ArrayList添加元素时默认添加至列表尾部，此时时间复杂度为O(1)；但如果在指定位置添加和删除元素时，时间复杂度为O(n)。</li>
<li>LinkedList在头尾插入和删除时时间复杂度为O(1)；但如果在指定位置插入删除元素时间复杂度为O(n)。</li>
</ul>
</li>
</ul>
<h2 id="ArrayList底层及扩容机制（⭐）"><a href="#ArrayList底层及扩容机制（⭐）" class="headerlink" title="ArrayList底层及扩容机制（⭐）"></a>ArrayList底层及扩容机制（⭐）</h2><p><strong>ArrayList三个构造函数：</strong></p>
<ul>
<li>ArrayList() 默认创建长度为0的数组。</li>
<li>ArrayList(int initialCapacity) 创建指定容量的数组。</li>
<li>ArrayList(Collection&lt;? extends E&gt; c) 使用集合c的大小作为数组容量。</li>
</ul>
<p><strong>ArrayList底层实现：</strong></p>
<ul>
<li><strong>底层数据结构：</strong>	<ul>
<li>底层采用动态数组object[]实现。</li>
</ul>
</li>
<li><strong>初始容量：</strong><ul>
<li>ArrayList初始容量为0，第一次添加数据时扩容为10。</li>
</ul>
</li>
<li><strong>扩容逻辑：</strong><ul>
<li>首先会创建一个新的数组，长度为原始数组的1.5倍(使用位运算)，然后使用Arrays.copy方法将老数组的元素copy到新数组中，再将需要添加的新元素添加到新数组中。<blockquote>
<p>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h2><pre><code>  Comparable和Comparator都是接口，都可以用来进行比较、排序，可以将Comparable理解为“内部比较器”，Comparator理解为“外部比较器”。
</code></pre>
<ul>
<li><strong>实现方式：</strong><ul>
<li>Comparable可以直接在需要进行排序的实体类中实现，重写compateTo方法即可。</li>
<li>Comparator需要另外创建一个实现Comparator接口的实现类来作为“比较器”，并在排序时将比较器作为参数传入。</li>
</ul>
</li>
<li><strong>各自的优缺点：</strong><ul>
<li>Comparable 实现比较简单，但是需要修改源代码。</li>
<li>Comparator需要新建比较器类，较为复杂，但是不需要修改源代码，并且新建的比较器类可以供多个对象排序使用。</li>
</ul>
</li>
</ul>
<p>具体参考这篇文章<a href="https://blog.csdn.net/qq_45559536/article/details/106091870">https://blog.csdn.net/qq_45559536&#x2F;article&#x2F;details&#x2F;106091870</a></p>
<h2 id="ArrayList-list-new-ArrayList-10-中的list扩容几次"><a href="#ArrayList-list-new-ArrayList-10-中的list扩容几次" class="headerlink" title="ArrayList list&#x3D;new ArrayList(10) 中的list扩容几次"></a>ArrayList list&#x3D;new ArrayList(10) 中的list扩容几次</h2><p><strong>该语句声明和实例了一个 ArrayList，指定了容量为 10，未进行扩容。</strong></p>
<h2 id="如何实现数组和List之间的转换"><a href="#如何实现数组和List之间的转换" class="headerlink" title="如何实现数组和List之间的转换"></a>如何实现数组和List之间的转换</h2><ul>
<li>数组转List：使用Arrays工具类的asList方法。</li>
<li>List转数组：使用List的toArray方法。</li>
</ul>
<p>数组转List后，如果修改了数组内容，list受影响吗？</p>
<ul>
<li><strong>受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，会传入数组对象的引用。</strong></li>
</ul>
<p>List转数组后，如果修改了List内容，数组受影响吗？</p>
<ul>
<li><strong>不受影响，调用toArray方法之后，底层会进行数组的拷贝，和原来List的元素就没关系了。</strong></li>
</ul>
<h1 id="双列集合汇总"><a href="#双列集合汇总" class="headerlink" title="双列集合汇总"></a>双列集合汇总</h1><h2 id="HashMap底层原理（⭐）"><a href="#HashMap底层原理（⭐）" class="headerlink" title="HashMap底层原理（⭐）"></a>HashMap底层原理（⭐）</h2><p>   关键点：<strong>①底层数据结构 ②工作方式</strong><br>        HashMap是一个集合了查询效率和增删效率的容器，内部存的都是一个个键值对，可以通过访问键值对其进行访问和修改。</p>
<ul>
<li>在jdk1.8以前：<ul>
<li>HashMap底层采用<strong>数组+链表</strong>的结构。</li>
<li>添加数据时，会计算key值对应的哈希值，以定位key存放的位置，然后判断该位置的key是否相同，相同则直接覆盖；不相同即发生哈希冲突，会采用头插法将元素插入链表中。</li>
</ul>
</li>
<li>从jdk1.8之后：<ul>
<li>HashMap底层采用**<strong>红黑树</strong>的结构，发生哈希冲突时采用尾插法将元素插入链表中，并且当链表长度大于阈值(默认为8)时，数组长度大于64时，会将链表改为红黑树进行存储。</li>
<li>红黑树是一种<strong>自平衡二叉搜索树</strong>，其查找和插入操作的时间复杂度均为 O(log n)。<blockquote>
<p><strong>红黑树相比avl树，在检索的时候效率会略微差一点点，但对于插入和删除操作效率会提高很多。因为红黑树不像avl树一样追求绝对的平衡，它允许一些局部的不完全平衡，减少了很多调平衡的操作。相当于牺牲了一点点查询的性能，大大提高了插入和删除的性能。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="HashMap-中-hash-值的作用？"><a href="#HashMap-中-hash-值的作用？" class="headerlink" title="HashMap 中 hash 值的作用？"></a>HashMap 中 hash 值的作用？</h2><pre><code> **HashMap 中的 hash 值是由hash函数产生的，所有键值对存放的位置都是由 hash值和(length-1) 与运算得到的(length必须为2的幂次方，此时与运算等价于对length-1取模)。因此，简单来说hash值就是用来定位某键值对在HashMap中存放的位置的。**
</code></pre>
<h2 id="HashMap-中的数组长度为什么必须是-2-的幂次方？"><a href="#HashMap-中的数组长度为什么必须是-2-的幂次方？" class="headerlink" title="HashMap 中的数组长度为什么必须是 2 的幂次方？"></a>HashMap 中的数组长度为什么必须是 2 的幂次方？</h2><p> <strong>length</strong>为2的幂次方可以确保**(length-1)<strong>的二进制低位都是1，此时</strong>hash&amp;(length-1) **等价于 <strong>hash%(length-1)</strong> ，并且位运算的效率较高。</p>
<h2 id="JDK-1-7中HashMap-为什么会形成死循环？"><a href="#JDK-1-7中HashMap-为什么会形成死循环？" class="headerlink" title="JDK 1.7中HashMap 为什么会形成死循环？"></a>JDK 1.7中HashMap 为什么会形成死循环？</h2><p>JDK 1.7中在链表中添加元素的方式是<strong>头插法</strong>，<strong>当两个线程同时对HashMap进行扩容操作时，可能会形成环形链表，产生死循环</strong>。JDK 1.7中采用了<strong>尾插法</strong>来避免链表导致，从而避免产生环形链表。<br>        具体来说：HashMap扩容时，会将旧HashMap的数据移植到 扩容的新HashMap中，而由于链表的插入方式是头插法，a-&gt;b-&gt;c 会变成 c-&gt;b-&gt;a ，旧线程仍然认为a节点后面是b，而b节点后面已经是a了，这里就会产生死循环。</p>
<h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ul>
<li><p><strong>线程安全与效率：</strong></p>
<ul>
<li>HashMap线程不安全，但效率相对较高。</li>
<li>Hashtable线程安全，效率相对较低。</li>
</ul>
</li>
<li><p><strong>对 Null 的支持：</strong></p>
<ul>
<li>HashMap可以存储null值，键只能存一个(对应的key为0)，值可以存多个。</li>
<li>Hashtable不可以存储null键和null值。</li>
</ul>
</li>
<li><p><strong>初始容量大小和每次扩容大小：</strong></p>
<ul>
<li><strong>不指定容量：</strong><ul>
<li>HashMap默认初始化大小为 16，之后每次扩充，容量变为原来的 2 倍。</li>
<li>Hashtable默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。</li>
</ul>
</li>
<li><strong>指定容量：</strong><ul>
<li>HashMap会将指定容量扩充为 2 的幂次方大小，即HashMap总是使用 2 的幂作为哈希表的大小。</li>
<li>Hashtable直接使用指定的容量。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>扩容方式不同：</strong>当容量不足时要进行resize方法，而resize有两个步骤：</p>
<ul>
<li>①扩容：两者扩容大小不一样。</li>
<li>②rehash：两者都会重新计算hash值，而两者计算hash的值的方式也不同。(如下代码)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hashMap计算hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//而hashtable直接使用hashcode值作为最终的hash值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>底层数据结构：</strong></p>
<ul>
<li>JDK1.8 以后的 HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时 ，将链表转化为红黑树以减少搜索时间。</li>
<li>Hashtable只使用链表解决哈希冲突。</li>
</ul>
</li>
</ul>
<h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h2><p> <strong>当我们将对象加入HashSet时，HashSet会计算该对象的hashcode值，并与HashSet中其他对象作比较：若没有hashcode相同的对象，则该对象不重复，允许加入；若有hashcode相同的对象，还需要使用equals()方法检查两对象是否真的相同，如果相同则不允许加入该对象。</strong><br>ps：<strong>hashcode是某个对象的哈希值，相同对象的hashcode值一定相同，不同对象的hashcode值也有可能相同(即哈希冲突)。</strong></p>
<h2 id="HashMap-为什么线程不安全？"><a href="#HashMap-为什么线程不安全？" class="headerlink" title="HashMap 为什么线程不安全？"></a>HashMap 为什么线程不安全？</h2><p>jdk1.8之前HashMap存在<strong>死循环</strong>和<strong>数据丢失</strong>的问题。而数据丢失是所有版本都存在的问题，主要是<strong>由于并发情况下多线程同时进行put操作，并发生了哈希冲突，此时线程A在判断完哈希冲突之后阻塞了，线程B将数据插入，然后线程B苏醒之后就会将线程A的数据覆盖掉。</strong></p>
<h2 id="HashMap-常见的遍历方式"><a href="#HashMap-常见的遍历方式" class="headerlink" title="HashMap 常见的遍历方式?"></a>HashMap 常见的遍历方式?</h2><p>主要有四种遍历方式：</p>
<ul>
<li><p>使用迭代器（Iterator）的方式进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用迭代器（Iterator）EntrySet 的方式进行遍历.</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用迭代器（Iterator）KeySet 的方式进行遍历；</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator1 = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">    System.out.println(map.get(next));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 For Each的方式进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 For Each EntrySet 的方式进行遍历；</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用 For Each KeySet 的方式进行遍历；</span></span><br><span class="line"><span class="keyword">for</span>(Integer key:map.keySet())&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Lambda 表达式的方式进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Streams API 的方式进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry)-&gt;&#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从性能上来说，<strong>迭代器是遍历是最快的，使用entryset比使用keyset要快</strong>。</p>
</li>
</ul>
<h2 id="ConcurrentHashMap-和-Hashtable-的区别（⭐）"><a href="#ConcurrentHashMap-和-Hashtable-的区别（⭐）" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别（⭐）"></a>ConcurrentHashMap 和 Hashtable 的区别（⭐）</h2><p><strong>实现线程安全的方式不一样：</strong></p>
<ul>
<li>Hashtable几乎在所有添加、删除等方法都加了<strong>synchronized同步锁</strong>，相当于给哈希表加了一个大锁，<strong>多线程访问的时候，大量线程会被阻塞，效率低下</strong>。</li>
<li>jdk1.8之前的ConcurrentHashMap采用的是<strong>分段锁</strong>的思想，将哈希数组切割成若干个<strong>segment</strong>，每个<strong>segment</strong>包含n个键值对。 每一个segment都进行加锁，不同的segment不会有锁竞争，因此比Hashtable效率要高。</li>
<li>jdk1.8之后的ConcurrentHashMap锁粒度更细，没有采用分段锁的策略，而是<strong>在元素的节点上采用 CAS + synchronized 操作来保证并发的安全性</strong>，仅在链表或红黑树的首节点进行加锁，只要hash值不冲突，就不会产生并发，大大提高了效率。</li>
</ul>
<h2 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有何不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有何不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有何不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有何不同？</h2><ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7采用分段锁，JDK 1.8锁粒度更细，对每个链表或红黑树的头节点加锁。</li>
<li><strong>Hash 碰撞解决方法</strong>：JDK 1.7采用拉链法(头插法)，JDK 1.8采用拉链法(尾插法)+红黑树。</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<h2 id="HashMap的put的具体流程。"><a href="#HashMap的put的具体流程。" class="headerlink" title="HashMap的put的具体流程。"></a>HashMap的put的具体流程。</h2><ul>
<li>判断键值对数组是否为空，是的话就执行resize()方法进行扩容。</li>
<li>根据键值key计算hash值得到数组索引。</li>
<li>判断索引位置是否为空，是的话直接新建节点进行添加；不为空的话，判断索引位置的首个元素是否和key一样，一样就直接覆盖，不一样则：<ul>
<li>判断索引位置是否为treenode，即判断是否是红黑树，如果是红黑树，直接在树中插入键值对。</li>
<li>遍历链表，如果链表长度大于8就转成红黑树，在树中执行插入操作；如果不是大于8，就在链表中执行插入；在遍历过程中判断key是否存在，存在就直接覆盖对应的value值。</li>
</ul>
</li>
<li>最后插入成功后，判断存在的键值对数量是否超过阈值，超过了需要进行扩容。</li>
</ul>
<h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><ul>
<li>在初始化或元素达到阈值时，需要调用resize函数进行扩容，第一次数组长度初始化为16，扩容阈值为12(数组长度*0.75)，每次扩容扩大为原来的两倍。</li>
<li>扩容之后会创建一个新数组，遍历老数组，将元素移到新数组中：<ul>
<li>当前节点没有哈希冲突，直接对新数组的长度做模运算，插入当前节点。</li>
<li>如果是红黑树，直接走红黑树的添加逻辑。</li>
<li>如果是链表，需要遍历链表，(可能需要拆分链表)，链表元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上。</li>
</ul>
</li>
</ul>
<h2 id="hashMap的寻址算法"><a href="#hashMap的寻址算法" class="headerlink" title="hashMap的寻址算法"></a>hashMap的寻址算法</h2><ul>
<li>先计算对象的<strong>哈希值</strong>，再进行<strong>二次哈希</strong>，即将哈希值右移16位再进行<strong>异或运算</strong>，可以<strong>使哈希分布更加均匀</strong>。</li>
<li>最后使用与运算**( (capacity-1)  &amp; hash))**得到对象的索引。</li>
</ul>
<h2 id="LinkedHashMap-使用场景"><a href="#LinkedHashMap-使用场景" class="headerlink" title="LinkedHashMap 使用场景"></a>LinkedHashMap 使用场景</h2><p>HashMap有一个问题，就是<strong>迭代HashMap的顺序并不是HashMap放置的顺序</strong>，也就是无序。HashMap的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的Map。<br>LinkedHashMap 继承自 HashMap，实现了 Map 接口。<strong>它在HashMap的基础上维护了一个双向链表，并且按照插入顺序或者访问顺序来迭代元素。既保证了HashMap的快速访问性能，又提供了顺序访问的能力，因此在某些场景下非常有用。</strong><br>比如我实习期间有一个功能接口是要返回一个 {key &#x3D; 日期，value &#x3D; 发电量} 的 map 给前端，这些键值对是按照时间顺序添加进去的，我们希望它们在 map 中也是按照我们添加的顺序存放，所以这个场景下可以使用 **LinkedHashMap **来存。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="为什么数组的索引从0开始？"><a href="#为什么数组的索引从0开始？" class="headerlink" title="为什么数组的索引从0开始？"></a>为什么数组的索引从0开始？</h2><ul>
<li>数组在根据索引获取元素时，会使用寻址公式：<strong>数组首地址 + 索引 * 存储数据的类型大小</strong></li>
<li>如果索引从1开始算的话，寻址公式就变为：<strong>数组首地址 + （索引-1） * 存储数据的类型大小</strong>，底层多运算了一次减法操作，性能会降低。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2024/08/02/%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="java语言有哪些优点和缺点"><a href="#java语言有哪些优点和缺点" class="headerlink" title="java语言有哪些优点和缺点?"></a>java语言有哪些优点和缺点?</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）</li>
<li>支持多线程</li>
<li>具备异常处理和自动内存管理机制</li>
<li>支持网络编程并且很方便</li>
<li>编译与解释并存</li>
</ul>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>使用大量的内存：垃圾回收机制需要占用大量内存，可能导致程序的运行速度相对较慢。</li>
<li>不支持底层操作：Java使用虚拟机来实现，无法和操作系统的底层打交道了。</li>
<li>启动时间慢：由于Java程序需要先启动虚拟机，再执行程序，启动时间相对较慢。<span id="more"></span></li>
</ul>
<h1 id="JVM-、-JDK-和-JRE的关系"><a href="#JVM-、-JDK-和-JRE的关系" class="headerlink" title="JVM 、 JDK 和 JRE的关系"></a>JVM 、 JDK 和 JRE的关系</h1><ul>
<li><strong>JDK（Java Development Kit）</strong>：是 Java 开发工具包，是整个 Java 的核心，它包含了JRE，同时还包含了 javac(编译 java 源码的编译器)、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</li>
<li><strong>JRE（ Java Runtime Environment）</strong>：是 Java 的运行环境，包含 JVM 及 Java 核心类库。</li>
<li><strong>JVM（Java Virtual Machine）</strong>：Java 虚拟机，是整个 Java 实现跨平台的最核心的部分。所有 Java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行。</li>
</ul>
<p><img src="/2024/08/02/%E5%9F%BA%E7%A1%80%E7%AF%87/1.png"></p>
<h1 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h1><p>高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><p><strong>编译型语言</strong>：通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p>
</li>
<li><p><strong>解释型语言</strong>：通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。一般开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p>
<p>  Java 语言既具有编译型语言的特征，又有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
</li>
</ul>
<h1 id="Java和c-的区别"><a href="#Java和c-的区别" class="headerlink" title="Java和c++的区别"></a>Java和c++的区别</h1><ul>
<li>Java 不提供指针直接访问内存，程序内存更加安全。</li>
<li>Java 的类单继承的，C++ 支持多重继承；虽然 Java 类不支持多继承，但接口支持多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C++支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
<li>……</li>
</ul>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="java的8种基本数据类型："><a href="#java的8种基本数据类型：" class="headerlink" title="java的8种基本数据类型："></a>java的8种基本数据类型：</h2><p><img src="/2024/08/02/%E5%9F%BA%E7%A1%80%E7%AF%87/2.png"></p>
<h2 id="基本类型和包装类型的区别："><a href="#基本类型和包装类型的区别：" class="headerlink" title="基本类型和包装类型的区别："></a>基本类型和包装类型的区别：</h2><ul>
<li><strong>用途</strong>：基本类型一般用来定义一些局部变量和常量，在其他地方比如方法参数、对象属性中一般使用包装类型，并且包装类型可用于泛型，而基本类型不可以。</li>
<li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量存放在 Java 虚拟机的堆中。包装类型属于对象类型，放在堆中。</li>
<li><strong>占用空间</strong>：相比于包装类型， 基本数据类型占用的空间比较小。</li>
<li><strong>比较方式</strong>：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。整型包装类对象之间值的比较，需要使用 equals() 方法。</li>
</ul>
<h2 id="包装类型的缓存机制："><a href="#包装类型的缓存机制：" class="headerlink" title="包装类型的缓存机制："></a>包装类型的缓存机制：</h2><p><strong>Byte</strong>,<strong>Short</strong>,<strong>Integer</strong>,<strong>Long</strong> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True 或 False，两种浮点数类型的包装类 Float,Double 没有实现缓存机制。<br>看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>
<p>上述代码应输出false。首先第一行代码会发生自动装箱，因此变量<strong>i1</strong>使用的是缓存中的对象，而<strong>i2</strong>会新new一个对象出来，故两者不相等。<br>如果想比较包装类对象之间值，需要使用equals。</p>
<h2 id="自动装箱和自动拆箱："><a href="#自动装箱和自动拆箱：" class="headerlink" title="自动装箱和自动拆箱："></a>自动装箱和自动拆箱：</h2><ul>
<li><strong>自动装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>自动拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>装箱其实就是调用了 包装类的**valueOf()**方法，拆箱其实就是调用了 <strong>xxxValue()</strong> 方法。<br>因此，</p>
<blockquote>
<p>Integer i &#x3D; 10 等价于 Integer i &#x3D; Integer.valueOf(10)<br>int n &#x3D; i 等价于 int n &#x3D; i.intValue();</p>
</blockquote>
<h2 id="浮点数运算的精度丢失问题及解决办法："><a href="#浮点数运算的精度丢失问题及解决办法：" class="headerlink" title="浮点数运算的精度丢失问题及解决办法："></a>浮点数运算的精度丢失问题及解决办法：</h2><p>由于底层保存浮点数的机制，会出现小数的精度发生损失的情况，可以使用 BigDecimal 对浮点数的运算，不会造成精度丢失。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); / <span class="number">0.1</span> /</span><br><span class="line">System.out.println(y); / <span class="number">0.1</span> /</span><br><span class="line">System.out.println(Objects.equals(x, y)); / <span class="literal">true</span> /</span><br></pre></td></tr></table></figure>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="成员变量与局部变量的区别？"></a>成员变量与局部变量的区别？</h2><p><strong>语法形式：</strong></p>
<ul>
<li>成员变量属于类，而局部变量是方法中定义的变量或参数；</li>
<li>成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；</li>
<li>成员变量和局部变量都能被 final 所修饰。</li>
</ul>
<p><strong>存储方式：</strong></p>
<ul>
<li>如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于类实例的。</li>
<li>而对象存在于堆内存，局部变量则存在于栈内存。</li>
</ul>
<h2 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h2><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建了多个对象，这样可以节省内存。<br>通常情况下，静态变量会被 final 关键字修饰成为常量。</p>
<h2 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h2><ul>
<li>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li>
<li>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li>
<li>占内存大小：字符常量占 2 个字节; 字符串常量占若干个字节。</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="静态方法和实例方法的区别："><a href="#静态方法和实例方法的区别：" class="headerlink" title="静态方法和实例方法的区别："></a>静态方法和实例方法的区别：</h2><ul>
<li><strong>调用方式</strong>：在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。</li>
<li><strong>访问限制</strong>：静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li>
</ul>
<h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><ul>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ul>
<h2 id="重载和重写的区别："><a href="#重载和重写的区别：" class="headerlink" title="重载和重写的区别："></a>重载和重写的区别：</h2><ul>
<li><strong>重载</strong>：同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</li>
<li><strong>重写</strong>：子类对父类方法的重新改造，外部样子不能改变，内部实现逻辑可以改变。</li>
</ul>
<h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="面向对象和面向过程的区别："><a href="#面向对象和面向过程的区别：" class="headerlink" title="面向对象和面向过程的区别："></a>面向对象和面向过程的区别：</h2><ul>
<li><strong>面向过程</strong>：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li><strong>面向对象</strong>：是一种“万物皆对象”的编程思想，任何物体都可以归为一类事物，而每一个个体都是一类事物的实例，通过调用对象的方法来解决问题。</li>
</ul>
<h2 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><p>用new 运算符，new 创建对象实例，对象实例在堆内存中；对象引用指向对象实例，存放在栈内存中。</p>
<ul>
<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li>
<li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>
</ul>
<h2 id="对象的相等和引用相等的区别："><a href="#对象的相等和引用相等的区别：" class="headerlink" title="对象的相等和引用相等的区别："></a>对象的相等和引用相等的区别：</h2><ul>
<li>对象相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般比较的是指向的内存地址是否相等。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 == 比较字符串的引用相等</span></span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str1 == str3);</span><br><span class="line"><span class="comment">// 使用 equals 方法比较字符串的相等</span></span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line">System.out.println(str1.equals(str3));</span><br></pre></td></tr></table></figure>
<p>上述代码执行结果为：<br><img src="/2024/08/02/%E5%9F%BA%E7%A1%80%E7%AF%87/3.png"></p>
<blockquote>
<p><strong>结果分析：</strong> 由于&#x3D;&#x3D;比较的是引用相等，str2字符串会重新new一个string对象，因此引用和str1不同；str3会优先去字符串常量池寻找有无“hello”这个字符串，有的话就直接引用它，所以str3和str1引用相等。而最后两个比较的是字符串内容是否相等，故str1、str2、str3都相等。 </p>
</blockquote>
<h2 id="构造函数是什么？能否被override？类没有声明构造方法，程序还能正确执行吗"><a href="#构造函数是什么？能否被override？类没有声明构造方法，程序还能正确执行吗" class="headerlink" title="构造函数是什么？能否被override？类没有声明构造方法，程序还能正确执行吗?"></a>构造函数是什么？能否被override？类没有声明构造方法，程序还能正确执行吗?</h2><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。构造函数可以被重载(overload)，但不能被重写(override)。<br>当一个类没有声明构造方法，程序也是可以正常执行的。 当没有显式声明构造方式时，类会默认声明一个无参构造函数。但<strong>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参构造方法了。</strong></p>
<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><ul>
<li><strong>封装</strong>：把数据和操作数据的方法封装起来，对数据的访问只能通过已定义的接口。<br>可以类比平常生活的开车，汽车的底层结构被封装起来，我们无需关心底层，只需要会踩油门、转动方向盘开车即可。</li>
<li><strong>继承</strong>：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类，得到继承信息的被称为子类。<br>父类中的私有属性和方法子类是无法访问，只是拥有。</li>
<li><strong>多态</strong>：一个对象具有多种状态，具体表现为父类的引用指向子类的实例。<br>多态存在的3个必要条件: 要有继承关系 、要有方法的重写、父类引用指向子类对象。</li>
</ul>
<h2 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h2><p><strong>抽象类</strong>和普通类类似，只是无法实例化，存在的意义就是让其他类继承的。抽象类可以包含抽象方法和非抽象方法，其中抽象方法没有具体的实现，而非抽象方法有具体的实现代码。<br><strong>接口</strong>是一种定义了一组方法签名的集合，这些方法默认都是公共的抽象方法，不包含具体的实现代码，比抽象类更加抽象。<br><strong>共同点：</strong></p>
<ul>
<li>都不能被实例化。（存在的意义就是被继承或实现）</li>
<li>都包含抽象方法。（抽象类也可以没有抽象方法，只要有abstract关键字修饰，但是没意义）</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>接口主要用于限制类的行为，实现了某个接口就具有了对应的行为。抽象类主要用于代码复用。</li>
<li>抽象类中可以定义构造函数，接口不能定义构造函数；</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
</ul>
<h2 id="深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h2><ul>
<li><strong>浅拷贝：</strong> 只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</li>
<li><strong>深拷贝：</strong> 会创造一个一模一样的对象，新旧对象不共享内存，修改新对象不会影响到原对象。</li>
</ul>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h2><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">● 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="和-equals-的区别："><a href="#和-equals-的区别：" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别："></a>&#x3D;&#x3D; 和 equals() 的区别：</h2><ul>
<li><strong>“&#x3D;&#x3D;”</strong>：由于 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。因此 &#x3D;&#x3D; 对于基本数据类型来说比较的是值，对于引用数据类型来说比较的是内存地址。</li>
<li>**equals()**：如果类没有重写equals方法，等价于“&#x3D;&#x3D;”的效果；如果重写了，则比较的是对象的属性是否相等。</li>
</ul>
<h2 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h2><p>如果不同时重写的话，可能会出现<strong>无法去重的</strong>现象。<br><strong>原因</strong>：set集合在进行去重操作时，会先判断两个对象的hashcode是否相等，<strong>如果不重写hashcode()方法，就会调用object中的hashcode()方法，返回的是对象内存地址的哈希码</strong>，这就意味着两个内容相同的对象，其哈希码会由于内存地址的不同而不同。 两个内容相同的对象哈希码不同，则默认这两个对象不同，都会插入到set集合中，导致set集合有重复对象。</p>
<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><h2 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h2><p><strong>字符串常量池：</strong><br>Java内存中存在一个字符串常量池，是存储字符串对象的特殊内存区域。当创建一个字符串时，如果该字符串已经存在于字符串常量池中，那么就会直接返回这个字符串的引用；如果不存在，则会将该字符串添加到字符串常量池中，并返回新创建的字符串的引用。由于字符串常量池的存在，多个字符串可以共享同一个实例，这样可以节省内存空间。而如果 String 是可变的，那么在修改字符串时，会导致其他使用相同字符串的地方出问题。<br><strong>安全性：</strong><br>由于String不可变，因此其在多线程环境下是安全的。<br><strong>缓存哈希值：</strong><br>String 类重写了 hashCode()方法，并且在第一次调用时计算并缓存了字符串的哈希值。由于 String 是不可变的，所以可以保证哈希值的唯一性和一致性。</p>
<h2 id="String、StringBuffer、StringBuilder-的区别："><a href="#String、StringBuffer、StringBuilder-的区别：" class="headerlink" title="String、StringBuffer、StringBuilder 的区别："></a>String、StringBuffer、StringBuilder 的区别：</h2><p><strong>可变性：</strong><br>String 用于表示字符串，属于不可变类。所以每次对String进行修改都会创建一个新的String对象，导致频繁的内存分配和回收，影响性能。<br>Java提供了StringBuffer 和 StringBuilder两个可变的字符串，用于高效地进行字符串的操作。<br><strong>原理：</strong><br><strong>String</strong> 内部使用字符数组来保存字符串内容，并且该数组是 final 修饰的，当对 String 进行修改时，会创建一个新的 String 对象；<br><strong>StringBuffer</strong> 内部也使用字符数组来保存字符串内容，但是该数组没有被 final 修饰，当对 StringBuffer 进行修改时，直接在原有的字符数组上进行操作，不会创建新的对象。<br><strong>StringBuilder</strong> 的实现原理与 StringBuffer 相同，唯一的区别是 StringBuilder 不是线程安全的，而 StringBuffer 是线程安全的。</p>
<h2 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h2><p>分情况：</p>
<ul>
<li>如果字符串常量池无该对象：那么会堆中创建两个字符串对象，一个存在字符串常量池中。</li>
<li>如果字符串常量池有该对象：那么只会在堆中创建一个字符串对象。</li>
</ul>
<h2 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="String#intern 方法有什么作用?"></a>String#intern 方法有什么作用?</h2><p><strong>intern</strong> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<h2 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h2><p>当字符串不加 final 关键字拼接时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>执行结果分析</strong>：首先明确，<br><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>因此，上述代码中，<strong>除了str4的其余字符串都已经存入到字符串常量池中</strong>；而str4涉及到两个字符串的拼接，底层会在堆中创建一个新的对象，所以str4和其他字符串的比较都为false。</p>
<p>不过，当字符串使用 <strong>final</strong> 关键字声明之后，可以让编译器当做常量来处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Java 异常类层次结构图概览：<br><img src="/2024/08/02/%E5%9F%BA%E7%A1%80%E7%AF%87/4.png"></p>
<h2 id="Exception-和-Error-的区别："><a href="#Exception-和-Error-的区别：" class="headerlink" title="Exception 和 Error 的区别："></a>Exception 和 Error 的区别：</h2><ul>
<li>Exception：程序本身可以处理的异常，可以通过catch来获取，Exception又可以细分为受检查异常和不受检查异常。</li>
<li>Error：属于程序无法处理的错误。</li>
</ul>
<h2 id="Checked-Exception-和-Unchecked-Exception的区别："><a href="#Checked-Exception-和-Unchecked-Exception的区别：" class="headerlink" title="Checked Exception 和 Unchecked Exception的区别："></a>Checked Exception 和 Unchecked Exception的区别：</h2><p><strong>Checked Exception：即受检查异常</strong>，<br>Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException…。<br><strong>Unchecked Exception：即不受检查异常</strong>，</p>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。RuntimeException 及其子类统称为不受检查异常，常见的有：</p>
<ol>
<li>NullPointerException(空指针错误)</li>
<li>ArrayIndexOutOfBoundsException（数组越界错误）</li>
<li>ClassCastException（类型转换错误）</li>
<li>IllegalArgumentException(参数错误比如方法入参类型错误)</li>
<li>NumberFormatException（字符串转换为数字格式错误）</li>
<li>ArithmeticException（算术错误）</li>
<li>SecurityException （安全错误比如权限不够）</li>
<li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li>
</ol>
<h2 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h2><ul>
<li>String getMessage(): 返回异常发生时的简要描述。</li>
<li>String toString(): 返回异常发生时的详细信息。</li>
<li>String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同。</li>
<li>void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息。</li>
</ul>
<h2 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a>try-catch-finally 如何使用？</h2><ul>
<li>try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li>catch块：用于处理 try 捕获到的异常。</li>
<li>finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h2><p>不一定，在某些情况下，finally 中的代码不会被执行，如：</p>
<ul>
<li>在执行finally的代码之前虚拟机被终止了。</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 try-with-resources 代替try-catch-finally？</h2><p>try-with-resources 是 Java 7 引入的一种语法结构，用于自动关闭实现了 AutoCloseable 接口的资源。它可以代替传统的 try-catch-finally 结构来处理资源的释放。<br><strong>优点：</strong></p>
<ul>
<li>简化了代码结构：不再需要显式地编写 finally 块来关闭资源。</li>
<li>自动确保资源的正确关闭：无论是否发生异常，都会自动调用资源的 close() 方法进行关闭。</li>
<li>支持多个资源同时关闭：可以在 try 后面的括号内声明多个资源，并按照声明顺序逆序关闭。</li>
</ul>
<h1 id="泛型的使用方式有哪几种？"><a href="#泛型的使用方式有哪几种？" class="headerlink" title="泛型的使用方式有哪几种？"></a>泛型的使用方式有哪几种？</h1><p>使用泛型，可以增加代码的灵活性和安全性，使得代码更加通用和易于维护。</p>
<ul>
<li><strong>泛型类</strong>：定义一个类时，可以在类名后面加上尖括号&lt;&gt;，并在其中指定类型参数。</li>
<li><strong>泛型接口</strong>：与泛型类类似，可以在接口名后面加上尖括号&lt;&gt;，并在其中指定类型参数。然后在实现该接口时，需要指定具体的类型。</li>
<li><strong>泛型方法</strong>：即在方法返回值前面加上尖括号&lt;&gt;，并在其中指定类型参数。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射的使用："><a href="#反射的使用：" class="headerlink" title="反射的使用："></a>反射的使用：</h2><p><strong>反射是java语言的一个特性，它允程序在运行时动态获取和调用类的属性和方法。</strong><br>要使用反射，需要先获取类的class对象(字节码对象)，有三种方式：</p>
<ul>
<li>Class.forName(“全类名”);</li>
<li>类名.class;</li>
<li>类实例对象.getClass()；</li>
</ul>
<p>接下来就可以通过具体的API调用获取到详细的属性或者方法：</p>
<ul>
<li>获取构造函数：getConstructors()等方法。</li>
<li>获取类成员变量：getFields()等方法。</li>
<li>获取类成员方法：getMethods()等方法。</li>
</ul>
<h2 id="反射的应用场景："><a href="#反射的应用场景：" class="headerlink" title="反射的应用场景："></a>反射的应用场景：</h2><p>Spring 框架的 IOC（动态加载管理 Bean）、加载数据库驱动：Class.forName(“com.mysql.cj.jdbc.Driver”);、IDEA的方法提醒都需要用到反射机制。</p>
<h1 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h1><p>注解只有被解析之后才会生效，常见的解析方法有两种：<br><strong>编译期直接扫描：</strong><br>编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<a href="/Override">@Override </a> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。 </p>
<p><strong>运行期通过反射处理：</strong><br>像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。</p>
<h1 id="什么是序列化-什么是反序列化"><a href="#什么是序列化-什么是反序列化" class="headerlink" title="什么是序列化?什么是反序列化?"></a>什么是序列化?什么是反序列化?</h1><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。<br>简单来说：</p>
<ul>
<li>序列化：将数据结构或对象转换成二进制字节流的过程。</li>
<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。</li>
</ul>
<p>序列化协议对应于OSI 七层协议模型中表示层。<br><img src="/2024/08/02/%E5%9F%BA%E7%A1%80%E7%AF%87/5.png"><br>对于不想进行序列化的变量，使用 <strong>transient</strong>关键字修饰。</p>
<blockquote>
<p>transient 只能修饰变量，不能修饰类和方法。<br>static 变量不属于任何对象(Object)，所以无论有无 transient修饰，均不会被序列化。</p>
</blockquote>
<h1 id="I-O流"><a href="#I-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h1><p>I&#x2F;O即Input&#x2F;Output，数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。<br>Java I&#x2F;O流中有四个抽象类基类，其架构如下图：<br><img src="/2024/08/02/%E5%9F%BA%E7%A1%80%E7%AF%87/6.png"><br><strong>字节流</strong>适合传输所有类型的文件，如音频、视频、图片、文本文件的复制转移等。<strong>字符流</strong>只适合传输纯文本文件，如txt、java文件等。</p>
<p><strong>字节缓冲流：</strong><br>字节流在调用 write(int b) 和 read() 方法的时候，一次只能读取一个字节。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p>
<p><strong>Java 中 3 种常见 IO 模型：</strong></p>
<ul>
<li><strong>BIO (Blocking I&#x2F;O)：</strong> 同步阻塞 IO 模型，就是当应用发起读取数据申请时，在内核数据没有准备好之前，该应用会一直处于等待数据状态，直到内核把数据准备好了交给应用才结束。cpu空闲时间较多。</li>
<li><strong>NIO (Non-blocking I&#x2F;O)：</strong> 同步非阻塞 IO 模型，非阻塞IO就是当应用发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用，不会让应用阻塞等待，但是应用会以轮询的方式不断请求。cpu处于忙等。</li>
<li><strong>AIO (Asynchronous I&#x2F;O)：</strong> 异步 IO 模型，应用请求之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
  </entry>
</search>
