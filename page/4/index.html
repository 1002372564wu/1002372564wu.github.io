<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/jay.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/jay.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Time will tell">
<meta property="og:type" content="website">
<meta property="og:title" content="Michael-Jay">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Michael-Jay">
<meta property="og:description" content="Time will tell">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="吴华杰">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Michael-Jay</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Michael-Jay</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="/study/" rel="section"><i class="fas fa-marker fa-fw"></i>技术</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/jay.jpg">
      <meta itemprop="name" content="吴华杰">
      <meta itemprop="description" content="Time will tell">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Michael-Jay">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/" class="post-title-link" itemprop="url">计网常见面试题</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-05 15:09:20 / 修改时间：16:22:32" itemprop="dateCreated datePublished" datetime="2024-08-05T15:09:20+08:00">2024-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP-IP-网络模型"><a href="#TCP-IP-网络模型" class="headerlink" title="TCP&#x2F;IP 网络模型"></a>TCP&#x2F;IP 网络模型</h1><p>对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而<strong>对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备</strong>，就协商出了一套<strong>通用的网络协议</strong>。<br>TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层，网络接口层</strong>。<br><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/1.png"></p>
<p><strong>应用层</strong></p>
<p>应用层是不用去关心数据是如何传输的，只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。<strong>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</strong>。</p>
<p><strong>传输层:</strong></p>
<p><strong>传输层的作用在于为运行在不同主机上的应用进程之间提供逻辑通信</strong>（这里的逻辑通信指的是在传输层角度看来两个进程间直接进行通信，实际上还是通过下层提供的服务）。传输层有两个传输协议，分别是 TCP 和 UDP：</p>
<ul>
<li><strong>TCP</strong>：提供面向连接的，可靠的数据传输服务。</li>
<li><strong>UDP</strong>：提供无连接的，尽最大努力的数据传输（不保证数据传输的可靠性），简单高效。</li>
</ul>
<p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此<strong>当传输层的数据包大小超过 MSS（TCP 最大报文段长度），就要将数据包分块</strong> ，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 TCP 段。</p>
<p><strong>网络层:</strong></p>
<p>我们不希望传输层处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能交给网络层。</p>
<p>网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。</p>
<p>网络层将数据从一个设备传输到另一个设备，需要依赖<strong>IP地址</strong>和<strong>子网掩码</strong>进行寻址找到对应的子网，再去寻找对应的主机。  </p>
<p><strong>除了寻址能力， IP 协议还有另一个重要的能力就是路由。</strong> 实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p>
<p><strong>网络接口层:</strong></p>
<p><strong>负责将数据转换为数字信号在物理设备之间传输</strong>。在生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p>
<p><strong>四个层的封装格式如下图：</strong><br><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/2.png"><br>网络接口层的传输单位是<strong>帧</strong>（frame），IP 层的传输单位是<strong>包</strong>（packet），TCP 层的传输单位是<strong>段</strong>（segment），HTTP 的传输单位则是<strong>消息或报文</strong>（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>
<h1 id="从输入-URL-到页面展示到底发生了什么？（⭐）"><a href="#从输入-URL-到页面展示到底发生了什么？（⭐）" class="headerlink" title="从输入 URL 到页面展示到底发生了什么？（⭐）"></a>从输入 URL 到页面展示到底发生了什么？（⭐）</h1><ul>
<li><strong>检查缓存</strong>：浏览器接收到⽤户请求，先检查浏览器缓存是否有缓存该资源，如果有直接返回。</li>
<li><strong>DNS解析</strong>：发送到DNS(域名服务器)获得域名对应的WEB服务器的IP地址。<strong>（扯一下域名解析过程）</strong></li>
<li><strong>TCP连接</strong>：客户端浏览器与WEB服务器建立TCP连接。<strong>（扯一下三次握手）</strong></li>
<li><strong>发送HTTP请求</strong>：客户端浏览器向目标WEB服务器发送相应的HTTP或HTTPS请求。<strong>（扯下HTTP和HTTPS）</strong></li>
<li><strong>服务器处理请求并返回 HTTP 报文</strong>：WEB服务器响应请求，返回指定的URL数据或错误信息；如果设定重定向，则重定向到新的URL地址。</li>
<li><strong>浏览器解析渲染页面</strong>：客户端浏览器下载数据，解析HTML源文件，在页面中进行显示。</li>
<li><strong>连接结束</strong>：断开TCP连接。</li>
</ul>
<h1 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h1><h2 id="HTTP是什么？"><a href="#HTTP是什么？" class="headerlink" title="HTTP是什么？"></a>HTTP是什么？</h2><p><strong>HTTP 是在互联网中约束两设备之间传输超文本数据的 约定 和 规范。</strong></p>
<h2 id="HTTP-常见的状态码："><a href="#HTTP-常见的状态码：" class="headerlink" title="HTTP 常见的状态码："></a>HTTP 常见的状态码：</h2><p><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/3.png"></p>
<ul>
<li>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</li>
<li>2xx 类状态码表示服务器成功处理了客户端的请求，常见的有：<ul>
<li>「200 OK」是最常见的成功状态码，表示一切正常。</li>
<li>「204 No Content」也是常见的成功状态码，但响应头没有 body 数据。</li>
</ul>
</li>
<li>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向，常见的有：<ul>
<li>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「302 Found」即临时重定向，请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
<li>「304 Not Modified」缓存重定向，告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
</li>
<li>4xx 类状态码表示客户端发送的报文有误，服务器无法处理。常见的有：<ul>
<li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「404 Not Found」表示请求的资源在服务器上不存在，所以无法提供给客户端。</li>
</ul>
</li>
<li>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，常见的有：<ul>
<li>「500 Internal Server Error」与 400 类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
</li>
</ul>
<h2 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h2><ul>
<li><strong>Host</strong>：客户端发送请求时，用来指定服务器的域名。</li>
<li><strong>Content-Length</strong> ：表明服务器返回数据的数据长度。</li>
<li><strong>Connection</strong> ：常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</li>
<li><strong>Content-Encoding</strong> ：说明数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。</li>
</ul>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><ul>
<li><strong>请求行，</strong> 包括以下内容：<ul>
<li>请求方法：如get、post。</li>
<li>请求路径：url</li>
<li>版本号</li>
</ul>
</li>
<li><strong>请求头</strong>：包含一些字段(见3.3)，服务端据此获取客户端的信息。</li>
<li><strong>请求体</strong>：传递请求参数。</li>
</ul>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><ul>
<li><strong>响应行</strong>：<ul>
<li>版本信息</li>
<li>状态码及描述</li>
</ul>
</li>
<li><strong>响应头</strong>：一些字段，包含服务器的一些基本信息。</li>
<li><strong>响应体</strong>：返回的数据。</li>
</ul>
<h1 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h1><ul>
<li><strong>语义（主要区别）</strong>：GET 通常用于获取或查询资源；而 POST 通常用于创建或修改资源。</li>
<li><strong>幂等</strong>：GET 请求是幂等的，即多次重复执行不会改变资源的状态；而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li>
<li><strong>格式</strong>：GET 请求的参数通常放在 URL 中，形成查询字符串；POST 请求的参数通常放在请求体（body）中。</li>
<li><strong>缓存</strong>：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点缓存起来，以提高性能； POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li>
</ul>
<h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><p>对于一些具有重复性的 HTTP 请求，可以把这些 <strong>「请求-响应」</strong> 的数据都<strong>缓存在本地，提高访问速度</strong>，降低服务器压力。</p>
<p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。  当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，其设置了过期时间大小。当浏览器再次请求访问服务器中的该资源时，会先根据Cache-Control 中设置的过期时间，来判断该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器。</p>
<ul>
<li><strong>强制缓存</strong>：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，无需向服务器发送请求。</li>
<li><strong>协商缓存</strong>：向服务器发送请求，服务器会根据请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并通知浏览器从缓存中读取资源。</li>
</ul>
<h1 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h1><h2 id="HTTP-与-HTTPS-的区别："><a href="#HTTP-与-HTTPS-的区别：" class="headerlink" title="HTTP 与 HTTPS 的区别："></a>HTTP 与 HTTPS 的区别：</h2><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
</ul>
<h2 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h2><ul>
<li><strong>混合加密的方式实现信息的机密性</strong>，解决了窃听的风险。<ul>
<li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li>
<li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续不再使用非对称加密。</li>
</ul>
</li>
<li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的标识，用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。<blockquote>
<p><strong>对称加密：</strong> 只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>非对称加密：</strong> 用公钥和私钥，公钥可任意分发，私钥保密，解决了密钥交换问题但速度慢。</p>
</blockquote>
<h2 id="HTTPS-是如何建立连接的？"><a href="#HTTPS-是如何建立连接的？" class="headerlink" title="HTTPS 是如何建立连接的？"></a>HTTPS 是如何建立连接的？</h2><ul>
<li><strong>客户端向服务器索要并验证服务器的公钥。</strong></li>
<li><strong>双方协商生产「会话秘钥」。</strong></li>
<li><strong>双方采用「会话秘钥」进行加密通信。</strong></li>
</ul>
<h2 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h2><ul>
<li>使用<strong>长连接</strong>的方式改善了 HTTP&#x2F;1.0 <strong>短连接</strong>造成的性能开销。</li>
<li>支持<strong>管道</strong>（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul>
<h2 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h2><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<ul>
<li><strong>头部压缩</strong>：如果同时发送多个请求，且头部是一样的，那协议会自动进行压缩。</li>
<li><strong>二进制格式</strong>：不再像 HTTP&#x2F;1.1 采用纯文本格式，头信息和数据体都是二进制且统称为帧。</li>
<li><strong>并发传输</strong>：引入了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</li>
<li><strong>服务器推送</strong>：客户端和服务器双方都可以建立 Stream，减少消息传递次数。</li>
</ul>
<h2 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h2><p>HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p>
<ul>
<li>HTTP&#x2F;1.1属于 HTTP 层队头阻塞。</li>
<li>HTTP&#x2F;2 属于 TCP 层队头阻塞。</li>
</ul>
<p>所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<h2 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h2><p> 通过<strong>session</strong>和<strong>cookie</strong>机制协同保存用户的状态。Session的作用就是通过服务端记录用户的状态，<strong>当用户进行操作时，服务端给该用户创建特定的 Session 之后就可以标识这个用户</strong>并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。最后通过在 Cookie 中附加一个 Session ID 来方式来跟踪这个Session。</p>
<p><strong>使用 Session 维护用户登录状态的过程如下：</strong></p>
<ol>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ol>
<p>如果cookie被禁用的话，可以利用 <strong>URL 重写</strong>把 Session ID 直接附加在 URL 路径的后面。</p>
<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><h2 id="什么是-WebSocket"><a href="#什么是-WebSocket" class="headerlink" title="什么是 WebSocket?"></a>什么是 WebSocket?</h2><p><strong>WebSocket</strong> 是一种基于 TCP 连接的<strong>全双工</strong>通信协议，即客户端和服务器可以同时发送和接收数据。其本质上是<strong>应用层</strong>的协议，<strong>用于弥补 HTTP 协议在持久通信能力上的不足</strong>。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<h2 id="WebSocket-和-HTTP-有什么区别？"><a href="#WebSocket-和-HTTP-有什么区别？" class="headerlink" title="WebSocket 和 HTTP 有什么区别？"></a>WebSocket 和 HTTP 有什么区别？</h2><ul>
<li>WebSocket 是一种<strong>双向实时通信协议</strong>，而 HTTP 是一种<strong>单向通信协议</strong>。</li>
<li>WebSocket 使用 ws:&#x2F;&#x2F; 或 wss:&#x2F;&#x2F; 作为协议前缀，HTTP 使用 http:&#x2F;&#x2F; 或 https:&#x2F;&#x2F; 作为协议前缀。</li>
<li>WebSocket 可以支持扩展，实现部分自定义的子协议，如支持压缩、加密等。</li>
</ul>
<h1 id="Ping命令"><a href="#Ping命令" class="headerlink" title="Ping命令"></a>Ping命令</h1><p>ping命令用来测试网络中主机之间的连通性和网络延迟。</p>
<p><strong>工作原理：</strong><br><strong>基于网络层的</strong> <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p>
<p>PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。</p>
<ul>
<li>PING 命令会向目标主机发送 ICMP Echo Request。</li>
<li>如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题，</strong>属于应用层协议，使用UDP传输。<br><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/4.png"><br>先以<strong>递归</strong>的方式查询<strong>本地 DNS 服务器</strong>，再以<strong>迭代</strong>的方式查询其余服务器。</p>
<p><strong>DNS解析过程：</strong></p>
<ul>
<li>先查询缓存以及硬盘里的hosts文件。</li>
<li>请求本地dns服务器，本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信。</li>
<li>本地DNS服务器以迭代的方式请求根域名服务器、顶级域名服务器、权威域名服务器 …最终查询到ip地址。</li>
</ul>
<h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><p><strong>TCP是面向连接的、可靠的、基于字节流的传输层协议。（基于这三个性质扯知识点）</strong></p>
<h2 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h2><ul>
<li><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。</li>
<li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
</ul>
<h2 id="什么时候选择-TCP，什么时候选-UDP"><a href="#什么时候选择-TCP，什么时候选-UDP" class="headerlink" title="什么时候选择 TCP，什么时候选 UDP?"></a>什么时候选择 TCP，什么时候选 UDP?</h2><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h2 id="HTTP-基于-TCP-还是-UDP？"><a href="#HTTP-基于-TCP-还是-UDP？" class="headerlink" title="HTTP 基于 TCP 还是 UDP？"></a>HTTP 基于 TCP 还是 UDP？</h2><p><strong>HTTP&#x2F;3.0 之前是基于 TCP 协议的，而 HTTP&#x2F;3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。</strong> 主要是为了解决 HTTP&#x2F;2 中存在的队头阻塞问题。</p>
<p>这是由于 HTTP&#x2F;2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p>
<h2 id="使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h2><p><strong>使用TCP的协议：</strong></p>
<ul>
<li><strong>HTTP 协议</strong>（HTTP&#x2F;3.0 之前）：是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>HTTPS 协议</strong>：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议。</li>
<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。</li>
<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>
<li><strong>POP3&#x2F;IMAP 协议</strong>：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>
<li><strong>Telnet 协议</strong>：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>
<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>
</ul>
<p><strong>使用UDP的协议：</strong></p>
<ul>
<li><strong>HTTP 协议（HTTP&#x2F;3.0 ）</strong>： HTTP&#x2F;3.0 弃用 TCP，改用基于 UDP 的 QUIC 协议 。</li>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址。</li>
<li><strong>DNS</strong>：域名系统（DNS，Domain Name System）将人类可读的域名转换为机器可读的 IP 地址。实际上，DNS 同时支持 UDP 和 TCP 协议。</li>
</ul>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>
<ul>
<li>一次握手 : 客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认；</li>
<li>二次握手 : 服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态</li>
<li>三次握手 : 客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成 TCP 三次握手。</li>
</ul>
<h2 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手?"></a>为什么需要三次握手?</h2><p><strong>三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<ol>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常。</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常。</li>
</ol>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ul>
<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 FIN-WAIT-1 状态。</li>
<li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li>
<li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了</li>
</ul>
<p><strong>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</strong></p>
<blockquote>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
</blockquote>
<h2 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h2><ul>
<li><strong>基于数据块传输</strong>：应用数据被分割成数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>重传机制</strong> : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答。</li>
<li><strong>流量控制</strong> : 当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。<strong>接收方的接收能力由滑动窗口表示</strong>，表示接收方还有多少缓冲区可以用来接收数据。<strong>网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量</strong>。<strong>发送方发送数据的大小是滑动窗口和拥塞窗口的最小值</strong>，<strong>这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</strong></li>
</ul>
<h2 id="什么是TCP粘包-拆包？发生的原因？"><a href="#什么是TCP粘包-拆包？发生的原因？" class="headerlink" title="什么是TCP粘包&#x2F;拆包？发生的原因？"></a>什么是TCP粘包&#x2F;拆包？发生的原因？</h2><p>由于 <strong>TCP</strong> 传输协议是<strong>面向字节流</strong>的传输协议，<strong>没有消息保护边界</strong>，所以发送方发送的多个数据包，接收方应用层不知如何区分，可能会被当成一个包来处理，这就是粘包；或者，发送方将一个打包分成多个小包发送，而接收方将它们当成多个包进行处理，这就是拆包。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li><strong>将首尾字符用特殊字符分隔。</strong></li>
<li><strong>使用变长协议，在报文头中指定当前报文中数据的长度。</strong>(如HTTP协议)</li>
</ul>
<h2 id="TCP的几种状态"><a href="#TCP的几种状态" class="headerlink" title="TCP的几种状态"></a>TCP的几种状态</h2><p><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/5.jpg"><br><strong>三次握手：</strong></p>
<ul>
<li><strong>CLOSED</strong>：初始状态，表示TCP连接是“关闭着的”或“未打开的”。</li>
<li><strong>LISTEN</strong> ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。</li>
<li><strong>SYN_RCVD</strong> ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。</li>
<li><strong>SYN_SENT</strong> ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</li>
<li><strong>ESTABLISHED</strong> ：表示TCP连接已经成功建立。</li>
</ul>
<p><strong>四次挥手：</strong></p>
<ul>
<li><strong>FIN_WAIT_1</strong> ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。</li>
<li><strong>FIN_WAIT_2</strong> ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。</li>
<li><strong>TIME_WAIT</strong> ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）</li>
<li><strong>CLOSING</strong>：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。</li>
<li><strong>CLOSE_WAIT</strong>：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</li>
<li><strong>LAST_ACK</strong>：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。</li>
</ul>
<h2 id="什么是半连接队列？"><a href="#什么是半连接队列？" class="headerlink" title="什么是半连接队列？"></a>什么是半连接队列？</h2><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。</p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP&#x2F;IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>
<h1 id="NAT的作用是什么？"><a href="#NAT的作用是什么？" class="headerlink" title="NAT的作用是什么？"></a>NAT的作用是什么？</h1><p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>
<p>NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。</p>
<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><h2 id="什么是-Mac-地址？"><a href="#什么是-Mac-地址？" class="headerlink" title="什么是 Mac 地址？"></a>什么是 Mac 地址？</h2><p><strong>MAC地址</strong>：MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。<br>MAC 地址具有可携带性、永久性，永久地标识一个设备的身份，不论它到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<h2 id="ARP-协议有什么用？"><a href="#ARP-协议有什么用？" class="headerlink" title="ARP 协议有什么用？"></a>ARP 协议有什么用？</h2><p>它解决的是<strong>网络层地址和链路层地址之间的转换问题</strong>。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，<strong>ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</strong></p>
<h1 id="应用层常见协议"><a href="#应用层常见协议" class="headerlink" title="应用层常见协议"></a>应用层常见协议</h1><p><img src="/2024/08/05/%E8%AE%A1%E7%BD%91%E7%AF%87/6.png"></p>

      
    </div>

    
    
    
	
	 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴华杰"
      src="/images/jay.jpg">
  <p class="site-author-name" itemprop="name">吴华杰</p>
  <div class="site-description" itemprop="description">Time will tell</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:1002372564@qq.com" title="E-Mail → mailto:1002372564@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-07-31 @ – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴华杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">83k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:16</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共51.3k字</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

</body>
</html>
