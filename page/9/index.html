<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Time will tell">
<meta property="og:type" content="website">
<meta property="og:title" content="Michael-Jay">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="Michael-Jay">
<meta property="og:description" content="Time will tell">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="吴华杰">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Michael-Jay</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
   <script type="text/javascript" src="/js/clicklove.js"></script>
  

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Michael-Jay</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="/study/" rel="section"><i class="fas fa-marker fa-fw"></i>技术</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-practice">

    <a href="/practice/" rel="section"><i class="fas fa-building fa-fw"></i>实习</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/05/JVM%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/jay.jpg">
      <meta itemprop="name" content="吴华杰">
      <meta itemprop="description" content="Time will tell">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Michael-Jay">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/05/JVM%E7%AF%87/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-05 10:52:03 / 修改时间：14:24:06" itemprop="dateCreated datePublished" datetime="2024-08-05T10:52:03+08:00">2024-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM的组成："><a href="#JVM的组成：" class="headerlink" title="JVM的组成："></a>JVM的组成：</h1><h2 id="JVM-概述-⭐"><a href="#JVM-概述-⭐" class="headerlink" title="JVM 概述(⭐)"></a>JVM 概述(⭐)</h2><h3 id="JVM是什么？"><a href="#JVM是什么？" class="headerlink" title="JVM是什么？"></a>JVM是什么？</h3><p><strong>jvm(Java Virtual Machine)，</strong>是Java程序的运行环境（java二进制字节码的运行环境）。</p>
<ul>
<li><strong>优点：</strong><ul>
<li>一次编写，到处运行。(jvm屏蔽了各种操作系统)</li>
<li>自动内存管理，垃圾回收机制。</li>
</ul>
</li>
</ul>
<h3 id="JVM由哪些部分组成，运行流程是什么？"><a href="#JVM由哪些部分组成，运行流程是什么？" class="headerlink" title="JVM由哪些部分组成，运行流程是什么？"></a>JVM由哪些部分组成，运行流程是什么？</h3><p><img src="/2024/08/05/JVM%E7%AF%87/1.png"><br><strong>JVM 的主要组成部分  :</strong></p>
<ul>
<li><strong>ClassLoader（类加载器）</strong></li>
<li><strong>Runtime Data Area（运行时数据区，内存分区）</strong></li>
<li><strong>Execution Engine（执行引擎）</strong></li>
<li><strong>Native Method Library（本地库接口）</strong></li>
</ul>
<p><strong>运行流程：</strong></p>
<ul>
<li><strong>类加载器</strong>把Java字节码文件加载进内存中。</li>
<li><strong>运行时数据区</strong>分为堆、栈、方法区、程序计数器等，各自存储各个类型的数据。</li>
<li><strong>执行引擎</strong>将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的<strong>本地库接口</strong>来实现整个程序的功能。</li>
</ul>
<h2 id="什么是程序计数器？"><a href="#什么是程序计数器？" class="headerlink" title="什么是程序计数器？"></a>什么是程序计数器？</h2><p><strong>程序计数器</strong>是<strong>线程私有</strong>的，用于记录正在执行的<strong>字节码指令的地址</strong>。<br>        java虚拟机对于多线程任务是通过线程轮流切换并分配线程执行时间来完成的。如果当前被执行的这个线程所分配的执行时间用完了【挂起】，处理器会切换到另外的一个线程上执行。当这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。 <strong>为了使线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。</strong><br>        程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h2 id="介绍一下Java的堆-⭐"><a href="#介绍一下Java的堆-⭐" class="headerlink" title="介绍一下Java的堆(⭐)"></a>介绍一下Java的堆(⭐)</h2><ul>
<li><strong>堆是线程共享的区域</strong>：主要用来保存<strong>对象实例</strong>，<strong>数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出<strong>OutOfMemoryError</strong>异常。</li>
<li><strong>组成：年轻代+老年代：</strong><ul>
<li><strong>年轻代</strong>被划分为三部分，Eden区和两个大小严格相同的Survivor区。</li>
<li><strong>老年代</strong>主要保存生命周期长的对象，一般是一些老的对象。</li>
</ul>
</li>
<li>Jdk1.7和1.8的区别：<ul>
<li>1.7中有有一个<strong>永久代（方法区）</strong>，存储的是类信息、静态变量、常量、编译后的代码。</li>
<li>1.8移除了永久代，把数据存储到了<strong>本地内存的元空间</strong>中，<strong>防止内存溢出</strong>。</li>
</ul>
</li>
</ul>
<h2 id="虚拟机栈-⭐"><a href="#虚拟机栈-⭐" class="headerlink" title="虚拟机栈(⭐)"></a>虚拟机栈(⭐)</h2><h3 id="什么是虚拟机栈？"><a href="#什么是虚拟机栈？" class="headerlink" title="什么是虚拟机栈？"></a>什么是虚拟机栈？</h3><ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈。</li>
<li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存。</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li>
</ul>
<h3 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h3><p>不涉及，<strong>垃圾回收</strong>主要指就是<strong>堆内存</strong>，当栈帧弹栈以后，内存就会释放。</p>
<h3 id="栈帧内存分配越大越好吗？"><a href="#栈帧内存分配越大越好吗？" class="headerlink" title="栈帧内存分配越大越好吗？"></a>栈帧内存分配越大越好吗？</h3><p>未必，默认的栈内存通常为1024k 。栈内存不变下，栈帧过大会导致线程数变少。</p>
<h3 id="方法内的局部变量是否线程安全？"><a href="#方法内的局部变量是否线程安全？" class="headerlink" title="方法内的局部变量是否线程安全？"></a>方法内的局部变量是否线程安全？</h3><ul>
<li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的。</li>
<li>如果局部变量逃离了方法的作用范围(如出现在<strong>形参</strong>或<strong>返回值</strong>)，需要考虑线程安全。</li>
</ul>
<h3 id="什么情况下会导致栈内存溢出？"><a href="#什么情况下会导致栈内存溢出？" class="headerlink" title="什么情况下会导致栈内存溢出？"></a>什么情况下会导致栈内存溢出？</h3><ul>
<li><strong>栈帧过多</strong>导致栈内存溢出，如：递归调用</li>
<li><strong>栈帧过大</strong>导致栈内存溢出。</li>
</ul>
<h3 id="堆栈的区别是什么？"><a href="#堆栈的区别是什么？" class="headerlink" title="堆栈的区别是什么？"></a>堆栈的区别是什么？</h3><ul>
<li><strong>栈内存</strong>一般会用来存储<strong>局部变量</strong>和<strong>方法调用</strong>，但<strong>堆内存</strong>是用来存储<strong>Java对象</strong>和<strong>数组</strong>的。堆有GC垃圾回收，而栈没有。</li>
<li><strong>栈内存</strong>是<strong>线程私有</strong>的，而<strong>堆内存</strong>是<strong>线程共享</strong>的。</li>
<li><strong>两者异常错误不同，栈内存或者堆内存不足都会抛出异常</strong>：   <ul>
<li>栈空间不足：java.lang.StackOverFlowError。      </li>
<li>堆空间不足：java.lang.OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h2 id="介绍一下方法区-⭐"><a href="#介绍一下方法区-⭐" class="headerlink" title="介绍一下方法区(⭐)"></a>介绍一下方法区(⭐)</h2><h3 id="方法区概述"><a href="#方法区概述" class="headerlink" title="方法区概述"></a>方法区概述</h3><ul>
<li><strong>方法区</strong>(Method Area)是各个<strong>线程共享</strong>的内存区域。</li>
<li>主要存储类<strong>的信息、运行时常量池。</strong></li>
<li>虚拟机启动的时候创建，关闭虚拟机时释放。</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace。</li>
</ul>
<p><strong>永久代</strong>是 <strong>JDK 1.8 之前</strong>的方法区实现，<strong>JDK 1.8 <strong>及以后方法区的实现变成了</strong>元空间</strong>。永久代在堆中，而元空间在本地内存，发生OOM的概率比永久代小。<br><img src="/2024/08/05/JVM%E7%AF%87/2.png"></p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li><strong>常量池</strong>：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li>当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>直接内存</strong>不受 JVM 内存回收管理，属于操作系统的内存，常见于 NIO 操作时，用于数据缓冲区，NIO读写性能比IO高。两者区别见下图：<br><img src="/2024/08/05/JVM%E7%AF%87/3.png"><br><img src="/2024/08/05/JVM%E7%AF%87/4.png"><br> <strong>传统阻塞IO</strong> <strong>的数据传输要走两次缓存区，而NIO只需走一次。</strong></p>
<h1 id="类加载器："><a href="#类加载器：" class="headerlink" title="类加载器："></a>类加载器：</h1><h2 id="什么是类加载器，类加载器有哪些-⭐"><a href="#什么是类加载器，类加载器有哪些-⭐" class="headerlink" title="什么是类加载器，类加载器有哪些?(⭐)"></a>什么是类加载器，类加载器有哪些?(⭐)</h2><p><img src="/2024/08/05/JVM%E7%AF%87/5.png"><br><strong>类加载器</strong>（ClassLoader ）的主要作用就是将<strong>类的字节码文件</strong>加载到<strong>JVM</strong> 中 ，从而让 Java 程序能够启动起来。类加载器根据各自加载范围的不同，划分为<strong>四种类加载器</strong>：</p>
<ul>
<li>启动类加载器(BootStrap ClassLoader)：<ul>
<li><strong>该类用来加载 Java 的核心类，并不继承 ClassLoader 类</strong>，其是由 C++ 编写实现。</li>
</ul>
</li>
<li>扩展类加载器(ExtClassLoader)：<ul>
<li>该类是ClassLoader的子类，主要加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类库。</li>
</ul>
</li>
<li>应用类加载器(AppClassLoader)：<ul>
<li>该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。</li>
</ul>
</li>
<li>自定义类加载器：<ul>
<li>开发者自定义类继承ClassLoader，实现自定义类加载规则。</li>
</ul>
</li>
</ul>
<h2 id="双亲委派模型-⭐"><a href="#双亲委派模型-⭐" class="headerlink" title="双亲委派模型(⭐)"></a>双亲委派模型(⭐)</h2><p><strong>该机制的核心思想是，当一个类需要被加载时，首先委托给其父类加载器，如果父类加载器无法加载，则由当前类加载器自己尝试加载。</strong><br>除了启动类加载器外，其他所有类加载器都需要继承抽象类<strong>ClassLoader</strong>，这个抽象类中定义了三个关键方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个类加载器都有个父加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//查找一下这个类是不是已经加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span>( c == <span class="literal">null</span> )&#123;</span><br><span class="line">          <span class="comment">//先委派给父加载器去加载，注意这是个递归调用</span></span><br><span class="line">          <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">              c = parent.loadClass(name);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果父加载器为空，查找Bootstrap加载器是不是加载过了</span></span><br><span class="line">              c = findBootstrapClassOrNull(name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父加载器没加载成功，调用自己的findClass去加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> c；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)&#123;</span><br><span class="line">       <span class="comment">//1. 根据传入的类名name，到在特定目录下去寻找类文件，把.class文件读入内存</span></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">       <span class="comment">//2. 调用defineClass将字节数组转成Class对象</span></span><br><span class="line">       <span class="keyword">return</span> defineClass(buf, off, len)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将字节码数组解析成一个Class对象，用native方法实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>JVM 的类加载器是分层次的，它们有父子关系，而<strong>这个关系不是继承维护，而是组合，每个类加载器都持有一个 parent 字段，指向父加载器</strong>。</li>
<li><strong>loadClass 方法的主要职责就是实现双亲委派机制</strong>：首先检查这个类是不是已经被加载过了，如果加载过了直接返回，否则委派给父加载器加载，这是一个递归调用，<strong>一层一层向上委派，最顶层的类加载器（启动类加载器）无法加载该类时，再一层一层向下委派给子类加载器加载</strong>。</li>
</ul>
<h3 id="为什么采用双亲委派机制？"><a href="#为什么采用双亲委派机制？" class="headerlink" title="为什么采用双亲委派机制？"></a>为什么采用双亲委派机制？</h3><ul>
<li><strong>唯一性：</strong>防止加载同一个类，通过委托询问上级是否已经加载过该.class，如果加载过了，则不需要重新加载。保证了数据安全。</li>
<li><strong>安全性：</strong> 保证类库 API 不会被修改，即使被修改了也不会被加载。</li>
</ul>
<h3 id="如何破坏双亲委派机制？"><a href="#如何破坏双亲委派机制？" class="headerlink" title="如何破坏双亲委派机制？"></a>如何破坏双亲委派机制？</h3><p>如果想不遵循双亲委派的类加载顺序，需要自定义类加载器，并重写findClass和loadClass方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1、获取class文件二进制字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            <span class="type">String</span> <span class="variable">namePath</span> <span class="operator">=</span> name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">classFile</span> <span class="operator">=</span> <span class="string">&quot;C:\\study\\myStudy\\ZooKeeperLearning\\zkops\\target\\classes\\&quot;</span> + namePath + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(classFile));</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、字节码加载到 JVM 的方法区，</span></span><br><span class="line">        <span class="comment">// 并在 JVM 的堆区建立一个java.lang.Class对象的实例</span></span><br><span class="line">        <span class="comment">// 用来封装 Java 类相关的数据和方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 直接自己加载</span></span><br><span class="line">        clazz = <span class="built_in">this</span>.findClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己加载不了，再调用父类loadClass，保持双亲委托模式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类装载的执行过程-⭐"><a href="#类装载的执行过程-⭐" class="headerlink" title="类装载的执行过程(⭐)"></a>类装载的执行过程(⭐)</h2><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了7 个阶段：<br><img src="/2024/08/05/JVM%E7%AF%87/6.png" alt="image.png"></p>
<ul>
<li><strong>加载</strong> : 通过class的<strong>全限定类名</strong>，把该类的代码数据加载到内存中。</li>
<li><strong>链接</strong>：<ul>
<li>**验证 **: 验证类是否符合JVM规范，安全性检查。</li>
<li><strong>准备(⭐)</strong> : 为类变量(静态变量)分配内存并设置类变量初始值（jvm的初始值）。（<strong>如果静态变量被final修饰的话，那么会被赋值为用户设置的初始值</strong>）</li>
<li><strong>解析</strong> : 把常量池中的符号引用转换为直接引用。<ul>
<li><strong>符号引用</strong>：以一组符号来描述所引用的目标。</li>
<li><strong>直接引用</strong>：可以理解为一个内存地址，或者一个偏移量。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
</li>
</ul>
</li>
<li><strong>初始化(⭐)</strong> : 直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码。此阶段会对类的<strong>静态变量，静态代码块、成员变量</strong>等执行初始化操作(开发人员设置的初始值)。<ul>
<li><strong>初始化顺序：静态变量-&gt;静态代码块-&gt;成员变量-&gt;构造函数</strong></li>
</ul>
</li>
<li>**使用 **: JVM 开始从入口方法开始执行用户的程序代码。</li>
<li><strong>卸载</strong> : 当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。<blockquote>
<p><strong>ps：非静态变量属于对象，不属于类，类加载的几个阶段都只针对类变量。</strong></p>
</blockquote>
</li>
</ul>
<h2 id="一个对象从创建到回收在内存中经历了哪些过程？"><a href="#一个对象从创建到回收在内存中经历了哪些过程？" class="headerlink" title="一个对象从创建到回收在内存中经历了哪些过程？"></a>一个对象从创建到回收在内存中经历了哪些过程？</h2><ol>
<li><strong>检查类是否加载：</strong> 当需要创建一个类的实例对象时，需要先判断该类是否被成功加载过了，若没有加载，要先进行类的加载，如果加载过了，会在堆区有一个类的class对象，方法区会有类的相关元数据信息。</li>
<li><strong>分配内存：</strong> 类加载成功后，jvm就能够确定对象的大小了，然后jvm会在堆内存划分一块对象大小的内存空间出来，分配给新生对象。jvm分配内存有两种方式：<ol>
<li><strong>指针碰撞法：</strong> 当堆中内存较规整的时候，会维护一个内存指针，通过移动指针的方式给对象分配内存空间。</li>
<li><strong>空闲列表：</strong> 当堆中内存较为凌乱，会维护一个空闲列表，当对象需要分配内存时，从空闲列表中找到一块足够对象大小的内存，分给新生对象。这种方式可能会产生一些<strong>内存碎片</strong>。<ol>
<li><strong>当多个线程同时分配内存时，这里会有线程安全问题。解决办法有两种：</strong><ol>
<li><strong>cas+重试机制：</strong> 就是通过cas操作移动指针，只有一个线程可以移动成功，移动失败的线程重试，直到成功为止。</li>
<li><strong>本地线程分配缓冲(TLAB)：</strong> 当线程开启时，就为每个线程分配一块较大的空间，然后线程内部创建对象的时候，就从自己的空间分配，当自己的空间分配完了再从堆中分配内存。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>初始化：</strong> 就是对分配的这一块内存初始化为零值，也就是给实例对象的成员变量赋值为零值，引用类型为null，int类型赋值为0等等操作。</li>
<li><strong>设置对象头：</strong> 对象分为 <strong>对象头，实例数据区，对齐填充位</strong>。设置对象头，就是设置对象头中对象的hashcode，分代年龄，锁状态，类元数据指针等信息。<ol>
<li><strong>对象头：</strong> 对象头分为mark word，Klass pointer 两个字段，mark word 保存了对象的hashcode 值，分代年龄，锁状态等信息。</li>
<li><strong>实例数据区：</strong> 保存对象成员变量的值，引用类型的话保存的是内存地址。</li>
<li><strong>对齐填充位：</strong> 填充占用的内存的大小，使其为8字节的整数倍。</li>
</ol>
</li>
<li><strong>执行初始化方法：</strong> 给对象的成员变量设置程序员指定值的初始值，并且会执行构造方法。</li>
</ol>
<h1 id="垃圾回收："><a href="#垃圾回收：" class="headerlink" title="垃圾回收："></a>垃圾回收：</h1><h2 id="对象什么时候可以被垃圾器回收-？-⭐"><a href="#对象什么时候可以被垃圾器回收-？-⭐" class="headerlink" title="对象什么时候可以被垃圾器回收 ？(⭐)"></a>对象什么时候可以被垃圾器回收 ？(⭐)</h2><p>如果没有任何的引用指向该对象了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p>
<p><strong>定位垃圾</strong>的方式：</p>
<ul>
<li><strong>引用计数法</strong>：给对象中添加一个引用计数器，每被引用一次计数器就+1，反之-1。引用数为0时代表该对象可被回收。（缺点：循环引用时会出现内存泄漏）</li>
<li><strong>可达性分析算法</strong>：通过一系列的称为 “GC Roots”（肯定不能当做垃圾回收的对象） 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<ul>
<li><strong>可以作为GC Root的对象：</strong><ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
<li>JNI（Java Native Interface）引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JVM-垃圾回收算法-⭐"><a href="#JVM-垃圾回收算法-⭐" class="headerlink" title="JVM 垃圾回收算法(⭐)"></a>JVM 垃圾回收算法(⭐)</h2><ul>
<li><strong>标记清除算法</strong>：先根据可达性分析算法得出的垃圾进行标记，再对这些标记为可回收的内容进行垃圾回收。<ul>
<li><strong>缺点</strong>：<strong>通过标记清除算法清理出来的内存，碎片化较为严重。</strong></li>
</ul>
</li>
<li><strong>标记整理算法</strong>：和上述类似，在清理完垃圾之后，会对存活对象进行整理，从而<strong>解决了碎片化的问题。</strong><ul>
<li><strong>缺点</strong>：<strong>对象需要移动，效率较低。</strong></li>
</ul>
</li>
<li><strong>复制算法</strong>：将原有的内存空间一分为二，每次只用其中的一块,正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。<strong>无碎片、效率较高。</strong><ul>
<li><strong>缺点</strong>：<strong>内存使用率低。</strong></li>
</ul>
</li>
</ul>
<h2 id="分代收集算法-⭐"><a href="#分代收集算法-⭐" class="headerlink" title="分代收集算法(⭐)"></a>分代收集算法(⭐)</h2><p>根据对象存活周期的不同将内存分为几块。一般将 Java <strong>堆</strong> 分为 <strong>新生代</strong> 和<strong>老年代</strong>，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br><img src="/2024/08/05/JVM%E7%AF%87/7.png"><br>在<strong>新生代</strong>中，每次收集都会有大量对象死去，所以可以选择 <strong>”标记-复制“</strong> 算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择 <strong>“标记-清除”</strong> 或 <strong>“标记-整理”</strong> 算法进行垃圾收集。<br><strong>对象回收分代回收的过程：</strong></p>
<ul>
<li>新创建的对象首先会分配到伊甸园。</li>
<li>当伊甸园内存不足，标记伊甸园和幸存区from中的存活对象。</li>
<li>使用复制算法将存活对象复制到to中，然后释放from和eden的内存。</li>
<li>一段时间后eden内存又不足，标记eden和to中存活的对象，复制到from中。</li>
<li>当幸存区对象熬过几次回收(15次)，晋身至老年代中。(幸存区内存不足或大对象会提前晋身)</li>
</ul>
<h3 id="MinorGC、-Mixed-GC-、-FullGC的区别是什么？"><a href="#MinorGC、-Mixed-GC-、-FullGC的区别是什么？" class="headerlink" title="MinorGC、 Mixed GC 、 FullGC的区别是什么？"></a><strong>MinorGC、 Mixed GC 、 FullGC的区别是什么？</strong></h3><ul>
<li><p><strong>MinorGC</strong>： 发生在新生代的垃圾回收，暂停时间短（ STW ）。</p>
</li>
<li><p><strong>FullGC</strong> ： 新生代 + 老年代完整垃圾回收，暂停时间长（ STW ），应尽力避免。</p>
<blockquote>
<p>触发FullGC的两种情况：<br>①在 MinorGC之前，会判断老年代中是否容得下新生代的对象，容不下会触发FullGC。<br>②在MinorGC之后老年代发生OOM。</p>
</blockquote>
</li>
<li><p><strong>Mixed GC</strong>： 新生代 + 老年代部分区域的垃圾回收， G1 收集器特有 。</p>
<blockquote>
<p>STW （ Stop-The-World ）：暂停所有应用程序线程，等待垃圾回收的完成 。</p>
</blockquote>
</li>
</ul>
<h2 id="JVM-垃圾回收器-⭐"><a href="#JVM-垃圾回收器-⭐" class="headerlink" title="JVM 垃圾回收器(⭐)"></a>JVM 垃圾回收器(⭐)</h2><ul>
<li><strong>串行垃圾收集器</strong>：垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（ STW ），等待垃圾回收的完成，<strong>适用于单机模式的虚拟机</strong>。<ul>
<li><strong>Serial</strong>：作用于新生代，采用复制算法。</li>
<li><strong>Serial Old</strong>： 作用于老年代，采用标记 - 整理算法。</li>
</ul>
</li>
<li><strong>并行垃圾收集器</strong>：（ JDK8 默认使用此垃圾回收器）<ul>
<li><strong>ParNew收集器</strong>：是<strong>Serial收集器的多线程并行版本</strong>，除了<strong>同时使用多条线程进行垃圾收集</strong>之外，其余的行为与Serial收集器完全一致。（除serial之外唯一能和CMS配合的）</li>
<li><strong>Parallel Scavenge收集器</strong>：新生代收集器，基于<strong>标记-复制算法</strong>实现，<strong>和ParNew非常相似，区别在于该收集器更加关注吞吐量</strong>（高效利用CPU）。</li>
<li><strong>Parallel Old收集器</strong>：是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</li>
</ul>
</li>
<li><strong>CMS收集器：</strong>主要作用于老年代<strong>，</strong>以获取<strong>最短回收停顿时间</strong>为目标的收集器，给用户带来良好的交互体验。<ul>
<li>基于<strong>标记-清除算法</strong>实现，整个过程分四个步骤：<strong>初始标记</strong>和<strong>重新标记</strong>耗时较短，需要<strong>STW</strong>暂停其他线程；而整个过程中耗时最长的<strong>并发标记</strong>和<strong>并发清除</strong>阶段中，垃圾收集器线程可以与用户线程并行工作。<ol>
<li>初始标记：标记GCRoots能直接关联到的对象，速度很快。</li>
<li>并发标记：标记GC Roots的间接关联对象，这个过程耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动。</li>
<li>并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ol>
</li>
</ul>
</li>
<li>G1收集器：<ul>
<li>应用于新生代和老年代，JDK9之后默认使用的收集器。</li>
<li>将java堆划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备。</li>
<li>采用标记复制算法，兼顾响应时间和吞吐量。</li>
<li><strong>分为四个阶段：</strong><ul>
<li><strong>初始标记</strong>：标记一下GC Roots能直接关联到的对象，这个阶段需要停顿线程，但耗时很短。</li>
<li><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li><strong>最终标记</strong>：需要对用户线程做一个短暂的暂停，解决上一阶段的漏标问题。</li>
<li><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把这些Region中的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</strong></p>
</blockquote>
<h2 id="强引用、软引用、弱引用、虚引用的区别？"><a href="#强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用的区别？"></a>强引用、软引用、弱引用、虚引用的区别？</h2><ul>
<li><strong>强引用</strong>：最传统的“引用”的定义，只要强引用关系还存在，<strong>垃圾收集器就永远不会回收掉被强引用的对象</strong>。</li>
<li><strong>软引用</strong>：如果内存空间足够，垃圾回收器就不会回收它，<strong>如果内存空间不足了，才会回收这些对象的内存</strong>。</li>
<li><strong>弱引用</strong>：强度比软引用更弱，当垃圾回收器开始工作时，无论内存空间是否充足都会对弱引用对象进行回收。</li>
<li><strong>虚引用</strong>：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>主要用来跟踪对象被垃圾回收器回收的活动</strong>。</li>
</ul>
<h1 id="jvm实践："><a href="#jvm实践：" class="headerlink" title="jvm实践："></a>jvm实践：</h1><h2 id="JVM调优的参数可以在哪里设置参数值？"><a href="#JVM调优的参数可以在哪里设置参数值？" class="headerlink" title="JVM调优的参数可以在哪里设置参数值？"></a>JVM调优的参数可以在哪里设置参数值？</h2><ul>
<li><strong>war包部署在tomcat中设置 修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件</strong></li>
<li><strong>jar包部署在启动参数设置 java -Xms512m -Xmx1024m -jar xxxx.jar</strong></li>
</ul>
<h2 id="JVM调优的参数都有哪些？（⭐）"><a href="#JVM调优的参数都有哪些？（⭐）" class="headerlink" title="JVM调优的参数都有哪些？（⭐）"></a>JVM调优的参数都有哪些？（⭐）</h2><ul>
<li><strong>设置堆空间大小</strong>：设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。<ul>
<li>-Xms：设置堆的初始化大小</li>
<li>-Xmx：设置堆的最大大小</li>
</ul>
</li>
<li><strong>虚拟机栈的大小</strong>：每个线程默认会开启1M的内存，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。<ul>
<li>-Xss   对每个线程stack大小的调整,-Xss128k</li>
</ul>
</li>
<li><strong>年轻代中Eden区和两个Survivor区的大小比例：</strong><ul>
<li>-XXSurvivorRatio&#x3D;8，表示年轻代中的分配比率：survivor:eden &#x3D; 2:8</li>
</ul>
</li>
<li><strong>年轻代晋升老年代阈值：默认为15。</strong><ul>
<li>-XX:MaxTenuringThreshold&#x3D;threshold</li>
</ul>
</li>
<li><strong>设置垃圾回收收集器：</strong><ul>
<li>-XX:+UseParallelGC</li>
<li>-XX:+UseG1GC</li>
</ul>
</li>
</ul>
<h2 id="JVM-调优的工具"><a href="#JVM-调优的工具" class="headerlink" title="JVM 调优的工具"></a>JVM 调优的工具</h2><ul>
<li><strong>命令工具：</strong><ul>
<li><strong>jps</strong>：输出JVM中运行的进程状态信息。	</li>
<li><strong>jstack</strong>：查看java进程内线程的堆栈信息。</li>
<li><strong>jmap</strong>：用于生成堆转存快照。</li>
<li><strong>jhat</strong>：用于分析jmap生成的堆转存快照。</li>
<li><strong>jstat</strong>：是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。</li>
</ul>
</li>
<li><strong>可视化工具：</strong><ul>
<li><strong>jconsole</strong>： 对 jvm 的内存，线程，类进行监控，是一个基于 jmx 的 GUI 性能监控工具。<ul>
<li>打开方式：java 安装目录 bin 目录下 直接启动 jconsole.exe 就行。</li>
</ul>
</li>
<li><strong>VisualVM</strong>：故障处理工具，能够监控线程，内存情况，查看方法的CPU时间和内存中的对象，已被GC的对象，反向查看分配的堆栈。<ul>
<li>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java内存泄露的排查思路"><a href="#Java内存泄露的排查思路" class="headerlink" title="Java内存泄露的排查思路"></a>Java内存泄露的排查思路</h2><p><strong>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况。</strong></p>
<ol>
<li>通过jmap或设置jvm参数获取堆内存快照dump</li>
<li>通过工具， VisualVM去分析dump文件，VisualVM可以加载离线的dump文件</li>
<li>通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</li>
<li>找到对应的代码，通过阅读上下文的情况，进行修复即可</li>
</ol>
<h2 id="CPU飙高排查方案与思路（⭐）"><a href="#CPU飙高排查方案与思路（⭐）" class="headerlink" title="CPU飙高排查方案与思路（⭐）"></a>CPU飙高排查方案与思路（⭐）</h2><ol>
<li>使用top命令查看占用cpu的情况，查看是哪一个进程占用cpu较高。</li>
<li>使用ps命令查看进程中的线程信息。</li>
<li>使用jstack命令查看进程中线程的信息，并定位到出问题的具体线程，最终定位问题。</li>
</ol>
<h2 id="什么是-OOM？如何分析及解决-OOM-问题-（⭐）"><a href="#什么是-OOM？如何分析及解决-OOM-问题-（⭐）" class="headerlink" title="什么是 OOM？如何分析及解决 OOM 问题?（⭐）"></a>什么是 OOM？如何分析及解决 OOM 问题?（⭐）</h2><h3 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h3><p>OOM，全称“Out Of Memory”，即内存溢出，来源于java.lang.OutOfMemoryError。当 JVM没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error。<br><strong>最常见的OOM情况有以下三种：</strong></p>
<ul>
<li>java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。</li>
<li>java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m -XX:MaxPermSize&#x3D;256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。</li>
<li>java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。</li>
</ul>
<h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><p>原因不外乎有两点：</p>
<ul>
<li>分配的内存少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。</li>
<li>应用占用内存太多，并且用完没释放，浪费了。此时就会造成<strong>内存泄露</strong>甚至<strong>内存溢出</strong>。</li>
</ul>
<h3 id="How？"><a href="#How？" class="headerlink" title="How？"></a>How？</h3><p><strong>如何预防？</strong></p>
<ul>
<li><strong>及时释放资源，防止内存泄漏</strong><ul>
<li>内存泄漏是导致OOM的一个重要原因。我们需要在代码中及时释放不再使用的内存，避免长时间占用内存资源。比如在Java中，使用finally块或try-with-resources语句，确保资源及时释放。</li>
</ul>
</li>
<li><strong>调整内存配置</strong><ul>
<li>针对不同的应用需求，合理配置内存参数。例如，在Java中，可以通过调整JVM的堆内存大小（-Xmx和-Xms参数）来满足应用的内存需求。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
	
	 
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
	
	<!-- require APlayer -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    <!-- require MetingJS-->
    <script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
    <!--qq音乐-->   
    <meting-js
		auto="https://c6.y.qq.com/base/fcgi-bin/u?__=nYC8LhwMbhVJ">
	</meting-js>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴华杰"
      src="/images/jay.jpg">
  <p class="site-author-name" itemprop="name">吴华杰</p>
  <div class="site-description" itemprop="description">Time will tell</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:1002372564@qq.com" title="E-Mail → mailto:1002372564@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-07-31 @ – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴华杰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">93k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:25</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共55.7k字</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='255,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
